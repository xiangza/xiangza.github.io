<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="翔仔"><meta name="copyright" content="翔仔"><meta name="generator" content="Hexo 5.4.2"><meta name="theme" content="hexo-theme-yun"><title>Spring | 翔仔的博客</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.2.4/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/@unocss/runtime/mini.global.js"></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"example.com","root":"/","title":"翔仔的小站","version":"1.8.11","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]},"vendors":{"darken":"https://cdn.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="spring简介SpringIOC什么是iocspring bean：定义的一个组件，这个组件的作用是实现某个功能。 ioc：控制反转，一种设计思想。 将对象的创建工作交给spring来处理，并将创建好的bean放到ioc容器中管理整个声明周期 DI：依赖注入，实现方式，将容器中的bean注入到应用程序中。 使用ioc之前：    使用ioc之后：     应用程序依赖于ioc容器管理的bean组">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring">
<meta property="og:url" content="http://example.com/2022/09/07/Spring/index.html">
<meta property="og:site_name" content="翔仔的博客">
<meta property="og:description" content="spring简介SpringIOC什么是iocspring bean：定义的一个组件，这个组件的作用是实现某个功能。 ioc：控制反转，一种设计思想。 将对象的创建工作交给spring来处理，并将创建好的bean放到ioc容器中管理整个声明周期 DI：依赖注入，实现方式，将容器中的bean注入到应用程序中。 使用ioc之前：    使用ioc之后：     应用程序依赖于ioc容器管理的bean组">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/09/07/Spring/study/blog/blog/source_posts/Spring/spring-framework-ioc-1.png">
<meta property="og:image" content="http://example.com/2022/09/07/Spring/study/blog/blog/source_posts/Spring/spring-framework-ioc-2.png">
<meta property="og:image" content="http://example.com/2022/09/07/Spring/study/blog/blog/source_posts/Spring/spring-framework-ioc-source-9.png">
<meta property="og:image" content="http://example.com/2022/09/07/Spring/study/blog/blog/source_posts/Spring/16ab581d21947171_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.awebp">
<meta property="og:image" content="http://example.com/2022/09/07/Spring/study/blog/blog/source_posts/Spring/spring-framework-ioc-source-100.png">
<meta property="og:image" content="http://example.com/2022/09/07/Spring/study/blog/blog/source_posts/Spring/1662987362760.png">
<meta property="og:image" content="http://example.com/2022/09/07/Spring/study/blog/blog/source_posts/Spring/1662987004411.png">
<meta property="og:image" content="http://example.com/2022/09/07/Spring/study/blog/blog/source_posts/Spring/1662987193290.png">
<meta property="og:image" content="http://example.com/2022/09/07/Spring/study/blog/blog/source_posts/Spring/1662990953859.png">
<meta property="og:image" content="http://example.com/2022/09/07/Spring/study/blog/blog/source_posts/Spring/1662779610485.png">
<meta property="og:image" content="http://example.com/2022/09/07/Spring/study/blog/blog/source_posts/Spring/spring-framework-ioc-source-102.png">
<meta property="og:image" content="http://example.com/2022/09/07/Spring/study/blog/blog/source_posts/Spring/1662950526009.png">
<meta property="article:published_time" content="2022-09-07T14:44:21.000Z">
<meta property="article:modified_time" content="2022-09-12T15:49:41.444Z">
<meta property="article:author" content="翔仔">
<meta property="article:tag" content="spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/09/07/Spring/study/blog/blog/source_posts/Spring/spring-framework-ioc-1.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="翔仔"><img width="96" loading="lazy" src="/images/tx.jpg" alt="翔仔"><span class="site-author-status" title="不想上学">😭</span></a><div class="site-author-name"><a href="/about/">翔仔</a></div><span class="site-name">翔仔的博客</span><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="我的主页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">28</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">10</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">21</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&amp;uin=910426929&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/YunYouJun" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="985391895@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#spring%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">spring简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringIOC"><span class="toc-number">2.</span> <span class="toc-text">SpringIOC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFioc"><span class="toc-number">2.1.</span> <span class="toc-text">什么是ioc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IOC%E9%85%8D%E7%BD%AE%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">IOC配置三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XML%E9%85%8D%E7%BD%AE"><span class="toc-number">2.2.1.</span> <span class="toc-text">XML配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E9%85%8D%E7%BD%AE"><span class="toc-number">2.2.2.</span> <span class="toc-text">java配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE"><span class="toc-number">2.2.3.</span> <span class="toc-text">注解配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">依赖注入三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setter%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">setter方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E6%B3%A8%E5%85%A5"><span class="toc-number">2.3.3.</span> <span class="toc-text">注解注入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IOC%E4%B8%8EDI%E5%B0%8F%E7%BB%93"><span class="toc-number">2.4.</span> <span class="toc-text">IOC与DI小结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E9%80%82%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%85%A5"><span class="toc-number">2.4.1.</span> <span class="toc-text">为什么推荐适用构造器方式注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Autowired%E5%92%8C-Resource%E4%BB%A5%E5%8F%8A-Inject%E7%AD%89%E6%B3%A8%E8%A7%A3%E6%B3%A8%E5%85%A5%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.2.</span> <span class="toc-text">@Autowired和@Resource以及@Inject等注解注入有何区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ioc%E4%B9%8BbeanFactory%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.5.</span> <span class="toc-text">ioc之beanFactory初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ioc%E4%B9%8Bbean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">2.6.</span> <span class="toc-text">ioc之bean的实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactory"><span class="toc-number">2.6.1.</span> <span class="toc-text">BeanFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactory%E4%B8%AD%E7%9A%84getBean%E7%9A%84%E4%B8%BB%E4%BD%93%E6%80%9D%E8%B7%AF"><span class="toc-number">2.6.2.</span> <span class="toc-text">BeanFactory中的getBean的主体思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BD%93%E6%80%9D%E8%B7%AF"><span class="toc-number">2.6.2.1.</span> <span class="toc-text">主体思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">2.6.3.</span> <span class="toc-text">循环依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">2.6.3.1.</span> <span class="toc-text">三级缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.3.2.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.6.4.</span> <span class="toc-text">Bean的生命周期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringAop"><span class="toc-number">3.</span> <span class="toc-text">SpringAop</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">常见面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%B0%88%E8%B0%88spring%E7%90%86%E8%A7%A3%EF%BC%8C%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">1、谈谈spring理解，原理和实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%B0%88%E8%B0%88springioc%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text">2、谈谈springioc的底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%8F%8F%E8%BF%B0%E4%BB%A5%E4%B8%8BBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.3.</span> <span class="toc-text">3、描述以下Bean的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.</span> <span class="toc-text">4、Spring如何解决循环依赖问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E7%BC%93%E5%AD%98%E6%94%BE%E7%BD%AE%E6%97%B6%E9%97%B4%E5%92%8C%E5%88%A0%E9%99%A4%E6%97%B6%E9%97%B4"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.1缓存放置时间和删除时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81BeanFactory%E4%B8%8EFactoryBean"><span class="toc-number">4.5.</span> <span class="toc-text">5、BeanFactory与FactoryBean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81spring%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.6.</span> <span class="toc-text">6、spring中用到的设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81spring%E7%9A%84aop%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">4.7.</span> <span class="toc-text">7、spring的aop底层原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81spring%E4%BA%8B%E5%8A%A1%E5%A6%82%E4%BD%95%E5%9B%9E%E6%BB%9A"><span class="toc-number">4.8.</span> <span class="toc-text">8、spring事务如何回滚</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E8%B0%88%E4%B8%80%E4%B8%8Bspring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD"><span class="toc-number">4.9.</span> <span class="toc-text">9、谈一下spring事务传播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81spring%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">4.10.</span> <span class="toc-text">10、spring事务隔离级别</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://example.com/2022/09/07/Spring/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="翔仔"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="翔仔的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Spring</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2022-09-07 22:44:21" itemprop="dateCreated datePublished" datetime="2022-09-07T22:44:21+08:00">2022-09-07</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2022-09-12 23:49:41" itemprop="dateModified" datetime="2022-09-12T23:49:41+08:00">2022-09-12</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E6%A1%86%E6%9E%B6/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">框架</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/spring/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">spring</span></a></span></div><div class="post-author"><span class="author-name">翔仔</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="spring简介"><a href="#spring简介" class="headerlink" title="spring简介"></a>spring简介</h1><h1 id="SpringIOC"><a href="#SpringIOC" class="headerlink" title="SpringIOC"></a>SpringIOC</h1><h2 id="什么是ioc"><a href="#什么是ioc" class="headerlink" title="什么是ioc"></a>什么是ioc</h2><p><strong>spring bean：</strong>定义的一个组件，这个组件的作用是实现某个功能。</p>
<p><strong>ioc：控制反转</strong>，一种设计思想。</p>
<p>将对象的创建工作交给spring来处理，并将创建好的bean放到ioc容器中管理整个声明周期</p>
<p><strong>DI：依赖注入</strong>，实现方式，将容器中的bean注入到应用程序中。</p>
<p>使用ioc之前：</p>
<p> <img src="/2022/09/07/Spring/study\blog\blog\source_posts\Spring\spring-framework-ioc-1.png" alt="img" loading="lazy"> </p>
<p>使用ioc之后：</p>
<p> <img src="/2022/09/07/Spring/study\blog\blog\source_posts\Spring\spring-framework-ioc-2.png" alt="img" loading="lazy"> </p>
<blockquote>
<p>应用程序依赖于ioc容器管理的bean组件（即对象资源），ioc容器注入应用程序所需要的对象资源</p>
</blockquote>
<h2 id="IOC配置三种方式"><a href="#IOC配置三种方式" class="headerlink" title="IOC配置三种方式"></a>IOC配置三种方式</h2><h3 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h3><p>将bean信息配置到xml文件中，通过spring加载文件来创建bean。</p>
<ul>
<li>优点：可以适用任何场景，结构清晰，通俗易懂</li>
<li>缺点，配置繁琐，不宜维护，扩展性差</li>
</ul>
<p><strong>例</strong></p>
<p>1、配置xxx.xml配置文件</p>
<p>2、声明命名空间和配置bean</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- services --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;tech.pdai.springframework.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="java配置"><a href="#java配置" class="headerlink" title="java配置"></a>java配置</h3><p>将类的创建交给配置的javaConfig类来完成，Spring只负责维护和管理，采用纯java创建方式。其本质就是把在xml上的配置声明转移到java配置类中。</p>
<ul>
<li>优点： 适用于任何场景，配置方便，因为是纯Java代码，扩展性高，十分灵活 </li>
<li>缺点 由于是采用Java类的方式，声明不明显，如果大量配置，可读性比较差 </li>
</ul>
<p><strong>例</strong></p>
<p>创建一个类声明为配置类，@Configuration</p>
<p>创建一个方法加上@Bean，该方法用于创建实例并返回，交给spring管理，方法名建议与实例名相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pdai</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeansConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user dao</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;userDao&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserDaoImpl <span class="title function_">userDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;userService&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserServiceImpl <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        userService.setUserDao(userDao());</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h3><p>通过在类上加注解方式，来声明一个类交给spring管理，spring会自动扫描带有@Component，@Controller，@Serice，@Repository这四个注解的类，然后区创建并管理，前提是需要先配置spring注解扫描器</p>
<ul>
<li>优点：方便维护</li>
<li>缺点：局限性，对于一些第三方资源只能用前两种方式加载</li>
</ul>
<p><strong>例</strong></p>
<p>对类添加@Component相关的注解，</p>
<p>设置ComponentScan的basePackage, 比如``, 或者<code>@ComponentScan(&quot;tech.pdai.springframework&quot;)</code>注解，或者 <code>new AnnotationConfigApplicationContext(&quot;tech.pdai.springframework&quot;)</code>指定扫描的basePackage.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pdai</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user dao impl.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDaoImpl userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * find user list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUserList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findUserList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖注入三种方式"><a href="#依赖注入三种方式" class="headerlink" title="依赖注入三种方式"></a>依赖注入三种方式</h2><blockquote>
<p>常用三种：setter注入、构造器注入、基于注解的注入</p>
</blockquote>
<h3 id="setter方式"><a href="#setter方式" class="headerlink" title="setter方式"></a>setter方式</h3><p>在xml配置方式中，property都是setter方式注入，比如下面的xml：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- services --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;tech.pdai.springframework.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>本质上包含两步：1、new UserServiceImpl()创建对象，需要默认构造器  2、通过setUserDao()注入userDao的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pdai</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user dao impl.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> UserDaoImpl userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * init.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * find user list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUserList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userDao.findUserList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set dao.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userDao user dao</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDaoImpl userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;!-- services --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;userService&quot;</span> class=<span class="string">&quot;tech.pdai.springframework.service.UserServiceImpl&quot;</span>&gt;</span><br><span class="line">        &lt;constructor-arg name=<span class="string">&quot;userDao&quot;</span> ref=<span class="string">&quot;userDao&quot;</span>/&gt;</span><br><span class="line">        &lt;!-- additional collaborators and configuration <span class="keyword">for</span> <span class="built_in">this</span> bean go here --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- more bean definitions <span class="keyword">for</span> services go here --&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>本质上是利用有参构造实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pdai</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user dao impl.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDaoImpl userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * init.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userDaoImpl user dao impl</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserDaoImpl userDaoImpl)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDaoImpl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * find user list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUserList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userDao.findUserList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解注入"><a href="#注解注入" class="headerlink" title="注解注入"></a>注解注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pdai</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user dao impl.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDaoImpl userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * find user list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUserList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findUserList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IOC与DI小结"><a href="#IOC与DI小结" class="headerlink" title="IOC与DI小结"></a>IOC与DI小结</h2><h3 id="为什么推荐适用构造器方式注入"><a href="#为什么推荐适用构造器方式注入" class="headerlink" title="为什么推荐适用构造器方式注入"></a>为什么推荐适用构造器方式注入</h3><p><code>这种方式可以保证注入的组件不可变，且确保需要的依赖不为空，此外构造器注入的依赖总是能够在返回客户端(组件)代码的时候保证完全初始化的状态</code></p>
<ul>
<li><strong>依赖不可变：</strong>这是final修饰</li>
<li><strong>需要的依赖不为空：</strong>当要实例化UserServiceImpl的时候，由于自己实现了有参构造，不会调用无参构造，那么就需要spring容器传入需要的参数，所以有两种情况：1、有该类型参数-&gt;传入 2、没有该类型参数-&gt;报错</li>
<li><strong>完全初始化状态：</strong>向构造器传参之前，要确保注入的内容不为空，那么肯定要调用依赖组件的构造方法完成实例化。而在Java类加载实例化的过程中，构造方法是最后一步（之前如果有父类先初始化父类，然后自己的成员变量，最后才是构造方法），所以返回来的都是初始化之后的状态。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pdai</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user dao impl.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDaoImpl userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * init.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userDaoImpl user dao impl</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(<span class="keyword">final</span> UserDaoImpl userDaoImpl)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDaoImpl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果适用setter注入，对于ioc意外环境，除了使用反射来提高需要的依赖外，无法复用该实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里只是模拟一下，正常来说我们只会暴露接口给客户端，不会暴露实现。</span></span><br><span class="line"><span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">userService.findUserList(); <span class="comment">// -&gt; NullPointerException, 潜在的隐患</span></span><br></pre></td></tr></table></figure>

<p><strong>循环依赖问题：</strong>使用field注入可能会导致循环依赖，即A里面注入B，B里面注入A</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用构造器注入，在spring项目启动的时候，就会抛出：BeanCurrentlyInCreationException：Requested bean is currently in creation: Is there an unresolvable circular reference？从而提醒你避免循环依赖，如果是field注入的话，启动的时候不会报错，在使用那个bean的时候才会报错。</p>
<h3 id="Autowired和-Resource以及-Inject等注解注入有何区别"><a href="#Autowired和-Resource以及-Inject等注解注入有何区别" class="headerlink" title="@Autowired和@Resource以及@Inject等注解注入有何区别"></a>@Autowired和@Resource以及@Inject等注解注入有何区别</h3><p><strong>@Autowired</strong></p>
<ul>
<li><p>注解源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以使用在以下地方：</span></span><br><span class="line"><span class="comment">	@Target(ElementType.CONSTRUCTOR) #构造函数</span></span><br><span class="line"><span class="comment">	@Target(ElementType.METHOD) #方法</span></span><br><span class="line"><span class="comment">	@Target(ElementType.PARAMETER) #方法参数</span></span><br><span class="line"><span class="comment">	@Target(ElementType.FIELD) #字段、枚举的常量</span></span><br><span class="line"><span class="comment">	@Target(ElementType.ANNOTATION_TYPE) #注解</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	还有一个value属性，默认为false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>总结</p>
<ul>
<li>@Autowired是spring自带注解，通过 AutowiredAnnotationBeanPostProcessor  类实现依赖注入</li>
<li>可以作用在构造函数、方法、方法参数、字段、注解</li>
<li>默认根据类型装配</li>
<li>如果有多个类型一样的bean候选者，需要指定按照名称进行装配，配合@Qualifier。指定名称后如果找不到对应bean会抛出 NoSuchBeanDefinitionException ，也可以将required设为false，如果找不到也不会抛异常</li>
</ul>
</li>
<li><p>简单使用</p>
<p>字段属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> HelloDao helloDao;</span><br></pre></td></tr></table></figure>

<p>或者构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HelloDao helloDao;</span><br><span class="line"><span class="keyword">public</span> HelloDao <span class="title function_">getHelloDao</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> helloDao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHelloDao</span><span class="params">(HelloDao helloDao)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.helloDao = helloDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HelloDao helloDao;</span><br><span class="line"><span class="comment">//@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HelloServiceImpl</span><span class="params">(<span class="meta">@Autowired</span> HelloDao helloDao)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.helloDao = helloDao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造器注入也可不写@Autowired，也可以注入成功。</span></span><br></pre></td></tr></table></figure>

<p>如果有多个候选者，会根据名称装配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;helloWorldDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> HelloDao helloDao;</span><br><span class="line"></span><br><span class="line"><span class="comment">//防止装配不成功时抛出异常</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;xxxxyyyy&quot;)</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> HelloDao helloDao;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>@Resource</strong></p>
<ul>
<li><p>注解源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Resource &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 其他省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@Target(ElementType.TYPE) #接口、类、枚举、注解</span></span><br><span class="line"><span class="comment">@Target(ElementType.FIELD) #字段、枚举的常量</span></span><br><span class="line"><span class="comment">@Target(ElementType.METHOD) #方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">name指定注入指定名称的组件</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>总结</p>
<ul>
<li>在javax.annotation包下</li>
<li>作用在接口、类、枚举、注解、字段、方法</li>
<li>根据属性名称自动装配</li>
<li>默认根据名称装配，如果有多个类型一样的bean候选，可以通过name指定注入</li>
</ul>
</li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperMan</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照属性名称 car 注入容器中的组件。如果容器中BMW还有BYD两种类型组件。指定加入BMW。</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperMan</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;BMW&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>name的作用类似于@Qualifier</p>
</li>
</ul>
<p><strong>@Inject</strong></p>
<ul>
<li><p>注解源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; METHOD, CONSTRUCTOR, FIELD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inject &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@Target(ElementType.CONSTRUCTOR) #构造函数</span></span><br><span class="line"><span class="comment">@Target(ElementType.METHOD) #方法</span></span><br><span class="line"><span class="comment">@Target(ElementType.FIELD) #字段、枚举的常量</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>总结</p>
<ul>
<li>导入javax.inject.Inject.jar包</li>
<li>可以作用在构造器、方法、字段、枚举的常量</li>
<li>默认根据类型自动i装配，如果需要按照名称装配，则需要配合@Named</li>
</ul>
</li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="keyword">private</span> Car car;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定加入BMW组件</span></span><br><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="meta">@Named(&quot;BMW&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Car car;</span><br></pre></td></tr></table></figure></li>
<li><p>总结</p>
<ul>
<li>@Autowired和@Inject用法基本一样，后者没有@Required属性</li>
<li>@Autowired和@Inject是默认按照类型匹配，@Resource按照名称匹配</li>
<li> @Autowired如果需要按照名称匹配需要和@Qualifier一起使用，@Inject和@Named一起使用，@Resource则通过name进行指定 </li>
</ul>
</li>
</ul>
<h2 id="ioc之beanFactory初始化"><a href="#ioc之beanFactory初始化" class="headerlink" title="ioc之beanFactory初始化"></a>ioc之beanFactory初始化</h2><p><a target="_blank" rel="noopener" href="https://javadoop.com/post/spring-ioc">https://javadoop.com/post/spring-ioc</a></p>
<blockquote>
<p>beanFactory的初始化主要包括，创建容器并从配置文件中加载、解析，生成bean的定义对象beanDefinition实例注册到容器</p>
</blockquote>
<p>ioc容器可以简单理解为线程安全的map结构，spring可以通过读取xml配置文件或使用注解配置类生成一个BeanDefinition放入到容器中，获取时通过反射技术将BeanDefinition对象转换为一个bean实例以及完成初始化。</p>
<p>IOC容器的初始化，<strong>可以概括为beanFactory的创建和BeanDefinition的建立和注册到容器</strong></p>
<p>SpringIOC容器对定义资源的载入是从refresh()函数开始</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">      <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">      <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">      <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">      <span class="comment">// 这块待会会展开说</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">         <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">         <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">         <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 重点，重点，重点</span></span><br><span class="line">         <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">         <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 把异常往外抛</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>obtainFreshBeanFactory：AbstractApplicationContext的obtainFreshBeanFactory()方法调用子类容器的refreshBeanFactory()方法，启动容器载入Bean定义资源文件的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这里使用了委派设计模式，父类定义了抽象的refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法</span></span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractApplicationContext类中只抽象定义了refreshBeanFactory()方法，容器真正调用的是其子类AbstractRefreshableApplicationContext实现的refreshBeanFactory()方法; 在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// 如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建DefaultListableBeanFactory，并调用loadBeanDefinitions(beanFactory)装载bean定义</span></span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        customizeBeanFactory(beanFactory); <span class="comment">// 对IoC容器进行定制化，如设置启动参数，开启注解的自动装配等 </span></span><br><span class="line">        loadBeanDefinitions(beanFactory); <span class="comment">// 调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器  </span></span><br><span class="line">        <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>BeanDefinition从加载到注册：</strong></p>
<p><strong>1、loadBeanDefinitions(DefaultListableBeanFactory beanFactory),实例化一个xmlBeanDefinitionReader来加载Bean</strong></p>
<p>​    读取配置的操作是通过BeanDefinitionReader接口定义的方法实现，因为配置文件的类型有多个，因此通过声明一个接口的方式来通过具体实现类读取指定配置文件信息</p>
<p><strong>2、</strong>xmlBean读取器通过父类的 AbstractBeanDefinitionReader 的<strong>loadBeanDefinitions(XmlBeanDefinitionReader reader)<strong>加载xml配置方式里的Bean定义的资源</strong>（A）</strong>和构造函数里配置的Bean配置文件<strong>（B）</strong>（虽然两个分支，但第二个分支也会解析路径转换为Resources进入4中）</p>
<p><strong>3、B：</strong>加载调用父类 AbstractBeanDefinitionReader 的**loadBeanDefinitions(String… locations)<strong>进而调用</strong>loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources)**方法</Resource></p>
<p>​    此方法做了两件事：1、调用资源加载器的获取资源方法resourceLoader.getResource(location)，获取到要加载的资源。 2、真正执行加载功能的是其子类 XmlBeanDefinitionReader的loadBeanDefinitions(resources)方法。 最终也会进入到**loadBeanDefinitions(Resource… resources)**中</p>
<p><strong>4、A/B：xmlBeanDefinitionReader加载Bean定义资源</strong></p>
<p>​    执行**loadBeanDefinitions(Resource… resources)**方法，本质是一个循环，每个文件是一个resource，内部调用loadBeanDefinitions(resource)方法，最后返回一个加载了多少个BeanDefinition</p>
<p>​    (1)loadBeanDefinitions(resource) —&gt; (2)loadBeanDefinitions(EncodedResource encodedResource) —&gt; (3)doLoadBeanDefinitions(InputSource inputSource, Resource resource)</p>
<p>​    doLoadBeanDefinitions方法进行两个操作，一个是将bean定义资源转换为Document对象；另一个操作是registerBeanDefinitions(Document doc, Resource resource)解析载入的Bean定义资源文件</p>
<p><strong>5、XmlBeanDefinitionReader解析载入的Bean定义资源文件</strong></p>
<p>​    XmlBeanDefinitionReader类中的doLoadBeanDefinitions方法是从特定XML文件中实际载入Bean定义资源的方法，该方法在载入Bean定义资源之后将其转换为Document对象，接下来调用registerBeanDefinitions启动Spring IoC容器对Bean定义的解析过程，即registerBeanDefinitions()方法</p>
<blockquote>
<p>Bean定义资源的载入和解析分为两个过程：1、通过XML解析器将Bean定义资源文件转换得到document对象。2、按照Spring的Bean规则对doxument对象解析</p>
<p>解析的过程是在BeanDefinitionDocumentReader的实现类 DefaultBeanDefinitionDocumentReader中实现的。 </p>
</blockquote>
<p>​    通过调用BeanDefinitionDocumentReader的实现类<strong>DefaultBeanDefinitionDocumentReader</strong>中的**registerBeanDefinitions(Document doc, XmlReaderContext readerContext)**方法进行解析document对象。</p>
<p>​    此方法内部由调用**doRegisterBeanDefinitions(Element root)<strong>，此方法为registerBeanDefinitions()方法的真正实现。其中的核心方法为</strong>parseBeanDefinitions(root, this.delegate)**从document根节点开始解析此对象</p>
<p>​    parseBeanDefinitions()方法的内部实现，根据不同的配置有两个方法走向：1、default namespace涉及的标签走向parseDefaultElement(ele, delegate)；2、其他namespace的元素走向parseCustomElement(ele)。</p>
<p>​    parseDefaultElement(ele, delegate)方法中对于bean标签的解析对应调用<strong>processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate)<strong>方法，内部先是生成了一</strong>BeanDefinitionHolder</strong>实例；接着通过<strong>BeanDefinitionReaderUtils.registerBeanDefinition()<strong>方法实现对解析后的BeanDefinition在ioc容器的</strong>注册</strong></p>
<blockquote>
<p>default namespace 涉及到的就四个标签 <import>、<alias>、<bean> 和 <beans></beans></bean></alias></import></p>
<p><strong>BeanDefinitionHolder</strong>里面是一个BeanDefinition和它的beanName、aliases三个信息</p>
</blockquote>
<p><strong>6、解析过后的BeanDefinition在IOC容器的注册</strong></p>
<p>​    Document对象经过解析后得到封装BeanDefinition的 <strong>BeanDefinitionHold</strong> 对象，然后调用<strong>BeanDefinitionReaderUtils.registerBeanDefinition()<strong>方法向IOC容器注册解析的Bean。内部通过调用</strong>BeanDefinitionReaderUtils.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition())<strong>方法完成真正的注册；</strong>同时</strong>如果有别名的话，也要根据别名注册一遍，以map结构存储：alias-&gt;beanName</p>
<p>​    **BeanDefinitionReaderUtils.registerBeanDefinition()**是由 IOC 实现 BeanDefinitionRegistry 接口来实现 即DafultListableBeanFactory。</p>
<p>​    DafultListableBeanFactory调用<strong>registerBeanDefinition()<strong>方法完成真正的注册。IOC容器本质是一个beanDefinitionMap，注册即将beanDefinition put到一个</strong>ConcurrentHashMap</strong>中。内部的实现中如果已经注册，那么会检查是否允许覆盖(一开始创建beanFactory时会设置参数)。如果没有注册，则put到beanDefinitionMap中同时会将每一个注册的beanName保存到ArrayList中。</p>
<p>7、至此，Bean定义资源文件中配置的Bean被解析过后，已经注册到IoC容器中，被容器管理起来，真正完成了IoC容器初始化所做的全部工作。现  在IoC容器中已经建立了整个Bean的配置信息，这些BeanDefinition信息已经可以使用，并且可以被检索，IoC容器的作用就是对这些注册的Bean定义信息进行处理和维护。这些的注册的Bean定义信息是IoC容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。</p>
<p> <img src="/2022/09/07/Spring/study\blog\blog\source_posts\Spring\spring-framework-ioc-source-9.png" alt="img" loading="lazy"> </p>
<h2 id="ioc之bean的实例化"><a href="#ioc之bean的实例化" class="headerlink" title="ioc之bean的实例化"></a>ioc之bean的实例化</h2><blockquote>
<p>spring主要通过将资源配置加载、解析，生成BeanDefinition并注册到ioc容器中，容器中存放的是Bean的定义即BeanDefinition放到BeanDefinitionMap中，本质是一个 ConcurrentHashMap&lt;String, Object&gt; 。接着便是从BeanDefinition中实例化Bean实例</p>
</blockquote>
<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>BeanFactory是spring提供的用于获取bean实例的接口，有一个核心方法，getBean()，通过该方法可以获取一个bean实例。在spring中该接口由DefaultListableBeanFactory实现，真正的业务处理在AbstractBeanFactory类。通过如下</p>
<p> <img src="/2022/09/07/Spring/study\blog\blog\source_posts\Spring\16ab581d21947171_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.awebp" alt="img" loading="lazy"> </p>
<p>getBean的入口在<strong>DefaultListableFactory</strong>， 准确来说是在<code>AbstractBeanFactory</code>这个类里面，因为getBean()的很多实现都是在<code>AbstractBeanFactory</code>这个抽象类里面。 </p>
<h3 id="BeanFactory中的getBean的主体思路"><a href="#BeanFactory中的getBean的主体思路" class="headerlink" title="BeanFactory中的getBean的主体思路"></a>BeanFactory中的getBean的主体思路</h3><blockquote>
<p>BeanFactory定义了Bean容器的规范。通过bean的名字，Class类型和构造函数参数来得到bean实例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据bean的名字和Class类型和构造函数的参数类型等来得到bean实例    </span></span><br><span class="line">Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException;    </span><br><span class="line">Object <span class="title function_">getBean</span><span class="params">(String name, Class requiredType)</span> <span class="keyword">throws</span> BeansException;    </span><br><span class="line">Object <span class="title function_">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException;</span><br></pre></td></tr></table></figure>

<p>BeanDefinition中包含了这个类的Class信息以及是否单例等 <img src="/2022/09/07/Spring/study\blog\blog\source_posts\Spring\spring-framework-ioc-source-100.png" alt="img" loading="lazy"> </p>
<p>简单的实现Object getBean(String name)思路：</p>
<ul>
<li><p>从beanDefeinitionMap中通过beanName获得BeanDefinition</p>
</li>
<li><p>从BeanDefinition中获得beanClasName</p>
</li>
<li><p>通过反射初始化BeanClassName的实例instance</p>
<ul>
<li>构造好念书从BeanDefinition的getConstructorArgumentValues()方法获取</li>
<li>属性值从BeanDefinition的getPropertyValues()方法获取</li>
</ul>
</li>
<li><p>返回beanName的实例instance</p>
</li>
</ul>
<h4 id="主体思路"><a href="#主体思路" class="headerlink" title="主体思路"></a>主体思路</h4><p>BeanFactory实现getBean()方法在AbstractBeanFactory中，这个方法内部又在调用doGetBean方法进行实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">  <span class="keyword">return</span> doGetBean(name, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">  <span class="keyword">return</span> doGetBean(name, requiredType, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">  <span class="keyword">return</span> doGetBean(name, <span class="literal">null</span>, args, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object... args)</span></span><br><span class="line">    <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">  <span class="keyword">return</span> doGetBean(name, requiredType, args, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而doGetBean的核心逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span>&#123;</span><br><span class="line"><span class="comment">//解析bean的真正name，如果bean是工厂类，name前缀会加&amp;，需要去掉</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line"><span class="comment">//核心1：从单例容器中获取缓存的bean</span></span><br><span class="line"> <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line"> <span class="comment">//如果从单例容器中到缓存的bean而且构造函数参数列表为空</span></span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//核心2：直接获取实例</span></span><br><span class="line">    bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//验证当前bean实例是否正在创建中，如果是 直接抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//中间省略了通过工厂方式创建bean的代码</span></span><br><span class="line">    .............</span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//核心3：将当前bean实例放入alreadyCreated集合里，标识这个bean准备创建了</span></span><br><span class="line">    markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//从BeanDefinitions中获取该实例的BeanDefinition</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="comment">//检查要创建的实例bean的修饰符，是否允许被实例化</span></span><br><span class="line">	    checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">        <span class="comment">//省略了实例化bean的所有依赖bean的过程,创建过程是一样的</span></span><br><span class="line">         .............</span><br><span class="line">             <span class="comment">// Create bean instance.</span></span><br><span class="line">		<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">         <span class="comment">//核心4：创建单例bean</span></span><br><span class="line">		sharedInstance = getSingleton(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">         <span class="comment">//为了解决循环依赖，spring将使用ObjectFactory表示bean，提前暴露bean</span></span><br><span class="line">         <span class="comment">//当真正属性注入的时候，调用ObjectFactory的getObject()方法获取bean实例</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//核心5：真正创建bean的方法，重点要看的方法   </span></span><br><span class="line">		<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">		&#125;<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="comment">//如果创建bean异常 做一些清除工作</span></span><br><span class="line">         <span class="comment">//包括将bean从alreadyCreated，singletonsCurrentlyInCreation等容器中清除</span></span><br><span class="line">		destroySingleton(beanName);</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;&#125;&#125;);</span><br><span class="line">        <span class="comment">//获取真正的bean，由于bean可以通过FactortBean或者工厂bean的方式创建</span></span><br><span class="line">        <span class="comment">//所以这个方法用于从Factorybean或者工厂bean获取要创建的真正的bean</span></span><br><span class="line">	    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">		  &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">          <span class="comment">//省略  原型模式的创建</span></span><br><span class="line">            .............</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//省略scope作用于的创建</span></span><br><span class="line">             .............</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(BeansException ex)&#123;</span><br><span class="line">        cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//如果requiredType不为空，尝试将获取的bean转换成requiredType</span></span><br><span class="line">        .............</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主要内容：</strong></p>
<ul>
<li>解析bean的真正name，如果bean是共产类，name前缀会加&amp;，需要去掉</li>
<li>无参单例先从缓存中尝试获取</li>
<li>如果bean实例还在创建中，则直接抛出异常</li>
<li>如果bean definition存在于父的bean工厂中，委托给父bean工厂获取</li>
<li>标记这个beanName的实例正在创建</li>
<li>确保它的依赖也被初始化</li>
<li>真正创建<ul>
<li>单例时</li>
<li>原型时</li>
<li>根据bean的scope创建</li>
</ul>
</li>
</ul>
<p><strong>详细流程</strong>：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903843596107790#heading-9">https://juejin.cn/post/6844903843596107790#heading-9</a></p>
<h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><p>A依赖B，B依赖A，在属性赋值时形成一个闭环，发生循环依赖。</p>
<p><img src="/2022/09/07/Spring/study\blog\blog\source_posts\Spring\1662987362760.png" alt="1662987362760" loading="lazy"></p>
<p>spring中bean都是单例的，整个容器只有一个对象，打破当前闭环，解决循环依赖：实例化、初始化分开</p>
<p><img src="/2022/09/07/Spring/study\blog\blog\source_posts\Spring\1662987004411.png" alt="1662987004411" loading="lazy"></p>
<p>而属性的赋值有两种方式：一位构造器方式属性赋值，这种循环依赖无法解决；另一种通过set方式属性赋值，可以通过三级缓存，提前暴露对象来解决循环依赖。</p>
<p>bean对象创建的核心：</p>
<p><img src="/2022/09/07/Spring/study\blog\blog\source_posts\Spring\1662987193290.png" alt="1662987193290" loading="lazy"></p>
<p>容器中的对象的状态有两种：完整的、不完整的。如果可以将不完整的对象提前存储到容器中，即可解决循环依赖，即一级缓存存储完整对象，二级缓存存储提前暴露的半成品对象</p>
<h4 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h4><blockquote>
<p>为什么需要三级缓存</p>
</blockquote>
<p>1、三级缓存分别存放什么对象？</p>
<p>​    1、完整对象；2、不完整对象；3、lamda表达式(访问时，返回一个不完整对象存入二级缓存)</p>
<p>2、只有一级缓存可以吗？</p>
<p>​    不行，这样的话，完整和不完整对象存放到一起，进行对象获取时有可能获取到不完整对象，无法使用</p>
<p>3、只有二级缓存可以吗？</p>
<p>​    三级缓存使用到的地方：1、getSingleton；2、doCreateBean</p>
<p>​    只有二级缓存也可以解决循环依赖问题</p>
<p>4、二级缓存也可以，为什么还要三级缓存？</p>
<p>​    1、二级缓存基础上添加aop，报错 This means that said other beans do not use the final version of the bean。没有使用最终状态的bean</p>
<p>​    2、如果一个对象需要被代理，生成代理对象需要预先生成非代理对象。</p>
<p>​    3、lamda表达式 getEarlyBeanReference的逻辑：如果没有代理对象直接返回bean，否则用代理对象替换对象。如果没有三级缓存，就无法得到代理对象，即整个容器中包含了代理对象和非代理对象。<strong>但是</strong>，容器中对象默认单例，意味着根据名称只能获取一个对象的值，此时容器<strong>同时存在</strong>两个对象的话，使用的时候无法确定<strong>使用哪一个</strong>以及无法确认<strong>什么时候会调用</strong>当前对象，是在其他对象的执行中调用，无法人为控制，因此必须<strong>保证容器中任何时刻都只有一个对象供外部调用</strong>。所以在三级缓存中，完成了一件代理对象替换非代理对象的工作(如果有代理对象)，确定返回的唯一对象 </p>
<p>​    4、<code>三级缓存是为了解决在aop代理过程中产生的循环依赖问题，如果没有aop的话，二级足以解决循环依赖问题</code></p>
<p>相当于一个回调机制，当需要使用当前对象时，会判断此对象是否需要被代理对象实现，如果需要直接替换，不需要直接返回代理对象即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="number">256</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>第一层缓存(singletonObjects)：单例对象池，已经实例化并且属性赋值，完整对象</li>
<li>第二层缓存(earlySingletonObjects)：单例对象缓存池，已经实例化但未属性赋值</li>
<li>第三层缓存(singletonFactories)：单例工厂的缓存</li>
</ul>
<p><code>getSingleton(beanName):</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">         <span class="comment">//从singletonObjects（一级缓存）中尝试获取</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">         <span class="comment">//如果缓存不存在&amp;&amp;对象在建立中，则尝试从earlySingletonObjects（二级缓存）中获取</span></span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="comment">//为了线程安全将单例的IOC容器锁起来</span></span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">                 <span class="comment">//从二级缓存(提前暴露容器)中查找是否存在对应的ObjectFactory</span></span><br><span class="line">				singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">				<span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                     <span class="comment">//如果还是找不到就从bean工厂类的缓存中查找</span></span><br><span class="line">					ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">					<span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                          <span class="comment">//从singletonFactories经过getObect获取，经过三级缓存获取</span></span><br><span class="line">						singletonObject = singletonFactory.getObject();</span><br><span class="line">                          <span class="comment">//将创建的bean放入到提前暴露容器集合里</span></span><br><span class="line">						<span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                          <span class="comment">//因为已经存在了实例无需再通过工厂创建，</span></span><br><span class="line">                          <span class="comment">//将创建该实例的工厂从工厂让其中删除</span></span><br><span class="line">						<span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//返回从缓存中获取结果</span></span><br><span class="line">		<span class="keyword">return</span> (singletonObject != hNULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>isSingletonCurrentlyInCreation()</code>：判断当前单例bean是否正在建立中，也就是没有初始化完成(好比A的构造器依赖了B对象因此得先去建立B对象， 或则在A的populateBean过程当中依赖了B对象，得先去建立B对象，这时的A就是处于建立中的状态。)</p>
<p><code>allowEarlyReference</code> ：是否容许从singletonFactories中经过getObject拿到对象</p>
<p>Spring首先从一级缓存singletonObjects中获取。若是获取不到，而且对象正在建立中，就再从二级缓存earlySingletonObjects中获取。若是仍是获取不到且容许singletonFactories经过getObject()获取，就从三级缓存singletonFactory.getObject()(三级缓存)获取，若是获取到了则从三级缓存移动到了二级缓存。</p>
<p>从上述分析可知，循环依赖的解决依赖于singletonFactories这个三级cache。这个cache的类型是ObjectFactory。定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在bean建立过程中，有两处匿名内部类实现了该接口，<strong>一处是</strong>spring创建bean的时候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sharedInstance = getSingleton(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">         <span class="comment">//为了解决循环依赖，spring将使用ObjectFactory表示bean，提前暴露bean</span></span><br><span class="line">         <span class="comment">//当真正属性注入的时候，调用ObjectFactory的getObject()方法获取bean实例</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//核心5：真正创建bean的方法，重点要看的方法   </span></span><br><span class="line">		<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">		&#125;<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="comment">//如果创建bean异常 做一些清除工作</span></span><br><span class="line">         <span class="comment">//包括将bean从alreadyCreated，singletonsCurrentlyInCreation等容器中清除</span></span><br><span class="line">		destroySingleton(beanName);</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;&#125;&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>另一处是</strong>通过ObjectFacstory暴露bean的时候：在createBenaInstance方法执行后。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将bean对应的objectFactory的lamda表达式添加到三级缓存</span></span><br><span class="line">addSingletonFactory(beanName,() -&gt; getEarlyBeanRefrence(beanName,mbd,bean));</span><br></pre></td></tr></table></figure>

<p>此处是解决循环依赖的关键，执行此段代码时单例对象已经被建立只是未被完全初始化完成。<strong>getEarlyBeanReference</strong>会将bean实例返回暴露出来。存到二级缓存。</p>
<p>三级缓存存放的是ObjectFactory的lamda表达式用来在get时暴露半成品对象</p>
<p><img src="/2022/09/07/Spring/study\blog\blog\source_posts\Spring\1662990953859.png" alt="1662990953859" loading="lazy"></p>
<blockquote>
<p>举例</p>
</blockquote>
<p>“A依赖B，B依赖A”。A先进行初始化并将自身通过objectFactory暴露出来，发现依赖B，此时尝试get(B)，发现未被创建就去创建B，此时发现B又依赖于A，就去get(A)。通过三层缓存查询，因为A经过objectFactory暴露，因此通过objectFactory.getObject获取A对象(半成品)，并将A从三级缓存放入二级缓存。所以B可以完成完整初始化被存放到一级缓存中。再返回A，此时A能拿到B对象顺利初始化完成。解决循环依赖。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><code>spring为什么不能解决构造器的循环依赖?</code></p>
<p>构造器注入形成的循环依赖：BeanB需要在BeanA的构造器完成初始化，BeanA也需要在BeanB构造器完成初始化。这种情况都不能完成</p>
<p>而Spring解决循环依赖主要依赖的是<strong>三级缓存</strong>，<strong>但在调用构造方法之前还未将其放入三级缓存中</strong>。因此后续的依赖调用构造方法的时候并不能从三级缓存中获取到依赖的Bean，因此不能解决</p>
<p><code>Spring为什么不能解决prototype作用域的循环依赖？</code></p>
<p>Spring不会缓存prototype作用域的bean，而spring的循环依赖的解决正是靠着缓存实现的</p>
<p><code>spring为什么不能解决多例的循环依赖？</code></p>
<p> 多实例Bean是每次调用一次getBean都会执行一次构造方法并且给属性赋值，根本没有三级缓存，因此不能解决循环依赖。 </p>
<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p><img src="/2022/09/07/Spring/study\blog\blog\source_posts\Spring\1662779610485.png" alt="1662779610485" loading="lazy"></p>
<blockquote>
<p>Spring 只帮我们管理单例模式 Bean 的<strong>完整</strong>生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。 </p>
</blockquote>
<p><strong>Spring容器中Bean的声明流程</strong></p>
<p> <img src="/2022/09/07/Spring/study\blog\blog\source_posts\Spring\spring-framework-ioc-source-102.png" alt="img" loading="lazy"> </p>
<ul>
<li><p>如果BeanFactoryPostProcesser和Bean关联，则调用postProcessBeanFactory方法（即首先尝试从Bean工厂获取Bean）</p>
</li>
<li><p>如果InstantiationAwareBeanPostProcessor和Bean关联。则调用postProcessBeforeInstantiation方法</p>
</li>
<li><p>根据配置<strong>实例化Bean</strong></p>
</li>
<li><p>利用依赖注入完成<strong>属性赋值</strong></p>
</li>
<li><p>如果InstantiationAwareBeanPostProcessor和Bean关联，则调用postProcessAfterInstantiation方法和postProcessProperties方法</p>
</li>
<li><p><strong>调用xxxAware接口</strong></p>
<p><strong>第一类Aware接口</strong></p>
<ul>
<li>如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的 setBeanName() 方法传入当前 Bean 的 id 值。</li>
<li>如果 Bean 实现了 BeanClassLoaderAware 接口，则 Spring 调用 setBeanClassLoader() 方法传入classLoader的引用。</li>
<li>如果 Bean 实现了 BeanFactoryAware 接口，则 Spring 调用 setBeanFactory() 方法传入当前工厂实例的引用。</li>
</ul>
<p><strong>第二类Aware接口</strong></p>
<ul>
<li>如果 Bean 实现了 EnvironmentAware 接口，则 Spring 调用 setEnvironment() 方法传入当前 Environment 实例的引用。</li>
<li>如果 Bean 实现了 EmbeddedValueResolverAware 接口，则 Spring 调用 setEmbeddedValueResolver() 方法传入当前 StringValueResolver 实例的引用。</li>
<li>如果 Bean 实现了 ApplicationContextAware 接口，则 Spring 调用 setApplicationContext() 方法传入当前 ApplicationContext 实例的引用。</li>
<li>…</li>
</ul>
</li>
<li><p>如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的预初始化方法 postProcessBeforeInitialzation() 对 Bean 进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。</p>
</li>
<li><p>如果 Bean 实现了 InitializingBean 接口，则 Spring 将调用 afterPropertiesSet() 方法。(或者有执行@PostConstruct注解的方法)</p>
</li>
<li><p>如果在配置文件中通过 <strong>init-method</strong> 属性指定了初始化方法，则调用该初始化方法。</p>
</li>
<li><p>如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的初始化方法 postProcessAfterInitialization()。此时，Bean 已经可以被应用系统使用了。</p>
</li>
<li><p>如果在 <code>中指定了该 Bean 的作用范围为 scope=&quot;singleton&quot;，则将该 Bean 放入 Spring IoC 的缓存池中，将触发 Spring 对该 Bean 的生命周期管理；如果在</code> 中指定了该 Bean 的作用范围为 scope=”prototype”，则将该 Bean 交给调用者，调用者管理该 Bean 的生命周期，Spring 不再管理该 Bean。</p>
</li>
<li><p>如果 Bean 实现了 DisposableBean 接口，则 Spring 会调用 destory() 方法将 Spring 中的 Bean 销毁；(或者有执行@PreDestroy注解的方法)</p>
</li>
<li><p>如果在配置文件中通过 <strong>destory-method</strong> 属性指定了 Bean 的销毁方法，则 Spring 将调用该方法对 Bean 进行销毁。</p>
</li>
</ul>
<p>Bean生命周期完整的方法可以分为以下几类：</p>
<ul>
<li><p><strong>Bean自身的方法</strong>： 这个包括了Bean本身调用的方法和通过配置文件中``的init-method和destroy-method指定的方法</p>
</li>
<li><p><strong>Bean级生命周期接口方法</strong>： 这个包括了BeanNameAware、BeanFactoryAware、ApplicationContextAware；当然也包括InitializingBean和DiposableBean这些接口的方法（可以被@PostConstruct和@PreDestroy注解替代)</p>
</li>
<li><p><strong>容器级生命周期接口方法</strong>： 这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</p>
</li>
<li><p><strong>工厂后处理器接口方法</strong>： 这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</p>
</li>
</ul>
<p><code>举例</code></p>
<p>定义Bean（这里是User）, 并让它实现BeanNameAware,BeanFactoryAware,ApplicationContextAware接口和InitializingBean,DisposableBean接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.pdai.springframework.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactoryAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pdai</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, BeanNameAware, ApplicationContextAware,</span><br><span class="line">        InitializingBean, DisposableBean &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user&#x27;s name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user&#x27;s age.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * bean factory.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * application context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * bean name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String beanName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;execute User#new User()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;execute User#setName(&#123;&#125;)&quot;</span>, name);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;execute User#setAge(&#123;&#125;)&quot;</span>, age);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;execute BeanFactoryAware#setBeanFactory&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;execute BeanNameAware#setBeanName&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.beanName = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;execute ApplicationContextAware#setApplicationContext&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;execute DisposableBean#destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;execute InitializingBean#afterPropertiesSet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doInit</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;execute User#doInit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;execute User#doDestroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>定义BeanFactoryPostProcessor实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pdai</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;execute BeanFactoryPostProcessor#postProcessBeanFactory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义In’stantiationAwareBeanPostProcessor实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pdai</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInstantiationAwareBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">InstantiationAwareBeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;execute InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation for &#123;&#125;&quot;</span>, beanName);</span><br><span class="line">        <span class="keyword">return</span> InstantiationAwareBeanPostProcessor.<span class="built_in">super</span>.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;execute InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation for &#123;&#125;&quot;</span>, beanName);</span><br><span class="line">        <span class="keyword">return</span> InstantiationAwareBeanPostProcessor.<span class="built_in">super</span>.postProcessAfterInstantiation(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;execute InstantiationAwareBeanPostProcessor#postProcessProperties for &#123;&#125;&quot;</span>, beanName);</span><br><span class="line">        <span class="keyword">return</span> InstantiationAwareBeanPostProcessor.<span class="built_in">super</span>.postProcessProperties(pvs, bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>定义BeanPostProcessor实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pdai</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;execute BeanPostProcessor#postProcessBeforeInitialization for &#123;&#125;&quot;</span>, beanName);</span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="built_in">super</span>.postProcessBeforeInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;execute BeanPostProcessor#postProcessAfterInitialization for &#123;&#125;&quot;</span>, beanName);</span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="built_in">super</span>.postProcessAfterInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>初始化Bean</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pdai</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeansConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;user&quot;, initMethod = &quot;doInit&quot;, destroyMethod = &quot;doDestroy&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;pdai&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cglib proxy demo.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pdai</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * main interface.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Init application context&quot;</span>);</span><br><span class="line">        <span class="comment">// create and configure beans</span></span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(</span><br><span class="line">                <span class="string">&quot;tech.pdai.springframework&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// retrieve configured instance</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// print info from beans</span></span><br><span class="line">        log.info(user.toString());</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;Shutdown application context&quot;</span>);</span><br><span class="line">        context.registerShutdownHook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">42.547</span> [main] INFO tech.pdai.springframework.App - Init application context</span><br><span class="line">...</span><br><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">43.134</span> [main] INFO tech.pdai.springframework.processor.MyBeanFactoryPostProcessor - execute BeanFactoryPostProcessor#postProcessBeanFactory</span><br><span class="line">...</span><br><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">43.216</span> [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean <span class="string">&#x27;user&#x27;</span></span><br><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">43.216</span> [main] INFO tech.pdai.springframework.processor.MyInstantiationAwareBeanPostProcessor - execute InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation <span class="keyword">for</span> user</span><br><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">43.236</span> [main] INFO tech.pdai.springframework.entity.User - execute User#<span class="keyword">new</span> <span class="title class_">User</span>()</span><br><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">43.237</span> [main] INFO tech.pdai.springframework.entity.User - execute User#setName(pdai)</span><br><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">43.237</span> [main] INFO tech.pdai.springframework.entity.User - execute User#setAge(<span class="number">18</span>)</span><br><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">43.237</span> [main] INFO tech.pdai.springframework.processor.MyInstantiationAwareBeanPostProcessor - execute InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation <span class="keyword">for</span> user</span><br><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">43.237</span> [main] INFO tech.pdai.springframework.processor.MyInstantiationAwareBeanPostProcessor - execute InstantiationAwareBeanPostProcessor#postProcessProperties <span class="keyword">for</span> user</span><br><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">43.242</span> [main] INFO tech.pdai.springframework.entity.User - execute BeanNameAware#setBeanName</span><br><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">43.242</span> [main] INFO tech.pdai.springframework.entity.User - execute BeanFactoryAware#setBeanFactory</span><br><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">43.242</span> [main] INFO tech.pdai.springframework.entity.User - execute ApplicationContextAware#setApplicationContext</span><br><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">43.242</span> [main] INFO tech.pdai.springframework.processor.MyBeanPostProcessor - execute BeanPostProcessor#postProcessBeforeInitialization <span class="keyword">for</span> user</span><br><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">43.242</span> [main] INFO tech.pdai.springframework.entity.User - execute InitializingBean#afterPropertiesSet</span><br><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">43.243</span> [main] INFO tech.pdai.springframework.entity.User - execute User#doInit</span><br><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">43.243</span> [main] INFO tech.pdai.springframework.processor.MyBeanPostProcessor - execute BeanPostProcessor#postProcessAfterInitialization <span class="keyword">for</span> user</span><br><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">43.270</span> [main] INFO tech.pdai.springframework.App - User(name=pdai, age=<span class="number">18</span>)</span><br><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">43.270</span> [main] INFO tech.pdai.springframework.App - Shutdown application context</span><br><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">43.276</span> [SpringContextShutdownHook] INFO tech.pdai.springframework.entity.User - execute DisposableBean#destroy</span><br><span class="line"><span class="number">12</span>:<span class="number">44</span>:<span class="number">43.276</span> [SpringContextShutdownHook] INFO tech.pdai.springframework.entity.User - execute User#doDestroy</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="SpringAop"><a href="#SpringAop" class="headerlink" title="SpringAop"></a>SpringAop</h1><h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h2 id="1、谈谈spring理解，原理和实现？"><a href="#1、谈谈spring理解，原理和实现？" class="headerlink" title="1、谈谈spring理解，原理和实现？"></a>1、谈谈spring理解，原理和实现？</h2><p>总：</p>
<p>控制反转：理论思想，由原来的对象由使用者来控制转换为把对象交给spring来进行管理</p>
<p>​            DI：依赖注入，把对应属性的值注入到具体对象中。@Autowired，populateBean完成属性注入</p>
<p>容器：存储对象，map结构存储，在spring存在三级缓存，singletonObject存放完整对象，earlySingletonObjects存放不完整提前暴露出来的对象，singletonFactories存放objectFactory将bean暴露。</p>
<p>​            整个bean的声明周期，从创建到使用到销毁的过程全部都是由容器来管理</p>
<p>分：</p>
<ol>
<li>要设计到容器的创建过程(beanFactory、DefaultListableBeanFactory)，向bean工厂设置一些参数(是否可覆盖、是否允许循环依赖、beanPostProcessor、Aware接口的子类等)</li>
<li>加载解析Bean，准备创建bean的定义对象beanDefinition</li>
<li>beanFactoryPostProcessor的处理，<strong>此处是扩展点</strong>，如PlaceHolderConfigurSupport、ConfigurationClassPostProcessor</li>
<li>BeanPostProcessor的注册功能，方便后续对bean对象完成具体的扩展功能</li>
<li>通过反射的方式将BeanDefinition对象实例化成具体的bean对象</li>
<li>bean对象的初始化过程（填充属性、 调用aware子类的方法、调用BeanPostProcessor的前置处理方法，调用init-method，调用BeanPostProcessor的后置处理方法）</li>
<li>生成完整的bean对象，通过getBean()可以直接获取</li>
<li>销毁过程</li>
</ol>
<blockquote>
<p>spring中的bean都是用过反射机制实现的，同时其中包含了很多扩展点，比如最常用的benaFactory的扩展（比如占位符）和bean的扩展.</p>
<p>ioc最核心的就是填充具体bean的属性，bean的声明周期</p>
</blockquote>
<h2 id="2、谈谈springioc的底层实现"><a href="#2、谈谈springioc的底层实现" class="headerlink" title="2、谈谈springioc的底层实现"></a>2、谈谈springioc的底层实现</h2><p>对他的理解和了解过的实现过程：</p>
<p>反射、工厂、设计模式(如果会)，关键的几个方法如：createBeanFactory、getBean、doGetBean、createBean、doCreateBean、createBeanInstance、populateBean、InitializingBean</p>
<ol>
<li>先通过createBeanFactory创建一个Bean工厂（DefaultListableBeanFactory）</li>
<li>开始循环创建对象，因为容器中bean默认为单例，因此优先通过getBean、doGetBean从容器中查找</li>
<li>如果找不到，则通过createBean、doCreateBean方法，以反射方式创建对象，一般情况下使用的是无参构造方法（getDeclaredConstructor，newInstance）</li>
<li>进行对象的属性填充populateBean</li>
<li>进行其他初始化操作（InitializingBean）</li>
</ol>
<h2 id="3、描述以下Bean的生命周期"><a href="#3、描述以下Bean的生命周期" class="headerlink" title="3、描述以下Bean的生命周期"></a>3、描述以下Bean的生命周期</h2><ol>
<li>实例化bean：反射方式生成对象</li>
<li>填充属性：populateBean，循环依赖问题（三级缓存）</li>
<li>调用aware接口的方法：InvokeAwareMethod（完成BeanName、BeanFactory、BeanClassLoader等对象的属性设置）</li>
<li>调用BeanPostProcessor的前置处理方法</li>
<li>调用init-method方法：在这之前判断是否实现了initializingBean接口，如果有，调用afterPropertiesSet方法，否则不调用</li>
<li>调用BeanPostProcessor的后置处理方法：spring的aop在此实现，AbstractAutoProxyCreater注册Deftuction相关回调接口：钩子方法</li>
<li>获取完整对象，可以通过getBean的方式来进行对象的获取</li>
<li>销毁流程，1、判断是否实现了DispoableBean接口。2、调用destroyMethod方法</li>
</ol>
<h2 id="4、Spring如何解决循环依赖问题"><a href="#4、Spring如何解决循环依赖问题" class="headerlink" title="4、Spring如何解决循环依赖问题"></a>4、Spring如何解决循环依赖问题</h2><p>三级缓存  提前暴露对象  aop</p>
<p>总：什么是循环依赖问题，A依赖B，B依赖A</p>
<p><img src="/2022/09/07/Spring/study\blog\blog\source_posts\Spring\1662950526009.png" alt="1662950526009" loading="lazy"></p>
<p>分：先说明bean的创建过程：实例化、初始化（填充属性）</p>
<ol>
<li>创建A对象，实例化A，此时属性b为空，填充属性b</li>
<li>从容器中查找b，如果找到了，直接赋值不存在循环依赖，找不到创建B对象</li>
<li>创建B对象，实例化B，此时属性a为空，填充属性a</li>
<li>从容器中查找a，找不到，直接创建</li>
</ol>
<p>形成闭环的原因</p>
<p>事实上，此时a对象存在，但此时是一个不完整对象，只完成实例化，而没有初始化。</p>
<p>因此可以优先把非完整状态的对象赋值，等待后续操作来完成赋值，相当于提前暴露了某个不完整对象</p>
<p>当所有的对象都完成实例化和初始化操作后，还要把完整对象存入容器，此时容器中对象存在两个状态，完整和不完整 因此要使用两个map结构存储，即一级缓存、二级缓存</p>
<p><strong>为什么需要三级缓存</strong></p>
<p>三级缓存的value类型是ObjectFactory，一个函数式接口，存在的意义是保证在整个容器的运行过程中同名的bean对象只有一个</p>
<p>如果一个对象需要被代理，或者需要生成代理对象，要优先生成一个普通对象。</p>
<p>普通对象和代理对象是不能同时出现在容器中，因此当一个对象需要被代理的时候，就要使用代理对象覆盖掉之前的普通对象，在实际调用中，是没有办法确认什么时候对象被使用，所以就要求当某个对象被调用的时候，优先判断此对象是否需要被覆盖，类似于一种回调机制的实现，因此传入lamabda表达式的时候，可以通过lambda表达式来执行对象的覆盖过程，getEarlyBeanReference() </p>
<p>因此，所有的bean对象在创建的时候都要优先放到三级缓存，在后续的使用过程中，如果需要被代理则返回代理对象，如果不需要被代理，则直接返回普通对象</p>
<h3 id="4-1缓存放置时间和删除时间"><a href="#4-1缓存放置时间和删除时间" class="headerlink" title="4.1缓存放置时间和删除时间"></a>4.1缓存放置时间和删除时间</h3><p>三级缓存：createBeanInstance之后：addSingletonFactory</p>
<p>二级缓存：第一次从三级缓存确定对象是代理对象还是普通对象的时候，同时删除三级缓存 getSingleton</p>
<p>一级缓存：生成完整对象之后放到一级缓存，删除二三级缓存 addSingleton</p>
<h2 id="5、BeanFactory与FactoryBean"><a href="#5、BeanFactory与FactoryBean" class="headerlink" title="5、BeanFactory与FactoryBean"></a>5、BeanFactory与FactoryBean</h2><p>相同点：都是用来创建对象</p>
<p>不同点：使用BeanFactory创建对象的时候，需要遵循严格的生命周期流程，过于复杂。如果想要简单的自定义某个对象的创建，同时创建完成后交给spring管理，就需要实现FactoryBean接口</p>
<p>​    isSingleton：是否是单例对象</p>
<p>​    getObjectType：获取返回对象的类型</p>
<p>​    getObject：自定义创建对象的过程(new、反射、动态代理)</p>
<h2 id="6、spring中用到的设计模式"><a href="#6、spring中用到的设计模式" class="headerlink" title="6、spring中用到的设计模式"></a>6、spring中用到的设计模式</h2><p>单例模式：bean默认都是单例</p>
<p>原型模式：指定作用域prototype</p>
<p>工厂模式：beanFactory</p>
<p>模板方法：postProcessorBeanFactory、onRefresh、initPropertyVale</p>
<p>策略模式：XmlBeanDfinitionReader、PropertiesBeanDefinitionReader</p>
<p>观察者模式：listener、event、multicast</p>
<p>适配器模式：Adapter</p>
<p>装饰者模式：BeanWrapper</p>
<p>责任链模式：使用aop的时候会先生成一个拦截器链</p>
<p>代理模式：动态代理，jdk、cglib</p>
<p>委托者模式：delegate</p>
<p>。。。。</p>
<h2 id="7、spring的aop底层原理"><a href="#7、spring的aop底层原理" class="headerlink" title="7、spring的aop底层原理"></a>7、spring的aop底层原理</h2><p>aop是ioc的一个扩展功能，先有的ioc，在有的aop。只是在ioc整个流程中新增的一个扩展点而已：<strong>BeanPostProcessor</strong></p>
<p>总：aop概念，应用场景，动态代理</p>
<p>分：bean的创建过程中有一个步骤可以对bean进行扩展实现，aop本身就是一个扩展功能，所以在BeanPostProcessor的后置处理方法中来进行实现。</p>
<p>​    1、代理对象创建过程（advice、切面、切点）</p>
<p>​    2、通过jck或cglib的方式生成代理对象</p>
<p>​    3、在执行方法调用的shi’hou，会调用到生成的字节码文件中，直接回找到DynamicAdvisoredInterceptor类中的intecept方法，从此方法执行</p>
<p>​    4、根据之前定义好的通知来生成拦截器链</p>
<p>​    5、从拦截器链中依次获取每一个通知开始执行，在执行过程中，为了方便找到下一个通知是哪个，会有一个CglibMethodInvocation的对象，从-1的位置依次查找并且执行</p>
<h2 id="8、spring事务如何回滚"><a href="#8、spring事务如何回滚" class="headerlink" title="8、spring事务如何回滚"></a>8、spring事务如何回滚</h2><p>spring事务如何实现？</p>
<p>总：spring事务是由aop实现的，首先要生成代理代理对象，然后按照aop的整套流程来执行具体的操作逻辑，正常情况下，要通过通知来完成核心功能，但事务不是用过通知实现的，而是通过一个<strong>TransactionInterceptor</strong>来实现的，然后调用invoke来实现具体的逻辑</p>
<p>分：1、先做准备工作，解析各个方法上相关的事务属性，根据具体的属性来判断是否开始新事物</p>
<p>​       2、当需要开启的时候，获取数据库连接，关闭自动提交功能，开启事务</p>
<p>​       3、执行具体的sql操作</p>
<p>​       4、在操作过程中，如果执行失败了，会通过completeTransactionAfterThrowing来完成事务回滚操作，回滚的具体逻辑是通过doRollBack方法来实现的，实现的时候也是先获取连接对象，通过连接对象来回滚</p>
<p>​       5、如果执行过程中，没有意外情况发生，通过commitTransactionAfterReturning来完成事务的提交操作，提交的具体逻辑是通过doCommit方法来完成的，实现的时候也是先获取连接，通过连接对象来提交</p>
<p>​       6、当事务执行完毕，需要清除相关的事务信息cleanupTransactionInfo</p>
<h2 id="9、谈一下spring事务传播"><a href="#9、谈一下spring事务传播" class="headerlink" title="9、谈一下spring事务传播"></a>9、谈一下spring事务传播</h2><p>传播特性有几种？<strong>7种</strong></p>
<p>Required、Requires_new、nested、Support、Not_Support、Never、Mandatory</p>
<p>问：某一个事务嵌套另一个事务怎么办</p>
<p>A方法调用B方法，AB方法都有事务，并且传播特性不同，那么A如果有异常，B怎么办？或者B如果有异常A怎么办？</p>
<p>总：事务的传播特性指的是不同方法的嵌套调用过程中，事务应该如何处理，是用同一个事务还是不同的事务，当出现异常的时候会回滚还是提交，两个事务之间的相互影响。使用的比较多的是required、requires_new、nested</p>
<p>分：1、事务的不同分类：分为三类：<code>支持当前事务、不支持当前事务、嵌套事务</code></p>
<p>​            不支持当前事务(三种，对事务的抵制由强到弱)：never：存在当前事务就报异常；not_support：存在当前事务就挂起；requires_new：存在当前事务挂起并新建事务</p>
<p>​            支持当前事务(三种，对事务的依赖从强到弱)：mandatory：使用当前事务，没有则报异常；required：使用当前事务，没有则新建；supports：使用当前事务，没有则不用事务</p>
<p>​            嵌套事务：nested：如果存在当前事务则创建一个事务作为当前事务的嵌套事务来运行，如果当前事务不能存在，则等价于required(新建)</p>
<p>​       2、如果外层方法是required，内层方法是 required，requires_new，nested</p>
<p>​       3、如果外层方法是requires_new,内层方法是 required，requires_new，nested </p>
<p>​       4、如果外层方法是nested，内层方法是 required，requires_new，nested</p>
<p>核心处理逻辑：</p>
<p>1、判断内外方法是否是同一个事务</p>
<p>​    是：异常统一在外层方法处理</p>
<p>​    否：内层方法有可能影响到外层方法，但是外层方法是不会影响到内层方法的</p>
<h2 id="10、spring事务隔离级别"><a href="#10、spring事务隔离级别" class="headerlink" title="10、spring事务隔离级别"></a>10、spring事务隔离级别</h2><p>使用的是数据库的隔离级别：</p>
<ul>
<li>read uncommitted</li>
<li>read committed</li>
<li>repeatable read</li>
<li>serializable</li>
</ul>
<p>进行配置时，如果数据库和spring代码中的隔离级别不同，以spring的配置为主</p>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/images/alipay.jpg"><img loading="lazy" src="/images/alipay.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/wechatpay.png"><img loading="lazy" src="/images/wechatpay.png" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>翔仔</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://example.com/2022/09/07/Spring/" title="Spring">http://example.com/2022/09/07/Spring/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a class="post-nav-next" href="/2022/09/04/shiro/" rel="next" title="shiro"><span class="post-nav-text">shiro</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2022 </span><span class="with-love" id="animate" title="云游君的赞助者们"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 翔仔</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.2</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.8.11</span></div><div class="live-time"><span>本博客已运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2022-04-10T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} 天 ${passHour} 小时 ${passMinute} 分 ${passSecond} 秒`;
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>