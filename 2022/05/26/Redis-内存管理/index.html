<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="翔仔"><meta name="copyright" content="翔仔"><meta name="generator" content="Hexo 5.4.2"><meta name="theme" content="hexo-theme-yun"><title>Redis-内存管理 | 翔仔的博客</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.2.4/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/@unocss/runtime/mini.global.js"></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"example.com","root":"/","title":"翔仔的小站","version":"1.8.11","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]},"vendors":{"darken":"https://cdn.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="内存使用情况内存使用统计命令：info memory 属性说明：  used_memory: Redis分配的内存总量，即存储的所有数据占用的内存。包括redis进程内部开销和使用的虚拟内存（即swap)，单位byte。 used_memory_human: 以可读格式返回使用的内存量(只是显示更友好). used_memory_rss:从系统角度,显示Redis进程占用的物理内存总量，与top及">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis-内存管理">
<meta property="og:url" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="翔仔的博客">
<meta property="og:description" content="内存使用情况内存使用统计命令：info memory 属性说明：  used_memory: Redis分配的内存总量，即存储的所有数据占用的内存。包括redis进程内部开销和使用的虚拟内存（即swap)，单位byte。 used_memory_human: 以可读格式返回使用的内存量(只是显示更友好). used_memory_rss:从系统角度,显示Redis进程占用的物理内存总量，与top及">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653532795056.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653532681883.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653533302271.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653534400077.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653534534213.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653575018583.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653575925026.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653576906156.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653576967052.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653576972838.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653613871735.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653613951305.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653614093089.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653614615294.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653615011955.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653615024670.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653615066728.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653615421918.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653617714577.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653618120859.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653618223275.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653618642715.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653618727717.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653619025645.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653619558896.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653619565790.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653620605843.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653620807521.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653634541002.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653635078149.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653635094580.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653635498266.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653635680342.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653635828017.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653636060529.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653636487524.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653636910582.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653637286449.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653637389658.png">
<meta property="og:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653637454936.png">
<meta property="article:published_time" content="2022-05-26T02:10:02.000Z">
<meta property="article:modified_time" content="2022-05-27T08:42:28.018Z">
<meta property="article:author" content="翔仔">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653532795056.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="翔仔"><img width="96" loading="lazy" src="/images/tx.jpg" alt="翔仔"><span class="site-author-status" title="不想上学">😭</span></a><div class="site-author-name"><a href="/about/">翔仔</a></div><span class="site-name">翔仔的博客</span><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="我的主页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">15</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">4</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">10</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&amp;uin=910426929&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/YunYouJun" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="985391895@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">1.</span> <span class="toc-text">内存使用情况</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%BB%9F%E8%AE%A1%E5%91%BD%E4%BB%A4%EF%BC%9Ainfo-memory"><span class="toc-number">1.1.</span> <span class="toc-text">内存使用统计命令：info memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98%E4%BA%A7%E7%94%9F"><span class="toc-number">1.2.</span> <span class="toc-text">为什么会有碎片问题产生</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">内存占用分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Redis%E8%87%AA%E8%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">2.1.</span> <span class="toc-text">1.Redis自身内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98"><span class="toc-number">2.2.</span> <span class="toc-text">2.对象内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BC%93%E5%86%B2%E5%86%85%E5%AD%98"><span class="toc-number">2.3.</span> <span class="toc-text">3.缓冲内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="toc-number">2.4.</span> <span class="toc-text">4.内存碎片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.4.1.</span> <span class="toc-text">内存碎片产生原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E8%A7%84%E9%81%BF%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.2.</span> <span class="toc-text">内存碎片规避方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E6%B6%88%E8%80%97"><span class="toc-number">2.5.</span> <span class="toc-text">5.子进程内存消耗</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%81"><span class="toc-number">3.</span> <span class="toc-text">内存管理、</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9C%80%E5%A4%A7%E5%86%85%E5%AD%98"><span class="toc-number">3.1.</span> <span class="toc-text">1.最大内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4%E5%86%85%E5%AD%98%E4%B8%8A%E9%99%90"><span class="toc-number">3.2.</span> <span class="toc-text">2.动态调整内存上限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-number">3.3.</span> <span class="toc-text">3.内存回收策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">3.3.1.</span> <span class="toc-text">过期数据删除策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">3.3.2.</span> <span class="toc-text">Redis内存淘汰机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Redis%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F"><span class="toc-number">3.4.</span> <span class="toc-text">4.Redis如何判断数据是否过期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">4.</span> <span class="toc-text">数据存储的细节</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-jemalloc"><span class="toc-number">4.2.</span> <span class="toc-text">2.jemalloc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-redisObject"><span class="toc-number">4.3.</span> <span class="toc-text">3.redisObject</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#type"><span class="toc-number">4.3.1.</span> <span class="toc-text">type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#encoding"><span class="toc-number">4.3.2.</span> <span class="toc-text">encoding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lru"><span class="toc-number">4.3.3.</span> <span class="toc-text">lru</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#refcount"><span class="toc-number">4.3.4.</span> <span class="toc-text">refcount</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ptr"><span class="toc-number">4.3.5.</span> <span class="toc-text">ptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SDS"><span class="toc-number">4.4.</span> <span class="toc-text">SDS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sds%E7%BB%93%E6%9E%84"><span class="toc-number">4.4.1.</span> <span class="toc-text">sds结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SDS%E4%B8%8Ec%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="toc-number">4.4.2.</span> <span class="toc-text">SDS与c字符串比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SDS%E4%B8%8Ec%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.4.3.</span> <span class="toc-text">SDS与c字符串的应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text">Redis的对象类型与内部编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.0.1.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81"><span class="toc-number">5.0.1.1.</span> <span class="toc-text">内部编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.0.1.2.</span> <span class="toc-text">编码转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8List"><span class="toc-number">5.0.2.</span> <span class="toc-text">列表List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-1"><span class="toc-number">5.0.2.1.</span> <span class="toc-text">内部编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2-1"><span class="toc-number">5.0.2.2.</span> <span class="toc-text">编码转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-number">5.0.3.</span> <span class="toc-text">哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-2"><span class="toc-number">5.0.3.1.</span> <span class="toc-text">内部编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2-2"><span class="toc-number">5.0.3.2.</span> <span class="toc-text">编码转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">5.0.4.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-3"><span class="toc-number">5.0.4.1.</span> <span class="toc-text">内部编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2-3"><span class="toc-number">5.0.4.2.</span> <span class="toc-text">编码转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">5.0.5.</span> <span class="toc-text">有序集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-4"><span class="toc-number">5.0.5.1.</span> <span class="toc-text">内部编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2-4"><span class="toc-number">5.0.5.2.</span> <span class="toc-text">编码转换</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">Redis内存优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redisObject%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.1.</span> <span class="toc-text">redisObject对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E5%80%BC%E7%A9%BA%E9%97%B4%E5%8E%8B%E7%BC%A9"><span class="toc-number">6.2.</span> <span class="toc-text">键值空间压缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%B1%A0%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.3.</span> <span class="toc-text">共享池对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E6%9C%89%E6%95%B4%E6%95%B0%E5%AF%B9%E8%B1%A1%E6%B1%A0%EF%BC%9F"><span class="toc-number">6.3.1.</span> <span class="toc-text">为什么只有整数对象池？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BC%98%E5%8C%96"><span class="toc-number">6.4.</span> <span class="toc-text">字符串优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">6.5.</span> <span class="toc-text">编码优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E5%92%8C%E6%95%B0%E5%AD%97"><span class="toc-number">6.6.</span> <span class="toc-text">String和数字</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="翔仔"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="翔仔的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Redis-内存管理</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2022-05-26 10:10:02" itemprop="dateCreated datePublished" datetime="2022-05-26T10:10:02+08:00">2022-05-26</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2022-05-27 16:42:28" itemprop="dateModified" datetime="2022-05-27T16:42:28+08:00">2022-05-27</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">数据库</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/redis/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">redis</span></a></span></div><div class="post-author"><span class="author-name">翔仔</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="内存使用情况"><a href="#内存使用情况" class="headerlink" title="内存使用情况"></a>内存使用情况</h1><h2 id="内存使用统计命令：info-memory"><a href="#内存使用统计命令：info-memory" class="headerlink" title="内存使用统计命令：info memory"></a>内存使用统计命令：<strong>info memory</strong></h2><p><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653532795056.png" alt="1653532795056" loading="lazy"></p>
<p>属性说明：</p>
<ul>
<li>used_memory: Redis分配的内存总量，即存储的所有数据占用的内存。包括redis进程内部开销和使用的<strong>虚拟内存</strong>（即swap)，单位byte。</li>
<li>used_memory_human: 以可读格式返回使用的内存量(只是显示更友好).</li>
<li>used_memory_rss:从系统角度,显示Redis进程占用的物理内存总量，与top及ps命令看到的值是一致的；除了分配器分配的内存之外，used_memory_rss还包括进程运行本身需要的内存、内存碎片等，但是不包括<strong>虚拟内存</strong>。</li>
<li>used_memory_rss_human:以可读格式返回Redis进程占用的物理内存总量</li>
<li>used_memory_peak:内存使用的最大值，表示used_memory峰值</li>
<li>used_memory_peak_human:以可读格式返回内存使用的最大值</li>
<li>total_system_memory:<strong>系统总内存</strong></li>
<li>total_system_memory_human:以可读格式返回系统总内存</li>
<li>used_memory_lua:Lua进程使用内存</li>
<li>used_memory_lua_human:以可读格式返回Lua进程使用内存</li>
<li>mem_fragmentation_ratio:内存碎片率，等价于(used_memory_rss /used_memory)</li>
<li>mem_allocator:redis使用的内存分配器:在编译时指定；可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc；</li>
</ul>
<blockquote>
<p>说明：used_memory_rss - used_memory多出的部分内存并没有用于数据存储，而是被内存碎片所消耗，如果两者相差很大，说明碎片率严重，需要及时进行碎片清理</p>
<p> 这种情况一般出现在操作系统把Redis 内存交换（Swap）到硬盘导致，出现这种情况时要格外关注，由于硬盘速度远远慢于内存，Redis性能会变得很差，甚至僵死 | 已经开始使用硬盘进行存储，需要考虑扩容内存 </p>
</blockquote>
<p><strong>重点关注used_memory以及used_memory_rss和碎片率mem_fragmentation_ratio</strong></p>
<p><strong>1) used_memory和used_memory_rss</strong>: 前者是从Redis角度得到的量，后者是从操作系统角度得到的量。二者之所以有所不同，一方面是因为内存碎片和Redis进程运行需要占用内存，使得前者可能比后者小，另一方面虚拟内存的存在，使得前者可能比后者大。</p>
<p><strong>2) mem_fragmentation_ratio :</strong> <img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653532681883.png" alt="1653532681883" loading="lazy"><br>由于在实际应用中，Redis的数据量会比较大，此时<strong>进程运行占用的内存与Redis数据量和内存碎片相比</strong>，都会小得多；因此used_memory_rss和used_memory的比例，便成了衡量Redis内存碎片率的参数；这个参数就是mem_fragmentation_ratio。</p>
<p>mem_fragmentation_ratio =表示(used_memory_rss/used_memory)的比值。</p>
<p><strong>mem_fragmentation_ratio &gt; 1</strong> 碎片率过大，导致内存资源浪费；，如果值越大，说明碎片越严重。</p>
<p><strong>mem_fragmentation_ratio &lt; 1</strong>: 一般出现在操作系统把Redis内存交换到硬盘导致，redis已使用swap分区。由于虚拟内存的媒介是磁盘，比内存速度要慢很多，当这种情况出现时，应该及时排查，如果内存不足应该及时处理，如增加Redis节点、增加Redis服务器的内存、优化应用等。</p>
<p>一般来说，mem_fragmentation_ratio在1.03左右是比较健康的状态（对于jemalloc来说）；上面截图中的mem_fragmentation_ratio值很大，是因为还没有向Redis中存入数据，Redis进程本身运行的内存使得used_memory_rss 比used_memory大得多。</p>
<h2 id="为什么会有碎片问题产生"><a href="#为什么会有碎片问题产生" class="headerlink" title="为什么会有碎片问题产生"></a>为什么会有碎片问题产生</h2><p>1.Redis内部有自己的内存管理器，为了提高内存使用的效率，来对内存的申请和释放进行管理</p>
<p>2.Redis中的值删除的时候，并没有把内存直接释放，交还给操作系统，而是交给了Redis内部有内存管理器。</p>
<p>3.Redis中申请内存的时候，也是先看自己的内存管理器中是否有足够的内存可用。</p>
<p>4.Redis的这种机制，提高了内存的使用率，但是会使Redis中有部分自己没在用，却不释放的内存，导致了内存碎片的发生。</p>
<h1 id="内存占用分析"><a href="#内存占用分析" class="headerlink" title="内存占用分析"></a>内存占用分析</h1><p><strong>Redis内存主要包括：对象内存+缓冲内存+自身内存+内存碎片</strong></p>
<p><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653533302271.png" alt="1653533302271" loading="lazy"></p>
<h2 id="1-Redis自身内存"><a href="#1-Redis自身内存" class="headerlink" title="1.Redis自身内存"></a>1.Redis自身内存</h2><p> 其中Redis自身内存消耗的很少，这部分内存大约几兆。通常占用used_memory_rss在3MB左右，used_memory在800k左右。 </p>
<p> 在大多数生产环境中与Redis数据占用的内存相比可以忽略。这部分内存不是由jemalloc分配，因此不会统计在used_memory中 </p>
<p> 补充说明：除了主进程外，Redis创建的子进程运行也会占用内存，如Redis执行AOF、RDB重写时创建的子进程。当然，这部分内存不属于Redis进程，也不会统计在used_memory和used_memory_rss中。 </p>
<h2 id="2-对象内存"><a href="#2-对象内存" class="headerlink" title="2.对象内存"></a>2.对象内存</h2><p>对象内存是Redis中内存消耗的主要部分，所有用户数据都存储在对象内存中。所有数据都采用key-value，每次创建都是创建<strong>两个对象</strong>， 即key对象和value对象，即 key的size + value的size. </p>
<p>Key对象：都是字符串，我们应当避免使用过长的key.</p>
<p>Value对象：根据数据类型不同（五种数据类型–String，List，Hash，Set，Zset），则占用的内存就不同。这5种类型是Redis对外提供的，实际上，在Redis内部，每种类型可能有2种或更多的内部编码实现；此外，Redis在存储对象时，并不是直接将数据扔进内存，而是会对对象进行各种包装：如redisObject、SDS等；</p>
<h2 id="3-缓冲内存"><a href="#3-缓冲内存" class="headerlink" title="3.缓冲内存"></a>3.缓冲内存</h2><p> 缓冲内存涉及到<strong>客户端缓冲区，复制积压缓冲区和AOF缓冲区</strong>。这部分内存由jemalloc分配，因此会统计在used_memory中。 </p>
<p><strong>客户端缓冲</strong>：指的是所有连接到Redis的服务器tcp连接输入输出缓冲 ，输入缓冲无法控制，最大空间1G；输出缓冲可通过client-output-buffer-limit控制。 </p>
<ul>
<li><p><strong>普通客户端的连接：</strong>client-output-buffer-limit normal 0 0 0 </p>
<p> 普通客户端默认并没有对输出缓冲区做限制。但是如果当有大量的慢连接客户端接入时，这部分消耗就不能忽略了，因为消费的很慢，在成输出缓冲区数据积压。所以可以设置maxclients做限制。 </p>
</li>
<li><p><strong>从客户端：c</strong>lient-output-buffer-limit slave 256mb 64mb 60 </p>
<p> 主节点会每一个从节点单独建立一条连接用于命令复制。当主节点网络延迟较高或主节点挂载大量的从节点时，这部分内存消耗将占用很大一部分，建议主节点挂载从节点最好不要超过2个。 </p>
</li>
<li><p>  <strong>订阅客户端：</strong>client-output-buffer-limit pubsub 32mb 8mb 60  </p>
</li>
</ul>
<p>   当生产消息的速度快于消费的速度时，输出缓冲区容易积压消息 </p>
<p> <strong>复制积压缓冲区：</strong>一个可重用的固定大小缓冲区用于实现部分复制功能，根据repl-backlog-size参数控制，默认1MB. 对于复制积压缓区，主节点有一个，所有从节点共享这个缓冲区，因此可以设置较大的值，比如100MB,这部分投入是有价值的，可以有效避免全量复制。 </p>
<p> <strong>AOF缓冲区：</strong>用于AOF重写期间保存最近写入的命令，等待被刷到磁盘。会先写入到缓冲区，然后根据响应的策略向磁盘进行同步，消耗的内存取决于写入的命令量和重写时间，通常很小。 </p>
<h2 id="4-内存碎片"><a href="#4-内存碎片" class="headerlink" title="4.内存碎片"></a>4.内存碎片</h2><p>Redis进程需要用内存的话，会<strong>先通过OS向device申请</strong>，然后才能够使用。一般进程在不需要使用的时候，会释放掉这部分内存并返回给device。但是redis可能为了更高的性能，所以<strong>在redis中实现了自己的内存分配器来管理内存</strong>，不会马上返还内存，不用每次都向OS申请了，从而实现高性能。</p>
<p>Redis默认的内存分配器是<strong>jemalloc</strong>，内存分配器的作用就是为了更好的管理和重复利用内存。内存碎片是Redis在分配、回收物理内存过程中产生的。</p>
<p>内存管理器一般会以块的形式对内存进行管理和空间分配。首先按照不同的大小范围进行范围内块大小的定义，根据实际对象的大小来进行内存空间的分配</p>
<p><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653534400077.png" alt="1653534400077" loading="lazy"></p>
<h3 id="内存碎片产生原因"><a href="#内存碎片产生原因" class="headerlink" title="内存碎片产生原因"></a>内存碎片产生原因</h3><p><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653534534213.png" alt="1653534534213" loading="lazy"></p>
<ul>
<li><strong>数据不对齐</strong>，由于以块的形式存储，内存块空间大小是固定标准，当对象与块大小不对齐时，无法充分利用该内存空间</li>
<li><strong>频繁更新操作</strong>，append等频繁更新操作有可能导致内存碎片产生</li>
<li><strong>大量键过期删除</strong>， 当出现大量键对象<code> 过期</code> 后，释放的空间未充分利用会导致碎片率上升 </li>
</ul>
<h3 id="内存碎片规避方法"><a href="#内存碎片规避方法" class="headerlink" title="内存碎片规避方法"></a>内存碎片规避方法</h3><ul>
<li>数据对齐，尽量使用定长数据类型，保持内存块对齐，也就是说尽可能物尽其用，用多少占多少</li>
<li>安全重启，在集群环境下，可以主从节点切换，通过重启服务来重载内存以提高内存使用率</li>
</ul>
<h2 id="5-子进程内存消耗"><a href="#5-子进程内存消耗" class="headerlink" title="5.子进程内存消耗"></a>5.子进程内存消耗</h2><p> 这里主要是指Redis在<code>AOF/RDB</code>时需要<code>fork()</code>创建出的子进程的内存消耗。 由于<code>Linux</code>中有<code>写时复制（copy-on-write）</code>技术来使父子进程共享物理内存页 ，只有当父进程处理写请求时会对需要修改的页复制出一份副本完成写操作，而子进程依旧读取fork时整个父进程内存快照。即<strong>只有当数据变更时才产生实际复制</strong>，因此无需预留占用和父进程一样的内存空间。</p>
<blockquote>
<p>Redis子进程并不需要消耗1倍 的父进程内存，但是依然要预留一些内存防止内存溢出 。需要设置sysctl vm.overcommit_memory=1允许内核可以分配所有的物理内存，防止Redis进程执行fork时因系统剩余内存不足而失败。 </p>
</blockquote>
<p><strong>注意：</strong> 排查当前系统是否支持并开启THP，如果开启，建议关闭。 </p>
<p> Linux提供的<strong>Transport Huge Page</strong>开启状态下产生的问题，<code>Linux kernel</code>在2.6.38内核增加了THP特性，支持大内存页（2MB）分配，默 认开启。当开启时可以降低fork子进程的速度，但fork操作之后，每个内存 页从原来<code>4KB</code>变为<code>2MB</code>，会大幅增加重写期间父进程内存消耗。同时每次写 命令引起的复制内存页单位放大了512倍，会拖慢写操作的执行时间，导致大量写操作慢查询，例如简单的incr命令也会出现在慢查询中。因此Redis日志中建议将此特性进行禁用。 </p>
<h1 id="内存管理、"><a href="#内存管理、" class="headerlink" title="内存管理、"></a>内存管理、</h1><p>内存主要是通过控制内存上限和内存回收策略进行内存管理和控制。</p>
<h2 id="1-最大内存"><a href="#1-最大内存" class="headerlink" title="1.最大内存"></a>1.最大内存</h2><p>Redis通过maxmemory参数限制最大可用内存。限制内存目的主要有：</p>
<p><strong>用于缓存场景，当超出内存上限maxmemory时候使用LRU等删除策略释放空间，防止所用内存超过服务器物理内存。</strong></p>
<p>所有的数据都必须在内存中，原来2.0版的VM策略(将Value放到磁盘，Key仍然放在内存)，2.4版后嫌麻烦又不支持了。<br>一定要设置最大内存，否则物理内存用爆了就会大量使用Swap，写RDB文件时的速度慢得你想死。我们可以通过配置redis.conf中的maxmemory这个值设置最大内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># maxmemory &lt;bytes&gt;</span><br></pre></td></tr></table></figure>

<p>若是启用了Redis快照功能，应该设置“maxmemory”值为系统可使用内存的45%，因为快照时需要一倍的内存来复制整个数据集，也就是说如果当前已使用45%，在快照期间会变成95%(45%+45%+5%)，其中5%是预留给其他的开销。 如果没开启快照功能，maxmemory最高能设置为系统可用内存的95%。</p>
<p>多留一倍内存是最安全的。重写AOF文件和RDB文件的进程(即使不做持久化，复制到Slave的时候也要写RDB)会fork出一条新进程来，**采用了操作系统的Copy-On-Write策略(子进程与父进程共享Page。如果父进程的Page-每页4K有修改，父进程自己创建那个Page的副本，不会影响到子进程，父爱如山)**。留意Console打出来的报告，如”RDB: 1215 MB of memory used by copy-on-write”。在系统极度繁忙时，如果父进程的所有Page在子进程写RDB过程中都被修改过了，就需要两倍内存。<br>按照Redis启动时的提醒，设置 vm.overcommit_memory = 1 ，使得fork()一条10G的进程时，因为COW策略而不一定需要有10G的free memory。</p>
<p>需要注意的是：</p>
<p><strong>maxmeory限制的是Redis实际使用的内存量，也就是used_memory统计项对应的内存。由于有内存碎片的存在，所以实际的内存使用比used_memory要大。</strong>需要考虑的内存包括：<br>1.AOF rewrite过程中对新写入命令的缓存(rewrite结束后会merge到新的aof文件)，留意”Background AOF buffer size: 80 MB”的字样。<br>2.负责与Slave同步的Client的缓存，默认设置master需要为每个slave预留不高于256M的缓存(见5.1持久化)。</p>
<p>通过设置上限，可以方便实现一台服务器部署多个Redis进程的内存控制。比如一台32G的内存的服务器，预留4GB内存给系统，预留4GB给Redis fork进程，留给Redis24GB内存，这样就可以部署3个maxmemory=8GB的redis进程。</p>
<h2 id="2-动态调整内存上限"><a href="#2-动态调整内存上限" class="headerlink" title="2.动态调整内存上限"></a>2.动态调整内存上限</h2><p>通过命令config set maxmemory 来设置内存使用上限，也就是限制used_memory中各项内存大小总合，由于存在内存碎片，Redis在系统中实际使用的内存要大于maxmemory</p>
<h2 id="3-内存回收策略"><a href="#3-内存回收策略" class="headerlink" title="3.内存回收策略"></a>3.内存回收策略</h2><h3 id="过期数据删除策略"><a href="#过期数据删除策略" class="headerlink" title="过期数据删除策略"></a>过期数据删除策略</h3><ul>
<li><strong>惰性删除</strong>：只会在取出key的时候才对数据进行过期检查，对<strong>CPU友好</strong>，但可能会造成太多过期key没有被删除</li>
<li><strong>定期删除</strong>：每隔一段时间抽取一批keyzhi’xing删除过期key操作。 并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。 </li>
</ul>
<p>定期删除对内存更加友好，惰性删除对CPU更加友好，Rqedis采用的是<strong>定期删除+惰性删除</strong></p>
<blockquote>
<p>但是，尽管如此还是可能存在被漏掉的很多过期key‘的情况。这样就导致大量过期key堆积在内存中，导致内存使用达到maxmemory上限而触发内存移除</p>
<p>如何解决？<strong>Redis内存淘汰机制</strong></p>
</blockquote>
<h3 id="Redis内存淘汰机制"><a href="#Redis内存淘汰机制" class="headerlink" title="Redis内存淘汰机制"></a>Redis内存淘汰机制</h3><p>六种淘汰机制：</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ol>
<h2 id="4-Redis如何判断数据是否过期"><a href="#4-Redis如何判断数据是否过期" class="headerlink" title="4.Redis如何判断数据是否过期"></a>4.Redis如何判断数据是否过期</h2><p>Redis通过过期字典(可以看作hash表)来保存数据过期时间。过期字典的键指向Redis数据库中的某个key，过期字典的值是一个longlong类型的整数，这个整数保存了key所指向的数据数据库键过期时间<img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653575018583.png" alt="1653575018583" loading="lazy"></p>
<p>过期字典是存储在redisDb这个结构里的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    dict *dict;     //数据库键空间,保存着数据库中所有键值对</span><br><span class="line">    dict *expires   // 过期字典,保存着键的过期时间</span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<h1 id="数据存储的细节"><a href="#数据存储的细节" class="headerlink" title="数据存储的细节"></a>数据存储的细节</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>关于Redis数据存储的细节，涉及到内存分配器(如jemalloc)、简单动态字符串（SDS）、5种对象类型及内部编码、redisObject。</p>
<p>如下图是执行set hello world时，所涉及到的数据模型<img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653575925026.png" alt="1653575925026" loading="lazy"></p>
<ol>
<li>dictEntry：Redis是key-value数据库，因此每个键值对都会有一个dictEntry，里面存储了指向key和value的指针；next指向下一个dictEntry，与本key-value无关。</li>
<li>key：图中右上角可见，key（“hello”）并不是直接以字符串形式存储，而是存储在SDS结构</li>
<li>redisObject：value既不是直接以字符串存储，也不是像key一样直接存储在SDS中，而是存储在redisObject中。实际上，不论value是五种类型的哪一种，都是通过redisObject来存储的；而redisObject中的type字段指明了value对象的类型，ptr字段则指向了对象所在的地址。 不过可以看出，字符串对象虽然经过了redisObject的包装，但仍然需要通过SDS存储。 (除此以外，<strong>redisObject还有其他字段，如指定对象内部编码的字段</strong>)</li>
<li> jemalloc：无论是DictEntry对象，还是redisObject、SDS对象，都需要内存分配器（如jemalloc）分配内存进行存储。以DictEntry对象为例，有3个指针组成，在64位机器下占24个字节，jemalloc会为它分配32字节大小的内存单元。 </li>
</ol>
<h2 id="2-jemalloc"><a href="#2-jemalloc" class="headerlink" title="2.jemalloc"></a>2.jemalloc</h2><p>Redis在编译时便会指定内存分配器；内存分配器可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc。</p>
<p>jemalloc作为Redis的默认内存分配器，在减小内存碎片方面做的相对比较好。jemalloc在64位系统中，将内存空间划分为小、大、巨大三个范围；每个范围内又划分了许多小的内存块单位；当Redis存储数据时，会选择大小最合适的内存块进行存储。</p>
<p>jemalloc划分的内存单元如下图所示：<br><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653576906156.png" alt="1653576906156" loading="lazy"></p>
<p> 例如，如果需要存储大小为130字节的对象，jemalloc会将其放入160字节的内存单元中。 </p>
<h2 id="3-redisObject"><a href="#3-redisObject" class="headerlink" title="3.redisObject"></a>3.redisObject</h2><p>一个redisObject对象大小是16字节</p>
<p>Redis对象有5种类型；无论是哪种类型，Redis都不会直接存储，而是通过redisObject对象进行存储。</p>
<p>redisObject对象非常重要，Redis对象的类型、内部编码、内存回收、共享对象等功能，都需要redisObject支持，下面将通过redisObject的结构来说明它是如何起作用的。</p>
<p>redisObject的定义如下（不同版本的Redis可能稍稍有所不同）：</p>
<p><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653576967052.png" alt="1653576967052" loading="lazy"></p>
<p><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653576972838.png" alt="1653576972838" loading="lazy"></p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type字段表示对象的类型，占4个比特；目前包括REDIS_STRING(字符串)、REDIS_LIST (列表)、REDIS_HASH(哈希)、REDIS_SET(集合)、REDIS_ZSET(有序集合)。</p>
<p>当我们执行type命令时，便是通过读取RedisObject的type字段获得对象的类型；如下图所示：<img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653613871735.png" alt="1653613871735" loading="lazy"></p>
<h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><p>encoding表示对象的内部编码，占4个比特。</p>
<p>对于Redis支持的每种类型，都有至少两种内部编码，例如对于字符串，有int、embstr、raw三种编码。通过encoding属性，Redis可以根据不同的使用场景来为对象设置不同的编码，大大提高了Redis的灵活性和效率。以列表对象为例，有压缩列表和双端链表两种编码方式；如果列表中的元素较少，Redis倾向于使用压缩列表进行存储，因为压缩列表占用内存更少，而且比双端链表可以更快载入；当列表对象元素较多时，压缩列表就会转化为更适合存储大量元素的双端链表。</p>
<p>通过object encoding命令，可以查看对象采用的编码方式，如下图所示：</p>
<p><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653613951305.png" alt="1653613951305" loading="lazy"></p>
<h3 id="lru"><a href="#lru" class="headerlink" title="lru"></a>lru</h3><p>lru记录的是对象最后一次被命令程序访问的时间，占据的比特数不同的版本有所不同（如4.0版本占24比特，2.6版本占22比特）。</p>
<p>通过对比lru时间与当前时间，可以计算某个对象的空转时间；object idletime命令可以显示该空转时间（单位是秒）。object idletime命令的一个特殊之处在于它不改变对象的lru值。<br><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653614093089.png" alt="1653614093089" loading="lazy"></p>
<p>lru值除了通过object idletime命令打印之外，还与Redis的内存回收有关系：如果Redis打开了maxmemory选项，且内存回收算法选择的是volatile-lru或allkeys—lru，那么当Redis内存占用超过maxmemory指定的值时，Redis会优先选择空转时间最长的对象进行释放。</p>
<h3 id="refcount"><a href="#refcount" class="headerlink" title="refcount"></a>refcount</h3><p><strong>refcount与共享对象</strong></p>
<p>refcount记录的是该对象被引用的次数，类型为整型。refcount的作用，主要在于对象的引用计数和内存回收。当创建新对象时，refcount初始化为1；当有新程序使用该对象时，refcount加1；当对象不再被一个新程序使用时，refcount减1；当refcount变为0时，对象占用的内存会被释放。</p>
<p><strong>Redis中被多次使用的对象(refcount&gt;1)，称为共享对象</strong>。Redis为了节省内存，当有一些对象重复出现时，新的程序不会创建新的对象，而是仍然使用原来的对象。这个被重复使用的对象，就是共享对象。目前共享对象仅支持整数值的字符串对象。</p>
<p><strong>共享对象的具体实现</strong></p>
<p>Redis的共享对象目前只支持整数值的字符串对象。之所以如此，实际上是对内存和CPU（时间）的平衡：共享对象虽然会降低内存消耗，但是判断两个对象是否相等却需要消耗额外的时间。对于整数值，判断操作复杂度为O(1)；对于普通字符串，判断复杂度为O(n)；而对于哈希、列表、集合和有序集合，判断的复杂度为O(n^2)。</p>
<p>虽然共享对象只能是整数值的字符串对象，但是5种类型都可能使用共享对象（如哈希、列表等的元素可以使用）。</p>
<p>就目前的实现来说，Redis服务器在初始化时，会创建10000个字符串对象，值分别是0<del>9999的整数值；当Redis需要使用值为0</del>9999的字符串对象时，可以直接使用这些共享对象。10000这个数字可以通过调整参数REDIS_SHARED_INTEGERS（4.0中是OBJ_SHARED_INTEGERS）的值进行改变。</p>
<p>共享对象的引用次数可以通过object refcount命令查看，如下图所示。命令执行的结果页佐证了只有0~9999之间的整数会作为共享对象。<img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653614615294.png" alt="1653614615294" loading="lazy"></p>
<h3 id="ptr"><a href="#ptr" class="headerlink" title="ptr"></a>ptr</h3><p> ptr指针指向具体的数据，如前面的例子中，set hello world，ptr指向包含字符串world的SDS。 </p>
<h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><p>在Redis中，字符串对象时经常用到的，Redis没有直接使用C字符串(即以空字符’\0’结尾的字符数组)作为默认的字符串表示，而是使用了SDS。SDS是简单动态字符串(Simple Dynamic String)的缩写。</p>
<p>举个例子：执行一个list的命令，lpush queue “redis” “list” “queue”，首先会创建queue键字符串，然后创建链表对象，链表对象内在包含三个字符串对象。</p>
<h3 id="sds结构"><a href="#sds结构" class="headerlink" title="sds结构"></a>sds结构</h3><p><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653615011955.png" alt="1653615011955" loading="lazy"></p>
<p><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653615024670.png" alt="1653615024670" loading="lazy"></p>
<p>buf：表示字节数组，用来存储字符串</p>
<p>len：表示buf已使用的长度</p>
<p>free：表示buf未使用的长度</p>
<p><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653615066728.png" alt="1653615066728" loading="lazy"></p>
<p> 通过SDS的结构可以看出，buf数组的长度=free+len+1（其中1表示字符串结尾的空字符）；所以，一个SDS结构占据的空间为：free所占长度+len所占长度+ buf数组的长度=4+4+free+len+1=free+len+9。 </p>
<blockquote>
<p>sds有几个特点：</p>
<p> 时间复杂度为O(1)，因为有已知长度，未知长度，字符串长度<br>支持安全的二进制数据存储，用于保存字节数组<br>内部实现空间预分配机制，降低内存再分配次数<br>惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留 </p>
</blockquote>
<p>所以字符串在使用的时候，尽量减少追加操作，避免大量的追加操作需要内存重新分配，造成内存碎片率上升。而是尽量使用直接插入。<br>字符串预分配每次都不是翻倍扩容，空间的预分配规则如下：</p>
<p>第一次创建len属性等于数据实际大小，free等于0，不做预分配。<br>修改后，如果已有free空间不够且数据小于1MB，每次与分配一倍容量。<br>修改后如果已有free空间不够且数据大于1MB，每次预分配1MB数据空间。如果数据量太大，也翻一倍的话，很有可能会造成内存不足，所有大于1MB的数据，每次预分配1MB空间，也是基于此原因。</p>
<p>一个简单的例子，比如在Redis中set一个简单点的值，在Redis内存中的结构图如下（参考样例）：<img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653615421918.png" alt="1653615421918" loading="lazy"></p>
<h3 id="SDS与c字符串比较"><a href="#SDS与c字符串比较" class="headerlink" title="SDS与c字符串比较"></a>SDS与c字符串比较</h3><p>SDS在C字符串的基础上加入了free和len字段，带来了很多好处：</p>
<ul>
<li><p>获取字符串长度：SDS是O(1)，C字符串是O(n)</p>
</li>
<li><p>缓冲区溢出：使用C字符串的API时，如果字符串长度增加（如strcat操作）而忘记重新分配内存，很容易造成缓冲区的溢出；而SDS由于记录了长度，相应的API在可能造成缓冲区溢出时会自动重新分配内存，杜绝了缓冲区溢出。</p>
</li>
<li><p>修改字符串时内存的重分配：对于C字符串，如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。而对于SDS，由于可以记录len和free，因此解除了字符串长度和空间数组长度之间的关联，可以在此基础上进行优化：空间预分配策略（即分配内存时比实际需要的多）使得字符串长度增大时重新分配内存的概率大大减小；惰性空间释放策略使得字符串长度减小时重新分配内存的概率大大减小。</p>
</li>
<li><p>存取二进制数据：SDS可以，C字符串不可以。因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而SDS以字符串长度len来作为字符串结束标识，因此没有这个问题。</p>
</li>
</ul>
<p>此外，由于SDS中的buf仍然使用了C字符串（即以’\0’结尾），因此SDS可以使用C字符串库中的部分函数；但是需要注意的是，只有当SDS用来存储文本数据时才可以这样使用，在存储二进制数据时则不行（’\0’不一定是结尾）。</p>
<h3 id="SDS与c字符串的应用"><a href="#SDS与c字符串的应用" class="headerlink" title="SDS与c字符串的应用"></a>SDS与c字符串的应用</h3><p>Redis在存储对象时，一律使用SDS代替C字符串。例如set hello world命令，hello和world都是以SDS的形式存储的。而sadd myset member1 member2 member3命令，不论是键（”myset”），还是集合中的元素（”member1”、 ”member2”和”member3”），都是以SDS的形式存储。除了存储对象，SDS还用于存储各种缓冲区。</p>
<p>只有在字符串不会改变的情况下，如打印日志时，才会使用C字符串。</p>
<h1 id="Redis的对象类型与内部编码"><a href="#Redis的对象类型与内部编码" class="headerlink" title="Redis的对象类型与内部编码"></a>Redis的对象类型与内部编码</h1><p>Redis支持5种对象类型（String，List，Hash，Set，Zset），<strong>而每种结构都有至少两种编码</strong>；这样做的好处在于：一方面接口与实现分离，当需要增加或改变内部编码时，用户使用不受影响，另一方面可以根据不同的应用场景切换内部编码，提高效率。</p>
<p>Redis各种对象类型支持的内部编码如下图所示(图中版本是Redis3.0，Redis后面版本中又增加了内部编码，略过不提；本章所介绍的内部编码都是基于3.0的)：</p>
<p>关于Redis内部编码的转换，都符合以下规律：编码转换在Redis写入数据时完成，且转换过程不可逆，只能从小内存编码向大内存编码转换。</p>
<p>但是不同的类型，在存储到Redis中时会有不同的底层数据结构实现。类似集合ArrayList的底层实现是数组，而Linkedlist的底层实现是链表结构一样，编码不同，则存储是占用的内存以及读写的效率也是不同的。</p>
<p><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653617714577.png" alt="1653617714577" loading="lazy"></p>
<p>关于Redis内部编码的转换，都符合以下规律：编码转换在Redis写入数据时完成，且转换过程不可逆，只能从小内存编码转向大内存编码。</p>
<p> 但是不同的类型，在存储到Redis中时会有不同的底层数据结构实现。类似集合ArrayList的底层实现是数组，而Linkedlist的底层实现是链表结构一样，编码不同，则存储是占用的内存以及读写的效率也是不同的。 </p>
<p><strong>embstr与raw的区别</strong></p>
<p>现代的计算机的结构上边在CPU和内存之间存在一个缓存结构，用来协调CPU的高效和访存的相对缓慢的矛盾。平时听到的L1 Cache，L2 Cache，L3 Cache就是这个缓存。当CPU要访问内存之前会先在缓存里面找一找看有没有，如果没有，就去内存找，找到之后放到缓存里面。这个缓存的最小单位一般是64字节，一次性缓存连续的64个字节，<strong>这个最小的单位称为缓存行</strong>。</p>
<p> 在Redis中，每个value对象都有一个redisObject对象头，对于Redis的字符串对象，当读取数据时，拿到*ptr指针，然后再去找到指向的SDS对象，如果这个对象距离很远，就会影响Redis读取的效率。因此在Redis中设计了一种特殊的编码结构，<strong>这种结构就是embstr</strong>，<strong>它把redisObject请求头和SDS对象紧紧地挨到一起，然后整体放到一个缓存行中</strong>去，这样，在查询的时候就可以直接从缓存中获取到相关的数据，提高了查询的效率。<br><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653618120859.png" alt="1653618120859" loading="lazy"></p>
<p>在上边也讲了，缓存行一般的长度为64字节，如果想要把对象存到缓存行中，首先整体的长度不得超过64字节，每个请求头redisObject占用16字节，而SDS至少有3个字节被占用，同时Redis中会以\0来作为结尾的标志，也占用一个字节，因此，留给可输入的数据的长度就成了（64-16-3-1）=44字节，当存储的数据长度超过了44字节，就会变成raw的编码形式。<br><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653618223275.png" alt="1653618223275" loading="lazy"></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是最基础的类型，因为所有的键都是字符串类型，且字符串之外的其他几种复杂类型的元素也是字符串。</p>
<p>字符串长度不能超过512MB.</p>
<h4 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h4><p>字符串类型的内部编码有三种，应用场景：</p>
<ul>
<li>int：8个字节的长整型。 字符串值是整型时，这个值使用long整型表示。 </li>
<li>embstr：&lt;=39字节的字符串。embstr与raw都使用redisObject和sds保存数据，区别在于，embstr的使用只分配一次内存空间（因此redisObject和sds是连续的），而raw需要分配两次内存空间（分别为redisObject和sds分配空间）。因此与raw相比，embstr的好处在于创建时少分配一次空间，删除时少释放一次空间，以及对象的所有数据连在一起，寻找方便。而embstr的坏处也很明显，如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，因此<strong>redis中的embstr实现为只读</strong>。</li>
<li>raw：大于39个字节的字符串</li>
</ul>
<p>示例：<img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653618642715.png" alt="1653618642715" loading="lazy"></p>
<p> embstr和raw进行区分的长度，是39；是因为redisObject的长度是16字节，sds的长度是9+字符串长度；因此当字符串长度是39时，embstr的长度正好是16+9+39=64，jemalloc正好可以分配64字节的内存单元。 </p>
<h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><p>当int数据不再是整数，或大小超过了long的范围时，自动转化为raw。</p>
<p>而对于embstr，由于其实现是<strong>只读</strong>的， 因此在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，<strong>修改后的对象一定是raw</strong>的，无论是否达到了39个字节。示例如下图所示：<img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653618727717.png" alt="1653618727717" loading="lazy"></p>
<h3 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h3><p> 列表（list）用来存储多个有序的字符串，每个字符串称为元素；一个列表可以存储2^32-1个元素。Redis中的列表支持两端插入和弹出，并可以获得指定位置（或范围）的元素，可以充当数组、队列、栈等。 </p>
<h4 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h4><p>列表的内部编码可以是压缩列表(ziplist)或双端队列(linkedlist)</p>
<p><strong>双端链表</strong>：由一个list结构和多个listNode结构组成，典型结构如下图所示：<img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653619025645.png" alt="1653619025645" loading="lazy"></p>
<p> 通过图中可以看出，<strong>双端链表</strong>同时保存了表头指针和表尾指针，并且每个节点都有指向前和指向后的指针；链表中保存了列表的长度；dup、free和match为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。而链表中每个节点指向的是type为字符串的redisObject。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表节点</span></span><br><span class="line">typedef  struct listNode&#123;</span><br><span class="line">       <span class="comment">//前置节点</span></span><br><span class="line">       struct listNode *prev;</span><br><span class="line">       <span class="comment">//后置节点</span></span><br><span class="line">       struct listNode *next;</span><br><span class="line">       <span class="comment">//节点的值</span></span><br><span class="line">       <span class="keyword">void</span> *value;  </span><br><span class="line">&#125;listNode</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表   </span></span><br><span class="line">typedef struct list&#123;</span><br><span class="line">     <span class="comment">//表头节点</span></span><br><span class="line">     listNode *head;</span><br><span class="line">     <span class="comment">//表尾节点</span></span><br><span class="line">     listNode *tail;</span><br><span class="line">     <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">     unsigned <span class="type">long</span> len;</span><br><span class="line">     <span class="comment">//节点值复制函数</span></span><br><span class="line">     <span class="keyword">void</span> (*free) (<span class="keyword">void</span> *ptr);</span><br><span class="line">     <span class="comment">//节点值释放函数</span></span><br><span class="line">     <span class="keyword">void</span> (*free) (<span class="keyword">void</span> *ptr);</span><br><span class="line">     <span class="comment">//节点值对比函数</span></span><br><span class="line">     <span class="type">int</span> (*match) (<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;list;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>压缩列表</strong>：压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的<strong>连续内存块</strong>(而不是像双端链表一样每个节点是指针)组成的顺序型数据结构；</p>
<p>与双端链表相比，压缩列表可以节省内存空间，但是进行修改或增删操作时，复杂度较高；因此当节点数量较少时，可以使用压缩列表；但是节点数量多时，还是使用双端链表划算。</p>
<p><strong>原理</strong>：压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定规则编码在一块连续的内存区域，目的是节省内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列表节点</span></span><br><span class="line">typedef struct ziplistNode&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录压缩列表前一个字节的长度.</span></span><br><span class="line">  <span class="type">int</span> previous_entry_length;</span><br><span class="line">  <span class="comment">// 节点的content的内容类型以及长度.encoding类型一共有两种，一种字节数组一种是整数，encoding区域长度为1字节、2字节或者5字节长。</span></span><br><span class="line">  buf encoding;</span><br><span class="line">  <span class="comment">// 节点的内容,节点内容类型和长度由encoding决定。</span></span><br><span class="line">  buf content;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩表</span></span><br><span class="line">typedef struct ziplist&#123;</span><br><span class="line">     <span class="comment">//表头节点和表尾节点</span></span><br><span class="line">     structz ziplistNode entryX;</span><br><span class="line">     <span class="comment">//表中节点的数量</span></span><br><span class="line">     unsigned <span class="type">long</span> length;</span><br><span class="line">     <span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line">     <span class="type">int</span> zlbytes;</span><br><span class="line">     <span class="type">int</span> zltail;</span><br><span class="line">     <span class="type">int</span> zlen;</span><br><span class="line">     <span class="type">int</span> zlend:</span><br><span class="line"></span><br><span class="line">&#125;ziplist;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653619558896.png" alt="1653619558896" loading="lazy"></p>
<p><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653619565790.png" alt="1653619565790" loading="lazy"></p>
<p><strong>压缩表特性</strong>：</p>
<p> 节点数据<br>(1) previous_entry_length：记录压缩列表前一个字节的长度。previous_entry_length的长度可能是1个字节或者是5个字节，如果上一个节点的长度<strong>小于254</strong>，则该节点只需要一个字节就可以表示前一个节点的长度了，如果前一个节点的长度<strong>大于等于254</strong>，则previous_entry_length的第一个字节为254，后面用四个字节表示当前节点前一个节点的长度。利用此原理即当前节点位置减去上一个节点的长度即得到上一个节点的起始位置，压缩列表可以从尾部向头部遍历。这么做很有效地减少了内存的浪费。<br>(2) encoding：节点的encoding保存的是节点的content的内容类型以及长度，encoding类型一共有两种，一种字节数组一种是整数，encoding区域长度为1字节、2字节或者5字节长。<br>(3) content：content区域用于保存节点的内容，节点内容类型和长度由encoding决定。 </p>
<p>压缩列表不仅用于实现列表，也用于实现哈希、有序列表。</p>
<h4 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h4><p> 只有同时满足下面两个条件时，才会使用压缩列表：<strong>列表中元素数量小于512个；列表中所有字符串对象都不足64字节</strong>。如果有一个条件不满足，则使用双端列表；且编码只可能由压缩列表转化为双端链表，反方向则不可能。 </p>
<p><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653620605843.png" alt="1653620605843" loading="lazy"></p>
<p> 其中，单个字符串不能超过64字节，是为了便于统一分配每个节点的长度；这里的64字节是指字符串的长度，不包括SDS结构，因为压缩列表使用连续、定长内存块存储字符串，不需要SDS结构指明长度。后面提到压缩列表，也会强调长度不超过64字节，原理与这里类似。 </p>
<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>哈希（作为一种数据结构），不仅是redis对外提供的5种对象类型的一种（与字符串、列表、集合、有序结合并列），也是Redis<strong>作为Key-Value数据库所使用的数据结构</strong>。为了说明的方便，在本文后面当使用“内层的哈希”时，代表的是redis对外提供的5种对象类型的一种；使用“外层的哈希”代指Redis作为Key-Value数据库所使用的数据结构。、</p>
<h4 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h4><p>内层的哈希使用的内部编码可以是压缩列表（ziplist）和哈希表（hashtable）两种；Redis的外层的哈希则只使用了hashtable。</p>
<p>压缩列表前面已介绍。与哈希表相比，压缩列表用于<strong>元素个数少、元素长度小</strong>的场景；其优势在于集中存储，节省空间；同时，虽然对于元素的操作复杂度也由O(n)变为了O(1)，但由于哈希中元素数量较少，因此操作的时间并没有明显劣势。</p>
<p>hashtable：一个hashtable由1个dict结构、2个dictht结构、1个dictEntry指针数组（称为bucket）和多个dictEntry结构组成。</p>
<p>正常情况下（即hashtable没有进行rehash时）各部分关系如下图所示：<br><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653620807521.png" alt="1653620807521" loading="lazy"></p>
<p>下面从底层向上一次介绍各个部分：</p>
<p><strong>1.dictEntry</strong></p>
<p>dictEntry结构用于保存键值对。结构定义如下：<img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653634541002.png" alt="1653634541002" loading="lazy"></p>
<p>其中，各个属性的功能如下：</p>
<ul>
<li>key：键值对中的键</li>
<li>val：键值对中的值，使用union（即共用体）实现， 存储的内容既可能是一个指向值的指针，也可能是64位整型，或无符号64位整型； </li>
<li>next：指向下一个dictEntry，用于解决哈希冲突问题</li>
</ul>
<p><strong>2.bucket</strong></p>
<p>bucket是一个<strong>数组</strong>，数组里每个元素都是指向dictEntry结构的指针。redis中bucket数组的大小计算规则如下：大于dictEntry的、最小的2^n.例如，如果有1000个dictEntry，那么bucket大小为1024；如果有1500个dictEntry，则bucket大小为2048。</p>
<p><strong>3.dictht</strong></p>
<p>结构如下：<img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653635078149.png" alt="1653635078149" loading="lazy"></p>
<p>其中，各个属性的功能如下：</p>
<ul>
<li>table：是一个指针，指向bucket</li>
<li>size：记录了哈希表的大小，即buclet的大小</li>
<li>sizemask：它的值总是<strong>size-1</strong>，这个属性和哈希值一起决定一个键在table中存储的位置</li>
<li>used：记录了已使用的dictEntry的数量</li>
</ul>
<p><strong>4.dict</strong></p>
<p>一般来说，通过使用 dictht和dictEntry结构，便可以实现普通哈希表的功能；但是Redis的实现中，在dictht结构的上层，还有一个dict结构。下面说明dict结构的定义及作用。 </p>
<p>dict结构如下：<img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653635094580.png" alt="1653635094580" loading="lazy"></p>
<p>其中，type属性和privdata属性是为了<strong>适应不同类型的键值对</strong>，用于<strong>创建多态字典</strong>。</p>
<p><strong>ht属性和trehashidx属性</strong>则用于rehash，即当哈希表需要扩展或收缩时使用。ht是一个包含两个项的数组，每项都指向一个dictht结构，这也是Redis的哈希会有1个dict、2个dictht结构的原因。通常情况下，所有的数据都是存在放dict的ht[0]中，ht[1]只在rehash的时候使用。dict进行rehash操作的时候，将ht[0]中的所有数据rehash到ht[1]中。然后将ht[1]赋值给ht[0]，并清空ht[1]。</p>
<p>因此，Redis中的哈希之所以在dictht和dictEntry结构之外还有一个dict结构，<strong>一方面是为了适应不同类型的键值对，另一方面是为了rehash。</strong></p>
<h4 id="编码转换-2"><a href="#编码转换-2" class="headerlink" title="编码转换"></a>编码转换</h4><p>Redis中内层的哈希既<strong>可能使用哈希表，也可能使用压缩列表。</strong></p>
<p>只有同时满足下面两个条件时，才会使用压缩列表：哈希中元素数量小于512个；哈希中所有键值对的键和值字符串长度都小于64字节。如果有一个条件不满足，则使用哈希表；且编码只可能由压缩列表转化为哈希表，反方向则不可能。</p>
<p>下图展示了Redis内层的哈希编码转换的特点：<img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653635498266.png" alt="1653635498266" loading="lazy"></p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合（set）与列表类似，都是用来保存多个字符串，但集合与列表有两点不同：<strong>集合中的元素无序，因此不能通过索引来操作元素；集合中的元素不能有重复。</strong></p>
<p> 一个集合中最多可以存储2^32-1个元素；除了支持常规的增删改查，Redis还支持多个集合取<strong>交集、并集、差集</strong>。 </p>
<h4 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h4><p>集合的内部编码可以是<strong>整数集合（intset）或哈希表（hashtable</strong>）。</p>
<p>哈希表前面已经讲过，需要注意的是，集合在使用哈希表时，值全部被置为null。</p>
<p>整数集合的结构定义如下：<img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653635680342.png" alt="1653635680342" loading="lazy"></p>
<p> 整数集合适用于集合所有元素都是整数且集合元素数量较小的时候，与哈希表相比，整数集合的优势在于集中存储，节省空间；同时，虽然对于元素的操作复杂度也由O(1)变为了O(n)，但由于集合数量较少，因此操作的时间并没有明显劣势。 </p>
<h4 id="编码转换-3"><a href="#编码转换-3" class="headerlink" title="编码转换"></a>编码转换</h4><p> 只有同时满足下面两个条件时，集合才会使用整数集合：<strong>集合中元素数量小于512个；集合中所有元素都是整数值</strong>。如果有一个条件不满足，则使用哈希表；且编码只可能由整数集合转化为哈希表，反方向则不可能。 </p>
<p><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653635828017.png" alt="1653635828017" loading="lazy"></p>
<h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p> 有序集合与集合一样，元素都<strong>不能重复</strong>；但与集合不同的是，有序集合中的元素是有顺序的。与列表使用索引下标作为排序依据不同，有序集合为<strong>每个元素设置一个分数</strong>（score）作为排序依据。 </p>
<h4 id="内部编码-4"><a href="#内部编码-4" class="headerlink" title="内部编码"></a>内部编码</h4><p> 有序集合的内部编码可以是<strong>压缩列表（ziplist）或跳跃表（skiplist）</strong> </p>
<p><strong>跳跃表</strong>是一种有序数据结构，通过<strong>在每个节点中维持多个指向其他节点的指针</strong>，从而达到快速访问节点的目的。除了跳跃表，实现有序数据结构的另一种典型实现是平衡树；大多数情况下，跳跃表的效率可以和平衡树媲美，且跳跃表实现比平衡树简单很多，因此redis中选用跳跃表代替平衡树。跳跃表支持平均O(logN)、最坏O(N)的复杂点进行节点查找，并支持顺序操作。Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成：前者用于保存跳跃表信息（如头结点、尾节点、长度等），后者用于表示跳跃表节点。</p>
<h4 id="编码转换-4"><a href="#编码转换-4" class="headerlink" title="编码转换"></a>编码转换</h4><p>只有同时满足下面两个条件时，才会使用压缩列表：有序集合中元素数量小于128个；有序集合中所有成员长度都不足64字节。如果有一个条件不满足，则使用跳跃表；且编码只可能由压缩列表转化为跳跃表，反方向则不可能。</p>
<p>下图展示了有序集合编码转换的特点：<img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653636060529.png" alt="1653636060529" loading="lazy"></p>
<h1 id="Redis内存优化"><a href="#Redis内存优化" class="headerlink" title="Redis内存优化"></a>Redis内存优化</h1><h2 id="redisObject对象"><a href="#redisObject对象" class="headerlink" title="redisObject对象"></a>redisObject对象</h2><p> Redis在对象结构体设计上，通过<code>type</code>来指定对象数据类型（<code>string 、list、hash、set、zset</code>），<code>encoding</code>来指定对象编码实现，也就是底层数据结构实现（<code>int、intset、ziplist、skiplist、linkedlist、hashtable</code>）。 不同的底层数据结构实现也继承了这种灵活适配的设计思想，根据不同数据对象类型在不同存储空间要求的情况下进行底层数据结构的替换和适配，目的就是<strong>根据实际需要灵活分配内存空间，尽可能减少内存使用。</strong> </p>
<h2 id="键值空间压缩"><a href="#键值空间压缩" class="headerlink" title="键值空间压缩"></a>键值空间压缩</h2><p>降低Redis内存使用最直接的方式就是缩减key和value的长度。</p>
<p><strong>对于键来说</strong>：只能存储<strong>字符串对象</strong>，因此使用较短长度的字符串可以减少内存空间占用。 如user:{userid}:friends:notify:{fid}，可以简化为u:{uid}:fs:nt:{fid} </p>
<p><strong>对于值来说</strong>：可以存储<strong>各种复杂数据类型对象</strong>，但最终存储形式还是<strong>字符串或数值</strong>， 因此场景形式是对业务数据进行序列化存储以达到数据压缩存储的目的 </p>
<h2 id="共享池对象"><a href="#共享池对象" class="headerlink" title="共享池对象"></a>共享池对象</h2><p><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653636487524.png" alt="1653636487524" loading="lazy"></p>
<p> <code>共享对象池</code>是指Redis内部维护<code>[0-9999]</code>的整数对象池。 创建大量的整数类型<code>redisObject</code>存在内存开销，每个<code>redisObject</code>内部结构至少占16字节，甚至超过了整数自身空间消耗。所以Redis内存维护一个<code>[0-9999]</code>的整数对象 池，用于节约内存。除了整数值对象，其他类型如<code>list、hash、set、zset</code>内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。整数对象池在Redis中通过变量<code>REDIS_SHARED_INTEGERS</code>定义，不能通过配置修改 </p>
<p><strong>共享对象池失效</strong>的场景：</p>
<ul>
<li>当设置maxmemory并启用lru相关淘汰策略如：volatile-lru、allkeys-lru时，Redis禁止使用共享池对象</li>
<li>对于<code>ziplist</code>编码的值对象，即使内部数据为整数也无法使用共享对象池，因为ziplist使用压缩且内存连续的结构，对象共享判断成本过高</li>
</ul>
<h3 id="为什么只有整数对象池？"><a href="#为什么只有整数对象池？" class="headerlink" title="为什么只有整数对象池？"></a>为什么只有整数对象池？</h3><p>实际上是对内存和CPU（时间）的平衡：共享对象虽然会降低内存消耗，但是判断两个对象是否相等却需要消耗额外的时间。</p>
<p><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653636910582.png" alt="1653636910582" loading="lazy"></p>
<h2 id="字符串优化"><a href="#字符串优化" class="headerlink" title="字符串优化"></a>字符串优化</h2><p>关于字符串优化，一是Redis内部实现的SDS。</p>
<p><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653637286449.png" alt="1653637286449" loading="lazy"></p>
<h2 id="编码优化"><a href="#编码优化" class="headerlink" title="编码优化"></a>编码优化</h2><p>不同类型对象具体底层实现的数据结构也不同，Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率，<img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653637389658.png" alt="1653637389658" loading="lazy"></p>
<p><img src="/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1653637454936.png" alt="1653637454936" loading="lazy"></p>
<h2 id="String和数字"><a href="#String和数字" class="headerlink" title="String和数字"></a>String和数字</h2><p>如果是整型/长整型，Redis会使用int类型（8字节）存储来代替字符串，可以节省更多空间。因此在可以使用长整型/整型代替字符串的场景下，尽量使用长整型/整型。</p>
<p>在Redis中如果存储的是“123”Redis是能够识别出来这是一个数字并且按照数字来存储，节省存储空间，当然除了这个优化之外，Redis内部会构建一个数字池，默认是10000，那么如果是在这个池子的数字就只需要用一个简单的索引来引用进来就可以，而不需要把重复的数字都分开存储。这个数值可以调整源代码的宏：REDIS_SHARED_INTEGERS来扩大和缩小池子的大小。</p>
<p>字符串对象是Redis内部最常用的数据类型。所有的键都是字符串类 型，值对象数据除了整数之外都使用字符串存储。在使用过程中应当<strong>尽量优先使用整数</strong>，比字符串类型更节省空间。并且要优化字符串使用，避免预分配造成的内存浪费。使用ziplist压缩编码优化hash、list等结构，注重效率和空间的平衡，使用intset编码优化整数集合。使用ziplist编码的hash结构降低小对象链规模。</p>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/images/alipay.jpg"><img loading="lazy" src="/images/alipay.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/wechatpay.png"><img loading="lazy" src="/images/wechatpay.png" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>翔仔</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="Redis-内存管理">http://example.com/2022/05/26/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a class="post-nav-next" href="/2022/05/24/Redis-SDS/" rel="next" title="Redis-SDS"><span class="post-nav-text">Redis-SDS</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2022 </span><span class="with-love" id="animate" title="云游君的赞助者们"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 翔仔</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.2</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.8.11</span></div><div class="live-time"><span>本博客已运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2022-04-10T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} 天 ${passHour} 小时 ${passMinute} 分 ${passSecond} 秒`;
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>