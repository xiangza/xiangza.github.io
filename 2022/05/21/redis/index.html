<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="翔仔"><meta name="copyright" content="翔仔"><meta name="generator" content="Hexo 5.4.2"><meta name="theme" content="hexo-theme-yun"><title>redis | 翔仔的博客</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.2.4/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/@unocss/runtime/mini.global.js"></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"example.com","root":"/","title":"翔仔的小站","version":"1.8.11","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]},"vendors":{"darken":"https://cdn.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="NoSQL数据库 解决CPU压力  解决IO压力   NoSQL（&#x3D;&#x3D; not only sql），泛指非关系型数据库 NoSQL不依赖业务逻辑方式存储，而以简单的key-value模式存储，因此大大增加了数据库的扩展能力  不遵循SQL标准 不支持ACID 远超于SQL的性能  适用于的场景  对数据高并发的读写 海量数据的读写 对数据高可扩展性的  不适合的场景  需要事务支持 基于sql的结">
<meta property="og:type" content="article">
<meta property="og:title" content="redis">
<meta property="og:url" content="http://example.com/2022/05/21/redis/index.html">
<meta property="og:site_name" content="翔仔的博客">
<meta property="og:description" content="NoSQL数据库 解决CPU压力  解决IO压力   NoSQL（&#x3D;&#x3D; not only sql），泛指非关系型数据库 NoSQL不依赖业务逻辑方式存储，而以简单的key-value模式存储，因此大大增加了数据库的扩展能力  不遵循SQL标准 不支持ACID 远超于SQL的性能  适用于的场景  对数据高并发的读写 海量数据的读写 对数据高可扩展性的  不适合的场景  需要事务支持 基于sql的结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653100841289.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653100893716.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653101153037.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653101212342.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653189559311.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653208718939.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653100678175.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653100739202.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653101328933.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653187798246.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653187850121.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653187926429.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653187950195.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653187981025.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653188042455.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653188069020.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653188134721.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653188174941.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653188250723.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653188273007.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653188347119.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653188510332.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653188641453.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653188673008.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653188685265.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653270837588.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653209031059.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653237700944.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653237997328.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653238212606.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653238670327.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653270278846.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653270547078.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653355587934.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653297992994.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653298035859.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653298071630.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653298103661.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653298159750.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653355774784.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653271418146.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653272674988.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653273030040.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653275490810.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653275944665.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653294337487.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653294598612.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653294726249.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653294731554.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653294841831.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653294885309.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653296931612.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653295245127.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653295577875.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653296701954.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653296818155.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653296912552.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653356212657.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653356578925.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653356777962.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653356803978.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653356820075.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653357332228.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653357345406.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653357487556.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653358942835.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653359016114.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653359092761.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653359216384.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653359345948.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653361444997.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653361752396.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653361854255.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653361516881.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/20210125225350321.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653362562517.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653378879859.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653378907009.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653378969679.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653378996005.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/wps1.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/wps2.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/wps3.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/wps4.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/wps5.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/wps6.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/wps7.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/wps8.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/wps9.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/wps10.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653379491071.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653379760933.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653379771259.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653380028485.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653380693916.png">
<meta property="og:image" content="http://example.com/2022/05/21/redis/1653380710105.png">
<meta property="article:published_time" content="2022-05-21T02:27:22.000Z">
<meta property="article:modified_time" content="2022-05-24T08:47:22.468Z">
<meta property="article:author" content="翔仔">
<meta property="article:tag" content="缓存数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/05/21/redis/1653100841289.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="翔仔"><img width="96" loading="lazy" src="/images/tx.jpg" alt="翔仔"><span class="site-author-status" title="不想上学">😭</span></a><div class="site-author-name"><a href="/about/">翔仔</a></div><span class="site-name">翔仔的博客</span><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="我的主页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">28</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">10</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">21</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&amp;uin=910426929&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/YunYouJun" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="985391895@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.</span> <span class="toc-text">NoSQL数据库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-number">2.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">Redis概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E5%90%AF%E5%8A%A8"><span class="toc-number">2.2.</span> <span class="toc-text">安装与启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Units"><span class="toc-number">2.3.1.</span> <span class="toc-text">Units</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INCLUDES"><span class="toc-number">2.3.2.</span> <span class="toc-text">INCLUDES</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NETWORK"><span class="toc-number">2.3.3.</span> <span class="toc-text">NETWORK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GENERAL"><span class="toc-number">2.3.4.</span> <span class="toc-text">GENERAL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SECURITY"><span class="toc-number">2.3.5.</span> <span class="toc-text">SECURITY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LIMITS"><span class="toc-number">2.3.6.</span> <span class="toc-text">LIMITS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">常用五大基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Key%E5%80%BC%E9%94%AE%E4%BD%8D"><span class="toc-number">2.4.1.</span> <span class="toc-text">Key值键位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.4.2.</span> <span class="toc-text">String字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E5%88%97%E8%A1%A8"><span class="toc-number">2.4.3.</span> <span class="toc-text">list列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-1"><span class="toc-number">2.4.3.3.</span> <span class="toc-text">常用命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E9%9B%86%E5%90%88"><span class="toc-number">2.4.4.</span> <span class="toc-text">set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-2"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2"><span class="toc-number">2.4.4.3.</span> <span class="toc-text">数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zset%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">2.4.5.</span> <span class="toc-text">zset有序集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-3"><span class="toc-number">2.4.5.1.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">2.4.5.2.</span> <span class="toc-text">应用案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3"><span class="toc-number">2.4.5.3.</span> <span class="toc-text">数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash"><span class="toc-number">2.4.6.</span> <span class="toc-text">hash</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-4"><span class="toc-number">2.4.6.1.</span> <span class="toc-text">常用命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="toc-number">2.5.</span> <span class="toc-text">发布和订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="toc-number">2.5.1.</span> <span class="toc-text">什么是发布和订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-5"><span class="toc-number">2.5.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85"><span class="toc-number">2.5.3.</span> <span class="toc-text">发布与订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%91%BD%E4%BB%A4"><span class="toc-number">2.5.4.</span> <span class="toc-text">实现发布订阅命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.5.5.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.6.</span> <span class="toc-text">三种特殊数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Geospatial%EF%BC%88%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">2.6.1.</span> <span class="toc-text">Geospatial（地理位置）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-6"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">常用命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hyperloglog%EF%BC%88%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1%EF%BC%89"><span class="toc-number">2.6.2.</span> <span class="toc-text">Hyperloglog（基数统计）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-number">2.6.2.1.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-7"><span class="toc-number">2.6.2.2.</span> <span class="toc-text">常用命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BitMaps%EF%BC%88%E4%BD%8D%E5%9B%BE%EF%BC%89"><span class="toc-number">2.6.3.</span> <span class="toc-text">BitMaps（位图）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="toc-number">2.6.3.1.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-8"><span class="toc-number">2.6.3.2.</span> <span class="toc-text">常用命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">2.7.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.7.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.7.2.</span> <span class="toc-text">事务操作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%94%99%E8%AF%AF"><span class="toc-number">2.7.3.</span> <span class="toc-text">事务错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7"><span class="toc-number">2.7.4.</span> <span class="toc-text">监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E4%B8%89%E7%89%B9%E6%80%A7"><span class="toc-number">2.7.5.</span> <span class="toc-text">Redis事务三特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jedis"><span class="toc-number">2.8.</span> <span class="toc-text">Jedis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">2.9.</span> <span class="toc-text">持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB"><span class="toc-number">2.9.1.</span> <span class="toc-text">RDB</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRDB"><span class="toc-number">2.9.1.0.1.</span> <span class="toc-text">什么是RDB</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.9.1.0.2.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">2.9.1.0.3.</span> <span class="toc-text">触发机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bgsave%E4%B8%8Esave"><span class="toc-number">2.9.1.0.4.</span> <span class="toc-text">bgsave与save</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="toc-number">2.9.1.0.5.</span> <span class="toc-text">优点与缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.9.1.0.6.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF"><span class="toc-number">2.9.2.</span> <span class="toc-text">AOF</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAOF"><span class="toc-number">2.9.2.0.1.</span> <span class="toc-text">什么是AOF</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#aof%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">2.9.2.0.2.</span> <span class="toc-text">aof的配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-number">2.9.2.0.3.</span> <span class="toc-text">AOF持久化流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF%E5%90%AF%E5%8A%A8%E4%B8%8E%E4%BF%AE%E5%A4%8D"><span class="toc-number">2.9.2.0.4.</span> <span class="toc-text">AOF启动与修复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF%E5%90%8C%E6%AD%A5%E9%A2%91%E7%8E%87%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.9.2.0.5.</span> <span class="toc-text">AOF同步频率设置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Rewrite%E5%8E%8B%E7%BC%A9"><span class="toc-number">2.9.2.0.6.</span> <span class="toc-text">Rewrite压缩</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9-1"><span class="toc-number">2.9.2.0.7.</span> <span class="toc-text">优点与缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">2.9.2.0.8.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E4%B8%8EAOF%E9%80%89%E6%8B%A9"><span class="toc-number">2.9.3.</span> <span class="toc-text">RDB与AOF选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">2.10.</span> <span class="toc-text">Redis主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">2.10.1.</span> <span class="toc-text">什么是主从复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">2.10.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">2.10.3.</span> <span class="toc-text">环境配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E"><span class="toc-number">2.10.4.</span> <span class="toc-text">一主二从</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E4%B8%89%E6%8B%9B"><span class="toc-number">2.10.5.</span> <span class="toc-text">常用三招</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%86"><span class="toc-number">2.10.5.1.</span> <span class="toc-text">1.一主二仆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0"><span class="toc-number">2.10.5.2.</span> <span class="toc-text">2.薪火相传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB"><span class="toc-number">2.10.5.3.</span> <span class="toc-text">3.反客为主</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">2.10.6.</span> <span class="toc-text">复制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%88sentinel%EF%BC%89"><span class="toc-number">2.10.7.</span> <span class="toc-text">哨兵模式（sentinel）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.10.7.1.</span> <span class="toc-text">使用步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.10.7.2.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%BB%B6%E6%97%B6"><span class="toc-number">2.10.7.3.</span> <span class="toc-text">复制延时</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="toc-number">2.10.8.</span> <span class="toc-text">故障恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4"><span class="toc-number">2.11.</span> <span class="toc-text">Redis集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">2.11.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%86%E7%BE%A4"><span class="toc-number">2.11.2.</span> <span class="toc-text">什么是集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE"><span class="toc-number">2.11.3.</span> <span class="toc-text">删除持久化数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C6%E4%B8%AA%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.11.4.</span> <span class="toc-text">制作6个实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="toc-number">2.11.4.1.</span> <span class="toc-text">配置基本信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-cluster%E9%85%8D%E7%BD%AE%E4%BF%AE%E6%94%B9"><span class="toc-number">2.11.4.2.</span> <span class="toc-text">redis cluster配置修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%A5%BDredis6379-conf%E6%96%87%E4%BB%B6%EF%BC%8C%E6%8B%B7%E8%B4%9D%E5%A4%9A%E4%B8%AA"><span class="toc-number">2.11.4.3.</span> <span class="toc-text">修改好redis6379.conf文件，拷贝多个</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2%E4%BF%AE%E6%94%B9%E5%8F%A6%E5%A4%96%E4%BA%94%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-number">2.11.4.4.</span> <span class="toc-text">使用查找替换修改另外五个文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%85%AD%E4%B8%AAredis%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.11.4.5.</span> <span class="toc-text">启动六个redis服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E5%85%AD%E4%B8%AA%E8%8A%82%E7%82%B9%E5%90%88%E6%88%90%E4%B8%80%E4%B8%AA%E9%9B%86%E7%BE%A4"><span class="toc-number">2.11.4.6.</span> <span class="toc-text">将六个节点合成一个集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E9%87%87%E7%94%A8%E9%9B%86%E7%BE%A4%E7%AD%96%E7%95%A5%E8%BF%9E%E6%8E%A5%EF%BC%8C%E8%AE%BE%E7%BD%AE%E6%95%B0%E6%8D%AE%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E5%88%B0%E7%9B%B8%E5%BA%94%E7%9A%84%E5%86%99%E4%B8%BB%E6%9C%BA"><span class="toc-number">2.11.4.7.</span> <span class="toc-text">*-c 采用集群策略连接，设置数据会自动切换到相应的写主机*</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-cluster-%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E8%BF%99%E5%85%AD%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">2.11.4.8.</span> <span class="toc-text">*redis cluster 如何分配这六个节点?*</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFslots"><span class="toc-number">2.11.4.9.</span> <span class="toc-text">什么是slots</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E9%9B%86%E7%BE%A4%E4%B8%AD%E5%BD%95%E5%85%A5%E5%80%BC"><span class="toc-number">2.11.4.10.</span> <span class="toc-text">*在集群中录入值*</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="toc-number">2.11.4.11.</span> <span class="toc-text">*查询集群中的值*</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D-1"><span class="toc-number">2.11.4.12.</span> <span class="toc-text">*故障恢复*</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E5%A5%BD%E5%A4%84%E4%B8%8E%E4%B8%8D%E8%B6%B3"><span class="toc-number">2.11.5.</span> <span class="toc-text">Redis集群的好处与不足</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-number">2.11.6.</span> <span class="toc-text">Redis应用问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">2.11.6.1.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.11.6.1.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3"><span class="toc-number">2.11.6.1.2.</span> <span class="toc-text">解决</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">2.11.6.2.</span> <span class="toc-text">缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">2.11.6.2.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3-1"><span class="toc-number">2.11.6.2.2.</span> <span class="toc-text">解决</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">2.11.6.3.</span> <span class="toc-text">缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">2.11.6.3.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3-2"><span class="toc-number">2.11.6.3.2.</span> <span class="toc-text">解决</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/21/redis/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="翔仔"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="翔仔的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">redis</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2022-05-21 10:27:22" itemprop="dateCreated datePublished" datetime="2022-05-21T10:27:22+08:00">2022-05-21</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2022-05-24 16:47:22" itemprop="dateModified" datetime="2022-05-24T16:47:22+08:00">2022-05-24</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">数据库</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">缓存数据库</span></a></span></div><div class="post-author"><span class="author-name">翔仔</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h1><ul>
<li><p>解决CPU压力<img src="/2022/05/21/redis/1653100841289.png" alt="1653100841289" loading="lazy"></p>
</li>
<li><p>解决IO压力<img src="/2022/05/21/redis/1653100893716.png" alt="1653100893716" loading="lazy"></p>
</li>
</ul>
<p>NoSQL（== not only sql），泛指非关系型数据库</p>
<p>NoSQL不依赖业务逻辑方式存储，而以简单的key-value模式存储，因此大大增加了数据库的扩展能力</p>
<ul>
<li>不遵循SQL标准</li>
<li>不支持ACID</li>
<li>远超于SQL的性能</li>
</ul>
<p><strong>适用于的场景</strong></p>
<ul>
<li>对数据高并发的读写</li>
<li>海量数据的读写</li>
<li>对数据高可扩展性的</li>
</ul>
<p><strong>不适合的场景</strong></p>
<ul>
<li>需要事务支持</li>
<li>基于sql的结构化查询存储，处理复杂的关系，</li>
</ul>
<p><strong>NoSQL优点</strong></p>
<p> 1.缓存数据库，完全在内存中，速度快，数据结构简单<br>2.减少io操作，数据库和表拆分，虽然破坏业务逻辑，即外加一个缓存数据库，提高数据库速度，也可以用专门的存储方式，以及针对不同的数据结构存储 </p>
<p><strong>大数据时代常用的数据库</strong></p>
<ul>
<li><p>行式数据库<img src="/2022/05/21/redis/1653101153037.png" alt="1653101153037" loading="lazy"></p>
</li>
<li><p>列式数据库<img src="/2022/05/21/redis/1653101212342.png" alt="1653101212342" loading="lazy"></p>
</li>
</ul>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h2><blockquote>
<p>Redis是典型的NoSQL数据库</p>
</blockquote>
<p>官网：<a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io</a></p>
<ul>
<li>Redis是一个开源的key-value存储系统</li>
<li>和Memcached类似，支持存户的value类型相对更多，包括string、set、zset、sorted set、hash。</li>
<li>在此基础上Redis支持各种不同的排序方式</li>
<li>与Memcached一样，为了保证效率，数据都缓存在内存中</li>
<li>区别是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件</li>
<li>并且在此基础上实现了master-slave主从同步</li>
<li>单线程+IO多路复用</li>
</ul>
<blockquote>
<p>与memcache三点不同：支持多数据类型，持久化，单线程+多路io复用</p>
</blockquote>
<p><strong>多路io复用：</strong></p>
<ul>
<li>使用一个线程来检查多个文件描述符(Socket)的就绪状态(比如调用select和poll函数，传入多个文件描述符)</li>
<li>如果有一个文件描述符就绪，则返回，否则阻塞直到超时</li>
<li>得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行(比如使用线程池)</li>
</ul>
<p><strong>多样的数据结构持久化数据</strong><img src="/2022/05/21/redis/1653189559311.png" alt="1653189559311" loading="lazy"></p>
<blockquote>
<p>redis是单线程的，基于内存操作的。</p>
<p>所以Redis的性能瓶颈不是cpu，而是机器内存和网络带宽</p>
</blockquote>
<blockquote>
<p>Redis为什么单线程还这么快？</p>
</blockquote>
<ul>
<li>误区1：高性能的服务器一定是多线程的？</li>
<li>误区2：多线程(cpu上下文会切换)一定比单线程效率高？</li>
</ul>
<p>核心：Redis是将所有的数据放在内存中，所以说使用单线程去操作效率就是最高的，多线程(spu上下文切换：耗时的操作)，对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个cpu上，在内存存储数据情况下，单线程才是最佳方案。</p>
<p><strong>应用场景</strong></p>
<p>高频次，热门访问的数据，降低数据库IO</p>
<p>分布式架构，做session共享</p>
<p><img src="/2022/05/21/redis/1653208718939.png" alt="1653208718939" loading="lazy"></p>
<h2 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h2><p>安装c语言的编译环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br><span class="line">yum install -y devtoolset-8-toolchain</span><br><span class="line">scl enable devtoolset-8 bash</span><br></pre></td></tr></table></figure>

<p>通过wget下载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-6.2.6.tar.gz</span><br><span class="line"></span><br><span class="line">// 下载路径：/opt</span><br></pre></td></tr></table></figure>

<p>解压至当前目录</p>
<blockquote>
<p>tar -zxvf redis-6.2.6.tar.gz </p>
</blockquote>
<p>解压后进入</p>
<blockquote>
<p>cd redis-6.2.6</p>
</blockquote>
<p>在当前目录执行make</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>默认安装在/usr/local/bin <img src="/2022/05/21/redis/1653100678175.png" alt="1653100678175" loading="lazy"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark：性能测试工具，可以在自己本子运行，看看自己本子性能如何</span><br><span class="line">redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲</span><br><span class="line">redis-check-dump：修复有问题的dump.rdb文件</span><br><span class="line">redis-sentinel：Redis集群使用</span><br><span class="line">redis-server：Redis服务器启动命令</span><br><span class="line">redis-cli：客户端，操作入口</span><br></pre></td></tr></table></figure>

<p>前台启动：/USR/LOCAL/BIN 目录下启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server(前台启动)</span><br></pre></td></tr></table></figure>

<p>后台启动：</p>
<ul>
<li> 安装 <em><strong>redis</strong></em> 的目录 <em><strong>/opt/redis-6.2.6</strong></em> 中将 <em><strong>redis.conf</strong></em> 复制到任意一个文件夹下 </li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf /etc/redis.conf</span><br><span class="line">// 将redis.conf复制到/etc/下</span><br></pre></td></tr></table></figure>

<ul>
<li><p>修改/etc/redis/conf配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim redis.conf</span><br><span class="line"></span><br><span class="line"># daemonize no 修改为 daemonize yes</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2022/05/21/redis/1653100739202.png" alt="1653100739202" loading="lazy"></p>
<ul>
<li><p>/usr/lobal/bin 目录启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>关闭redis</strong></p>
<ul>
<li>kill 进程</li>
<li>命令 shutdown</li>
</ul>
<p>默认端口6379</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>redis.conf</p>
<h3 id="Units"><a href="#Units" class="headerlink" title="Units"></a>Units</h3><blockquote>
<p>单位，配置大小单位，开头定义了一些基本的度量单位，支支持bytes，不支持bit。大小写不敏感</p>
</blockquote>
<p><img src="/2022/05/21/redis/1653101328933.png" alt="1653101328933" loading="lazy"></p>
<h3 id="INCLUDES"><a href="#INCLUDES" class="headerlink" title="INCLUDES"></a>INCLUDES</h3><blockquote>
<p>包含，多实例的情况可以把公用的配置文件提取出来</p>
</blockquote>
<p><img src="/2022/05/21/redis/1653187798246.png" alt="1653187798246" loading="lazy"></p>
<h3 id="NETWORK"><a href="#NETWORK" class="headerlink" title="NETWORK"></a>NETWORK</h3><blockquote>
<p>网络相关配置</p>
<p>bind</p>
<p>默认情况 <code>bind=127.0.0.1</code> 只能接受本机的访问请求。</p>
<p>不写的情况下，无限制接受任何 <em><strong>ip</strong></em> 地址的访问。</p>
<p>生产环境肯定要写你应用服务器的地址，服务器是需要远程访问的，<em>所以需要将其注释掉</em>。</p>
<p>如果开启了<em><strong>protected-mode</strong></em>，那么在没有设定 <em><strong>bind ip</strong></em> 且没有设密码的情况下，<em><strong>Redis</strong></em> 只允许接受本机的响应。</p>
</blockquote>
<p><img src="/2022/05/21/redis/1653187850121.png" alt="1653187850121" loading="lazy"></p>
<p>protected-mode</p>
<p>将本机访问保护模式设置no<img src="/2022/05/21/redis/1653187926429.png" alt="1653187926429" loading="lazy"></p>
<p>port</p>
<p>端口号，6379<img src="/2022/05/21/redis/1653187950195.png" alt="1653187950195" loading="lazy"></p>
<p>tcp-backlog</p>
<p>设置 <em><strong>tcp</strong></em> 的 <em><strong>backlog</strong></em>，<em><strong>backlog</strong></em> 其实是一个连接队列，<em><strong>backlog</strong></em> 队列总和 == 未完成三次握手队列 ++ 已经完成三次握手队列。</p>
<p>在高并发环境下你需要一个高 <em><strong>backlog</strong></em> 值来避免慢客户端连接问题。</p>
<p><img src="/2022/05/21/redis/1653187981025.png" alt="1653187981025" loading="lazy"></p>
<p>timeout</p>
<p>一个空闲的客户端维持多少秒会关闭，0表示关闭该功能，即永不关闭</p>
<p><img src="/2022/05/21/redis/1653188042455.png" alt="1653188042455" loading="lazy"></p>
<p>tcp-keepalive</p>
<p>对访问客户端的一种心跳检测，每个 <em><strong>n</strong></em> 秒检测一次。</p>
<p>单位为秒，如果设置为 0，则不会进行 <em><strong>Keepalive</strong></em> 检测，建议设置成 60。<img src="/2022/05/21/redis/1653188069020.png" alt="1653188069020" loading="lazy"></p>
<h3 id="GENERAL"><a href="#GENERAL" class="headerlink" title="GENERAL"></a>GENERAL</h3><p>通用</p>
<p>daemonize 是否为后台进程，设置为yes</p>
<p>守护进程，后台启动<img src="/2022/05/21/redis/1653188134721.png" alt="1653188134721" loading="lazy"></p>
<p>pifgile</p>
<p>存放pid文件的位置，每个实例会产生一个不同的pid文件<img src="/2022/05/21/redis/1653188174941.png" alt="1653188174941" loading="lazy"></p>
<p>loglevel</p>
<p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice。<img src="/2022/05/21/redis/1653188250723.png" alt="1653188250723" loading="lazy"></p>
<p>lofile，日志文件名称<img src="/2022/05/21/redis/1653188273007.png" alt="1653188273007" loading="lazy"></p>
<p>database，设定库的数量，默认16，默认数据库为0，可以使用select<dbid>命令在连接上指定数据库id<img src="/2022/05/21/redis/1653188347119.png" alt="1653188347119" loading="lazy"></dbid></p>
<h3 id="SECURITY"><a href="#SECURITY" class="headerlink" title="SECURITY"></a>SECURITY</h3><p>安全， 访问密码的查看、设置和取消。在命令中设置密码，只是临时的。重启Redis服务器，密码会还原。</p>
<p>永久设置需要在配置文件中进行设置</p>
<h3 id="LIMITS"><a href="#LIMITS" class="headerlink" title="LIMITS"></a>LIMITS</h3><p>限制，</p>
<p>maxclients，设置redis同时可以与多少个客户端进行连接，默认情况是10000个客户端。如果达到了上限，redis则会拒绝新的连接请求，并且向这些连接请求方发出  <em><strong>max number of clients reached</strong></em> 以作回应。 <img src="/2022/05/21/redis/1653188510332.png" alt="1653188510332" loading="lazy"></p>
<p>maxmemory</p>
<p>建议必须设置，否则将内存占满，造成服务器宕机</p>
<p>设置redis可以使用的内存量，一旦达到内存使用上限，redis将会视图移除内部数据，移除规则可以通过maxmemory-palicy指定</p>
<p>如果 <em><strong>redis</strong></em> 无法根据移除规则来移除内存中的数据，或者设置了不允许移除，那么 <em><strong>redis</strong></em> 则会针对那些需要申请内存的指令返回错误信息，比如 <em><strong>SET、LPUSH</strong></em> 等。</p>
<p>但是对于无内存申请的指令，仍然会正常响应，比如 <em><strong>GET</strong></em> 等。如果你的 <em><strong>redis</strong></em> 是主 <em><strong>redis</strong></em>（ 说明你的 <em><strong>redis</strong></em> 有从 <em><strong>redis</strong></em> ），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。<img src="/2022/05/21/redis/1653188641453.png" alt="1653188641453" loading="lazy"></p>
<p><em><strong>maxmemory-policy</strong></em></p>
<p><em><strong>volatile-lru</strong></em>：使用 <em><strong>LRU</strong></em> 算法移除 <em><strong>key</strong></em>，只对设置了过期时间的键（最近最少使用）。</p>
<p><em><strong>allkeys-lru</strong></em>：在所有集合 <em><strong>key</strong></em> 中，使用 <em><strong>LRU</strong></em> 算法移除 <em><strong>key</strong></em>。</p>
<p><em><strong>volatile-random</strong></em>：在过期集合中移除随机的 <em><strong>key</strong></em>，只对设置了过期时间的键。</p>
<p><em><strong>allkeys-random</strong></em>：在所有集合 <em><strong>key</strong></em> 中，移除随机的 <em><strong>key</strong></em>。</p>
<p><em><strong>volatile-ttl</strong></em>：移除那些 <em><strong>TTL</strong></em> 值最小的 <em><strong>key</strong></em>，即那些最近要过期的 <em><strong>key</strong></em>。</p>
<p><em><strong>noeviction</strong></em>：不进行移除。针对写操作，只是返回错误信息。</p>
<p><img src="/2022/05/21/redis/1653188673008.png" alt="1653188673008" loading="lazy"></p>
<p><em><strong>maxmemory-samples</strong></em></p>
<p>设置样本数量，<em><strong>LRU</strong></em> 算法和最小 <em><strong>TTL</strong></em> 算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，<em><strong>redis</strong></em> 默认会检查这么多个 <em><strong>key</strong></em> 并选择其中 <em><strong>LRU</strong></em> 的那个。</p>
<p>一般设置 3 到 7 的数字，数值越小样本越不准确，但性能消耗越小。<img src="/2022/05/21/redis/1653188685265.png" alt="1653188685265" loading="lazy"></p>
<h2 id="常用五大基本数据类型"><a href="#常用五大基本数据类型" class="headerlink" title="常用五大基本数据类型"></a>常用五大基本数据类型</h2><p><img src="/2022/05/21/redis/1653270837588.png" alt="1653270837588" loading="lazy"></p>
<p>redis常见数据类型操作命令<a target="_blank" rel="noopener" href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p>
<h3 id="Key值键位"><a href="#Key值键位" class="headerlink" title="Key值键位"></a>Key值键位</h3><blockquote>
<p>在Redis中，无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作</p>
</blockquote>
<p><strong>key值的操作</strong>：</p>
<ul>
<li>keys *：查看当前库的所有key</li>
<li>set key value：设置key值与value</li>
<li>exists key：查看key是是否存在</li>
<li>move key db：将键值对移动到指定数据库</li>
<li>expire key second：设置键值对的过期时间</li>
<li>type key：查看key是什么类型</li>
<li>del key：删除指定的key数据</li>
<li>unlink key：根据value选择非阻塞删除(仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作)</li>
<li>expire key 10 10秒钟：为给定的key设置过期时间</li>
<li>ttl key：查看还有多少秒过期，-1表示永不过期，-2表示已过期</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys * # 查看当前数据库所有key</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; set name qinjiang # set key</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;name&quot;</span><br><span class="line">127.0.0.1:6379&gt; move age 1 # 将键值对移动到指定数据库</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; EXISTS age # 判断键是否存在</span><br><span class="line">(integer) 0 # 不存在</span><br><span class="line">127.0.0.1:6379&gt; EXISTS name</span><br><span class="line">(integer) 1 # 存在</span><br><span class="line">127.0.0.1:6379&gt; SELECT 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; del age # 删除键值对</span><br><span class="line">(integer) 1 # 删除个数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXPIRE age 15 # 设置键值对的过期时间</span><br><span class="line"></span><br><span class="line">(integer) 1 # 设置成功 开始计数</span><br><span class="line">127.0.0.1:6379&gt; ttl age # 查看key的过期剩余时间</span><br><span class="line">(integer) 13</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(integer) -2 # -2 表示key过期，-1表示key未设置过期时间</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get age # 过期的key 会被自动delete</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; type name # 查看value的数据类型</span><br><span class="line">string</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>库的选择：</strong></p>
<ul>
<li>select命令切换数据库</li>
<li>dbsize：查看当前数据库的key数量</li>
<li>flushdb：清空当前库</li>
<li>flushall通杀全部库</li>
</ul>
<h3 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h3><ul>
<li>一个key对应一个value</li>
<li>二进制安全的，即可包含任何数据</li>
<li>value最多可以是512m</li>
</ul>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul>
<li>set key value：设置key值</li>
<li>get key：查询key值</li>
<li>append key value：将给定的value追加到原值的末尾</li>
<li>strlen key：获取值的长度</li>
<li>setnx key value：只有在key不存在时设置key值</li>
<li>inct key：将key值存储的数字增1，只对数字操作，如果为空，新增值为1</li>
<li>decr key：将key值存储的数字减1，只对数字操作，如果为空，新增值为-1</li>
<li>incrby/decrby key&lt;步长&gt;：将key值存储的数字增减步长</li>
</ul>
<p>补充：原子操作，不会被打断</p>
<p>补充额外字符串参数：</p>
<ul>
<li>mset key value key value..：同时设置一个或多个key-value</li>
<li>mget key key…：同时获取一个或多个value</li>
<li>msetnx  key value key value…：同时设置一个或多个key-value当且仅当所有的key都不存在</li>
<li>getrange key &lt;起始位置&gt; &lt;结束位置&gt; 获取key的起始位置和结束位置的值</li>
<li>setrange key &lt;起始位置&gt; value：将value的值覆盖起始位置开始</li>
<li>set key &lt;&gt; value：设置键值的同时，设置过期时间</li>
<li>getset key value：用新值换旧值</li>
</ul>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h4><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.</p>
<p><img src="/2022/05/21/redis/1653209031059.png" alt="1653209031059" loading="lazy"></p>
<p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>计数器，比如用户访问次数、热点文章点赞转发数量等</li>
<li>统计多单位的数量：uid：12312：follow：0</li>
<li>粉丝数</li>
<li>对象存储缓存</li>
</ul>
<h3 id="list列表"><a href="#list列表" class="headerlink" title="list列表"></a>list列表</h3><blockquote>
<p>Redis列表是简单的字符串列表，按照插入顺序排序，你可以添加到列表的头部（左边）或者尾部（右边）一个列表最多可以包含232-1个元素（4294967295，每个列表超过40亿个元素）</p>
</blockquote>
<p>列表，可以经过规则定义将其变为队列、栈、双端队列等<img src="/2022/05/21/redis/1653237700944.png" alt="1653237700944" loading="lazy"></p>
<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p>List的数据结构为快速链表quickList。</p>
<p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结结构是zipList，既是<strong>压缩列表</strong>。</p>
<p>它将所有的元素紧挨着一起存储，分配的是一块连续内存。当数据量比较多的时候才会改成quickList。</p>
<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。<img src="/2022/05/21/redis/1653237997328.png" alt="1653237997328" loading="lazy"></p>
<p>Redis将<strong>链表和zipList结合</strong>起来组成了quickList。也就是将多个zipList使用双向指针串起来使用，这样既满足了快速的插入和删除，又不会出现太大的空间冗余。</p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>发布订阅或者消息队列、慢查询</p>
<h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><p><img src="/2022/05/21/redis/1653238212606.png" alt="1653238212606" loading="lazy"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">---------------------------LPUSH---RPUSH---LRANGE--------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPUSH mylist k1 # LPUSH mylist=&gt;&#123;1&#125;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH mylist k2 # LPUSH mylist=&gt;&#123;2,1&#125;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist k3 # RPUSH mylist=&gt;&#123;2,1,3&#125;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get mylist # 普通的get是无法获取list值的</span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 4 # LRANGE 获取起止位置范围内的元素</span><br><span class="line">1) &quot;k2&quot;</span><br><span class="line">2) &quot;k1&quot;</span><br><span class="line">3) &quot;k3&quot;</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 2</span><br><span class="line">1) &quot;k2&quot;</span><br><span class="line">2) &quot;k1&quot;</span><br><span class="line">3) &quot;k3&quot;</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 1</span><br><span class="line">1) &quot;k2&quot;</span><br><span class="line">2) &quot;k1&quot;</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1 # 获取全部元素</span><br><span class="line">1) &quot;k2&quot;</span><br><span class="line">2) &quot;k1&quot;</span><br><span class="line">3) &quot;k3&quot;</span><br><span class="line"></span><br><span class="line">---------------------------LPUSHX---RPUSHX-----------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPUSHX list v1 # list不存在 LPUSHX失败</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; LPUSHX list v1 v2  </span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; LPUSHX mylist k4 k5 # 向mylist中 左边 PUSH k4 k5</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;k5&quot;</span><br><span class="line">2) &quot;k4&quot;</span><br><span class="line">3) &quot;k2&quot;</span><br><span class="line">4) &quot;k1&quot;</span><br><span class="line">5) &quot;k3&quot;</span><br><span class="line"></span><br><span class="line">---------------------------LINSERT--LLEN--LINDEX--LSET----------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LINSERT mylist after k2 ins_key1 # 在k2元素后 插入ins_key1</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;k5&quot;</span><br><span class="line">2) &quot;k4&quot;</span><br><span class="line">3) &quot;k2&quot;</span><br><span class="line">4) &quot;ins_key1&quot;</span><br><span class="line">5) &quot;k1&quot;</span><br><span class="line">6) &quot;k3&quot;</span><br><span class="line">127.0.0.1:6379&gt; LLEN mylist # 查看mylist的长度</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; LINDEX mylist 3 # 获取下标为3的元素</span><br><span class="line">&quot;ins_key1&quot;</span><br><span class="line">127.0.0.1:6379&gt; LINDEX mylist 0</span><br><span class="line">&quot;k5&quot;</span><br><span class="line">127.0.0.1:6379&gt; LSET mylist 3 k6 # 将下标3的元素 set值为k6</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;k5&quot;</span><br><span class="line">2) &quot;k4&quot;</span><br><span class="line">3) &quot;k2&quot;</span><br><span class="line">4) &quot;k6&quot;</span><br><span class="line">5) &quot;k1&quot;</span><br><span class="line">6) &quot;k3&quot;</span><br><span class="line"></span><br><span class="line">---------------------------LPOP--RPOP--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPOP mylist # 左侧(头部)弹出</span><br><span class="line">&quot;k5&quot;</span><br><span class="line">127.0.0.1:6379&gt; RPOP mylist # 右侧(尾部)弹出</span><br><span class="line">&quot;k3&quot;</span><br><span class="line"></span><br><span class="line">---------------------------RPOPLPUSH--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;k4&quot;</span><br><span class="line">2) &quot;k2&quot;</span><br><span class="line">3) &quot;k6&quot;</span><br><span class="line">4) &quot;k1&quot;</span><br><span class="line">127.0.0.1:6379&gt; RPOPLPUSH mylist newlist # 将mylist的最后一个值(k1)弹出，加入到newlist的头部</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">127.0.0.1:6379&gt; LRANGE newlist 0 -1</span><br><span class="line">1) &quot;k1&quot;</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;k4&quot;</span><br><span class="line">2) &quot;k2&quot;</span><br><span class="line">3) &quot;k6&quot;</span><br><span class="line"></span><br><span class="line">---------------------------LTRIM--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LTRIM mylist 0 1 # 截取mylist中的 0~1部分</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;k4&quot;</span><br><span class="line">2) &quot;k2&quot;</span><br><span class="line"></span><br><span class="line"># 初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2</span><br><span class="line">---------------------------LREM--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LREM mylist 3 k2 # 从头部开始搜索 至多删除3个 k2</span><br><span class="line">(integer) 3</span><br><span class="line"># 删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LREM mylist -2 k2 #从尾部开始搜索 至多删除2个 k2</span><br><span class="line">(integer) 2</span><br><span class="line"># 删除后：mylist: k2,k2,k2,k4,k2,k2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------BLPOP--BRPOP--------------------------</span><br><span class="line"></span><br><span class="line">mylist: k2,k2,k2,k4,k2,k2</span><br><span class="line">newlist: k1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist mylist 30 # 从newlist中弹出第一个值，mylist作为候选</span><br><span class="line">1) &quot;newlist&quot; # 弹出</span><br><span class="line">2) &quot;k1&quot;</span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist mylist 30</span><br><span class="line">1) &quot;mylist&quot; # 由于newlist空了 从mylist中弹出</span><br><span class="line">2) &quot;k2&quot;</span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist 30</span><br><span class="line">(30.10s) # 超时了</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist 30 # 我们连接另一个客户端向newlist中push了test, 阻塞被解决。</span><br><span class="line">1) &quot;newlist&quot;</span><br><span class="line">2) &quot;test&quot;</span><br><span class="line">(12.54s)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h3><blockquote>
<p>Reids的set是string类型的无序集合。集合成员是唯一的，着意味着集合中不能出现重复的数据。</p>
<p>Redis中集合是通过哈希表实现的，所以添加、删除、查找的复杂度都是O(1)。</p>
<p>集合中最大成员数为232-1（4294967295）</p>
</blockquote>
<h4 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令<img src="/2022/05/21/redis/1653238670327.png" alt="1653238670327" loading="lazy"></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">---------------SADD--SCARD--SMEMBERS--SISMEMBER--------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SADD myset m1 m2 m3 m4 # 向myset中增加成员 m1~m4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; SCARD myset # 获取集合的成员数目</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers myset # 获取集合中所有成员</span><br><span class="line">1) &quot;m4&quot;</span><br><span class="line">2) &quot;m3&quot;</span><br><span class="line">3) &quot;m2&quot;</span><br><span class="line">4) &quot;m1&quot;</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m5 # 查询m5是否是myset的成员</span><br><span class="line">(integer) 0 # 不是，返回0</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m2</span><br><span class="line">(integer) 1 # 是，返回1</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m3</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">---------------------SRANDMEMBER--SPOP----------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 3 # 随机返回3个成员</span><br><span class="line">1) &quot;m2&quot;</span><br><span class="line">2) &quot;m3&quot;</span><br><span class="line">3) &quot;m4&quot;</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset # 随机返回1个成员</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">127.0.0.1:6379&gt; SPOP myset 2 # 随机移除并返回2个成员</span><br><span class="line">1) &quot;m1&quot;</span><br><span class="line">2) &quot;m4&quot;</span><br><span class="line"># 将set还原到&#123;m1,m2,m3,m4&#125;</span><br><span class="line"></span><br><span class="line">---------------------SMOVE--SREM----------------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SMOVE myset newset m3 # 将myset中m3成员移动到newset集合</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) &quot;m4&quot;</span><br><span class="line">2) &quot;m2&quot;</span><br><span class="line">3) &quot;m1&quot;</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS newset</span><br><span class="line">1) &quot;m3&quot;</span><br><span class="line">127.0.0.1:6379&gt; SREM newset m3 # 从newset中移除m3元素</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS newset</span><br><span class="line">(empty list or set)</span><br><span class="line"></span><br><span class="line"># 下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算</span><br><span class="line"># setx=&gt;&#123;m1,m2,m4,m6&#125;, sety=&gt;&#123;m2,m5,m6&#125;, setz=&gt;&#123;m1,m3,m6&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------SDIFF------------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SDIFF setx sety setz # 等价于setx-sety-setz</span><br><span class="line">1) &quot;m4&quot;</span><br><span class="line">127.0.0.1:6379&gt; SDIFF setx sety # setx - sety</span><br><span class="line">1) &quot;m4&quot;</span><br><span class="line">2) &quot;m1&quot;</span><br><span class="line">127.0.0.1:6379&gt; SDIFF sety setx # sety - setx</span><br><span class="line">1) &quot;m5&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------SINTER---------------------------------------</span><br><span class="line"># 共同关注（交集）</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SINTER setx sety setz # 求 setx、sety、setx的交集</span><br><span class="line">1) &quot;m6&quot;</span><br><span class="line">127.0.0.1:6379&gt; SINTER setx sety # 求setx sety的交集</span><br><span class="line">1) &quot;m2&quot;</span><br><span class="line">2) &quot;m6&quot;</span><br><span class="line"></span><br><span class="line">-------------------------SUNION---------------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SUNION setx sety setz # setx sety setz的并集</span><br><span class="line">1) &quot;m4&quot;</span><br><span class="line">2) &quot;m6&quot;</span><br><span class="line">3) &quot;m3&quot;</span><br><span class="line">4) &quot;m2&quot;</span><br><span class="line">5) &quot;m1&quot;</span><br><span class="line">6) &quot;m5&quot;</span><br><span class="line">127.0.0.1:6379&gt; SUNION setx sety # setx sety 并集</span><br><span class="line">1) &quot;m4&quot;</span><br><span class="line">2) &quot;m6&quot;</span><br><span class="line">3) &quot;m2&quot;</span><br><span class="line">4) &quot;m1&quot;</span><br><span class="line">5) &quot;m5&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><p>需要存放的数据不能重复以及需要获取多个数据源交集和并集等</p>
<h4 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h4><p>set数据结构是dict字典，字典是用哈希表实现的。</p>
<p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p>
<h3 id="zset有序集合"><a href="#zset有序集合" class="headerlink" title="zset有序集合"></a>zset有序集合</h3><blockquote>
<p>每个元素都会关联一个double类型的分数(score)，通过分数来为集合中的成员进行从小到大的排序。</p>
<p>score相同：按字典序排序</p>
<p>有序集合的成员是唯一的，但分数却可以重复</p>
</blockquote>
<h4 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h4><p><img src="/2022/05/21/redis/1653270278846.png" alt="1653270278846" loading="lazy"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">-------------------ZADD--ZCARD--ZCOUNT--------------</span><br><span class="line">127.0.0.1:6379&gt; ZADD myzset 1 m1 2 m2 3 m3 # 向有序集合myzset中添加成员m1 score=1 以及成员m2 score=2..</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZCARD myzset # 获取有序集合的成员数</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myzset 0 1 # 获取score在 [0,1]区间的成员数量</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myzset 0 2</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">----------------ZINCRBY--ZSCORE--------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZINCRBY myzset 5 m2 # 将成员m2的score +5</span><br><span class="line">&quot;7&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myzset m1 # 获取成员m1的score</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myzset m2</span><br><span class="line">&quot;7&quot;</span><br><span class="line"></span><br><span class="line">--------------ZRANK--ZRANGE-----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANK myzset m1 # 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; ZRANK myzset m2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 1 # 获取索引在 0~1的成员</span><br><span class="line">1) &quot;m1&quot;</span><br><span class="line">2) &quot;m3&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 -1 # 获取全部成员</span><br><span class="line">1) &quot;m1&quot;</span><br><span class="line">2) &quot;m3&quot;</span><br><span class="line">3) &quot;m2&quot;</span><br><span class="line"></span><br><span class="line">#testset=&gt;&#123;abc,add,amaze,apple,back,java,redis&#125; score均为0</span><br><span class="line">------------------ZRANGEBYLEX---------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + # 返回所有成员</span><br><span class="line">1) &quot;abc&quot;</span><br><span class="line">2) &quot;add&quot;</span><br><span class="line">3) &quot;amaze&quot;</span><br><span class="line">4) &quot;apple&quot;</span><br><span class="line">5) &quot;back&quot;</span><br><span class="line">6) &quot;java&quot;</span><br><span class="line">7) &quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 0 3 # 分页 按索引显示查询结果的 0,1,2条记录</span><br><span class="line">1) &quot;abc&quot;</span><br><span class="line">2) &quot;add&quot;</span><br><span class="line">3) &quot;amaze&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 3 3 # 显示 3,4,5条记录</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">2) &quot;back&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset (- [apple # 显示 (-,apple] 区间内的成员</span><br><span class="line">1) &quot;abc&quot;</span><br><span class="line">2) &quot;add&quot;</span><br><span class="line">3) &quot;amaze&quot;</span><br><span class="line">4) &quot;apple&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset [apple [java # 显示 [apple,java]字典区间的成员</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">2) &quot;back&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line"></span><br><span class="line">-----------------------ZRANGEBYSCORE---------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 10 # 返回score在 [1,10]之间的的成员</span><br><span class="line">1) &quot;m1&quot;</span><br><span class="line">2) &quot;m3&quot;</span><br><span class="line">3) &quot;m2&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 5</span><br><span class="line">1) &quot;m1&quot;</span><br><span class="line">2) &quot;m3&quot;</span><br><span class="line"></span><br><span class="line">--------------------ZLEXCOUNT-----------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZLEXCOUNT testset - +</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; ZLEXCOUNT testset [apple [java</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">------------------ZREM--ZREMRANGEBYLEX--ZREMRANGBYRANK--ZREMRANGEBYSCORE--------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZREM testset abc # 移除成员abc</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYLEX testset [apple [java # 移除字典区间[apple,java]中的所有成员</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYRANK testset 0 1 # 移除排名0~1的所有成员</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYSCORE myzset 0 3 # 移除score在 [0,3]的成员</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># testset=&gt; &#123;abc,add,apple,amaze,back,java,redis&#125; score均为0</span><br><span class="line"># myzset=&gt; &#123;(m1,1),(m2,2),(m3,3),(m4,4),(m7,7),(m9,9)&#125;</span><br><span class="line">----------------ZREVRANGE--ZREVRANGEBYSCORE--ZREVRANGEBYLEX-----------</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE myzset 0 3 # 按score递减排序，然后按索引，返回结果的 0~3</span><br><span class="line">1) &quot;m9&quot;</span><br><span class="line">2) &quot;m7&quot;</span><br><span class="line">3) &quot;m4&quot;</span><br><span class="line">4) &quot;m3&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE myzset 2 4 # 返回排序结果的 索引的2~4</span><br><span class="line">1) &quot;m4&quot;</span><br><span class="line">2) &quot;m3&quot;</span><br><span class="line">3) &quot;m2&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYSCORE myzset 6 2 # 按score递减顺序 返回集合中分数在[2,6]之间的成员</span><br><span class="line">1) &quot;m4&quot;</span><br><span class="line">2) &quot;m3&quot;</span><br><span class="line">3) &quot;m2&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYLEX testset [java (add # 按字典倒序 返回集合中(add,java]字典区间的成员</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;back&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">4) &quot;amaze&quot;</span><br><span class="line"></span><br><span class="line">-------------------------ZREVRANK------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK myzset m7 # 按score递减顺序，返回成员m7索引</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK myzset m2</span><br><span class="line">(integer) 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># mathscore=&gt;&#123;(xm,90),(xh,95),(xg,87)&#125; 小明、小红、小刚的数学成绩</span><br><span class="line"># enscore=&gt;&#123;(xm,70),(xh,93),(xg,90)&#125; 小明、小红、小刚的英语成绩</span><br><span class="line">-------------------ZINTERSTORE--ZUNIONSTORE-----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZINTERSTORE sumscore 2 mathscore enscore # 将mathscore enscore进行合并 结果存放到sumscore</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE sumscore 0 -1 withscores # 合并后的score是之前集合中所有score的和</span><br><span class="line">1) &quot;xm&quot;</span><br><span class="line">2) &quot;160&quot;</span><br><span class="line">3) &quot;xg&quot;</span><br><span class="line">4) &quot;177&quot;</span><br><span class="line">5) &quot;xh&quot;</span><br><span class="line">6) &quot;188&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ZUNIONSTORE lowestscore 2 mathscore enscore AGGREGATE MIN # 取两个集合的成员score最小值作为结果的</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE lowestscore 0 -1 withscores</span><br><span class="line">1) &quot;xm&quot;</span><br><span class="line">2) &quot;70&quot;</span><br><span class="line">3) &quot;xg&quot;</span><br><span class="line">4) &quot;87&quot;</span><br><span class="line">5) &quot;xh&quot;</span><br><span class="line">6) &quot;93&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h4><ul>
<li>set排序存储班级成绩表。工资表排序</li>
<li>普通消息，1.重要消息 2.带权重进行判断</li>
<li>排行榜应用实现，取TOP N测试</li>
</ul>
<h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它<strong>等价于Java的数据结构Map&lt;String, Double&gt;<strong>，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，</strong>内部的元素会按照权重score进行排序</strong>，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p>（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值</p>
<p>（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><blockquote>
<p>Redis的hash是一个string类型的field和value的映射表，hash特别适合用于存储对象</p>
<p>set就是一种简化的hash，只变动key，而value使用默认值填充。可以将一个hash表作为一个对象存储，表中存放对象的信息</p>
</blockquote>
<h4 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h4><p><img src="/2022/05/21/redis/1653270547078.png" alt="1653270547078" loading="lazy"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">------------------------HSET--HMSET--HSETNX----------------</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx name sakura # 将studentx哈希表作为一个对象，设置name为sakura</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx name gyc # 重复设置field进行覆盖，并返回0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx age 20 # 设置studentx的age为20</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HMSET studentx sex 1 tel 15623667886 # 设置sex为1，tel为15623667886</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HSETNX studentx name gyc # HSETNX 设置已存在的field</span><br><span class="line">(integer) 0 # 失败</span><br><span class="line">127.0.0.1:6379&gt; HSETNX studentx email 12345@qq.com</span><br><span class="line">(integer) 1 # 成功</span><br><span class="line"></span><br><span class="line">----------------------HEXISTS--------------------------------</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS studentx name # name字段在studentx中是否存在</span><br><span class="line">(integer) 1 # 存在</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS studentx addr</span><br><span class="line">(integer) 0 # 不存在</span><br><span class="line"></span><br><span class="line">-------------------HGET--HMGET--HGETALL-----------</span><br><span class="line">127.0.0.1:6379&gt; HGET studentx name # 获取studentx中name字段的value</span><br><span class="line">&quot;gyc&quot;</span><br><span class="line">127.0.0.1:6379&gt; HMGET studentx name age tel # 获取studentx中name、age、tel字段的value</span><br><span class="line">1) &quot;gyc&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;15623667886&quot;</span><br><span class="line">127.0.0.1:6379&gt; HGETALL studentx # 获取studentx中所有的field及其value</span><br><span class="line"> 1) &quot;name&quot;</span><br><span class="line"> 2) &quot;gyc&quot;</span><br><span class="line"> 3) &quot;age&quot;</span><br><span class="line"> 4) &quot;20&quot;</span><br><span class="line"> 5) &quot;sex&quot;</span><br><span class="line"> 6) &quot;1&quot;</span><br><span class="line"> 7) &quot;tel&quot;</span><br><span class="line"> 8) &quot;15623667886&quot;</span><br><span class="line"> 9) &quot;email&quot;</span><br><span class="line">10) &quot;12345@qq.com&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------HKEYS--HLEN--HVALS--------------</span><br><span class="line">127.0.0.1:6379&gt; HKEYS studentx # 查看studentx中所有的field</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;age&quot;</span><br><span class="line">3) &quot;sex&quot;</span><br><span class="line">4) &quot;tel&quot;</span><br><span class="line">5) &quot;email&quot;</span><br><span class="line">127.0.0.1:6379&gt; HLEN studentx # 查看studentx中的字段数量</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; HVALS studentx # 查看studentx中所有的value</span><br><span class="line">1) &quot;gyc&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;1&quot;</span><br><span class="line">4) &quot;15623667886&quot;</span><br><span class="line">5) &quot;12345@qq.com&quot;</span><br><span class="line"></span><br><span class="line">-------------------------HDEL--------------------------</span><br><span class="line">127.0.0.1:6379&gt; HDEL studentx sex tel # 删除studentx 中的sex、tel字段</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; HKEYS studentx</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;age&quot;</span><br><span class="line">3) &quot;email&quot;</span><br><span class="line"></span><br><span class="line">-------------HINCRBY--HINCRBYFLOAT------------------------</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY studentx age 1 # studentx的age字段数值+1</span><br><span class="line">(integer) 21</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY studentx name 1 # 非整数字型字段不可用</span><br><span class="line">(error) ERR hash value is not an integer</span><br><span class="line">127.0.0.1:6379&gt; HINCRBYFLOAT studentx weight 0.6 # weight字段增加0.6</span><br><span class="line">&quot;90.8&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Hash变更的数据user name age，其是用户信息之类的，经常变更的信息 Hash更适合对象的存储，String更加适合字符串存储</p>
<h2 id="发布和订阅"><a href="#发布和订阅" class="headerlink" title="发布和订阅"></a>发布和订阅</h2><h3 id="什么是发布和订阅"><a href="#什么是发布和订阅" class="headerlink" title="什么是发布和订阅"></a>什么是发布和订阅</h3><p>Redis发布订阅(pub/sub)是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息</p>
<p>Redis客户端可以订阅任意数量的频道</p>
<h3 id="常用命令-5"><a href="#常用命令-5" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="/2022/05/21/redis/1653355587934.png" alt="1653355587934" loading="lazy"></p>
<h3 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h3><p>1.客户端可以订阅频道如下图<img src="/2022/05/21/redis/1653297992994.png" alt="1653297992994" loading="lazy"></p>
<p>2.当给这个频道发布消息后，消息就会发送给订阅的客户端<img src="/2022/05/21/redis/1653298035859.png" alt="1653298035859" loading="lazy"></p>
<h3 id="实现发布订阅命令"><a href="#实现发布订阅命令" class="headerlink" title="实现发布订阅命令"></a>实现发布订阅命令</h3><p>1.打开一个客户端订阅channel1<img src="/2022/05/21/redis/1653298071630.png" alt="1653298071630" loading="lazy"></p>
<p>2.打开另一个客户端，给channel1发布消息hello<img src="/2022/05/21/redis/1653298103661.png" alt="1653298103661" loading="lazy"></p>
<p>返回的1是订阅者数量</p>
<p>3.打开第一个客户端可以看到发送的消息<img src="/2022/05/21/redis/1653298159750.png" alt="1653298159750" loading="lazy"></p>
<p><strong>注意：</strong>发布的消息没有持久化。如果在订阅的客户端收不到hello，只能收到订阅后发布的消息</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。<img src="/2022/05/21/redis/1653355774784.png" alt="1653355774784" loading="lazy"></p>
<p>客户端订阅，就被连接到对应频道的链表尾部，退订则就是从链表中删除</p>
<p><strong>缺点</strong><br>如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。<br>这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。<br><strong>应用</strong><br>消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现）<br>多人在线聊天室。</p>
<h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><h3 id="Geospatial（地理位置）"><a href="#Geospatial（地理位置）" class="headerlink" title="Geospatial（地理位置）"></a>Geospatial（地理位置）</h3><blockquote>
<p>使用经纬度定位地理坐标并用一个有序集合zset保存，所以zset命令也可以用</p>
</blockquote>
<h4 id="常用命令-6"><a href="#常用命令-6" class="headerlink" title="常用命令"></a>常用命令</h4><p><img src="/2022/05/21/redis/1653271418146.png" alt="1653271418146" loading="lazy"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">添加地理位置</span><br><span class="line">goeadd key longitude latitude member</span><br><span class="line">geoadd china:city 121.47 31.23 shanghai</span><br><span class="line"></span><br><span class="line">获取指定地区的坐标值</span><br><span class="line">geopos key member</span><br><span class="line">geopos china:city shanghai</span><br><span class="line"></span><br><span class="line">获取两个位置之间的直线距离</span><br><span class="line">geodist key member1 member2 (m km ft mi)</span><br><span class="line"></span><br><span class="line">以给定的经纬度为中心，找出某一半径内的元素</span><br><span class="line">georadius key longitude lattitude radius (m km ft mi)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>有效经纬度：</p>
<ul>
<li>有效经度从-180到180度</li>
<li>有效纬度从-85.05112878到85.0512878度</li>
</ul>
</blockquote>
<p>指定的单位的参数unit必须是以下单位的其中一个：</p>
<ul>
<li>m：米</li>
<li>km：千米</li>
<li>mi：英里</li>
<li>ft：英尺</li>
</ul>
<p><strong>关于GEORADIUS的参数</strong></p>
<p>通过georadius可以完成附近的人功能</p>
<p>withcord：带上坐标；withdist：带上举例，单位与半径单位相同</p>
<p>COUNT n：只显示前n个（按距离递增排序）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">----------------georadius---------------------</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 120 30 500 km withcoord withdist # 查询经纬度(120,30)坐标500km半径内的成员</span><br><span class="line">1) 1) &quot;hangzhou&quot;</span><br><span class="line">   2) &quot;29.4151&quot;</span><br><span class="line">   3) 1) &quot;120.20000249147415&quot;</span><br><span class="line">      2) &quot;30.199999888333501&quot;</span><br><span class="line">2) 1) &quot;shanghai&quot;</span><br><span class="line">   2) &quot;205.3611&quot;</span><br><span class="line">   3) 1) &quot;121.40000134706497&quot;</span><br><span class="line">      2) &quot;31.400000253193539&quot;</span><br><span class="line">     </span><br><span class="line">------------geohash---------------------------</span><br><span class="line">127.0.0.1:6379&gt; geohash china:city yichang shanghai # 获取成员经纬坐标的geohash表示</span><br><span class="line">1) &quot;wmrjwbr5250&quot;</span><br><span class="line">2) &quot;wtw6ds0y300&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Hyperloglog（基数统计）"><a href="#Hyperloglog（基数统计）" class="headerlink" title="Hyperloglog（基数统计）"></a>Hyperloglog（基数统计）</h3><blockquote>
<p>是用来做基数统计的算法，Hyperloglog的优点是，在输入元素的数量或者体积非常大时，计算基数所需的空间总是固定的，并且很小。</p>
<p>因为hyperloglog只会根据输入元素来计算基数，而<strong>不会存储元素本身</strong>，所以hyperloglog不能像集合那样，返回输入的各个元素，底层使用string数据类型</p>
<p>基数统计有一定的误差</p>
</blockquote>
<p><strong>什么是基数？</strong></p>
<p>数据集中不重复的元素个数</p>
<h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><p>网页访问量(uv)：一个用户多次访问，只算做一个</p>
<blockquote>
<p>传统实现，存储用户id，每次进行比较。当用户变多后这种方式及其浪费空间，而目的只是计数，hjyperloglog可以利用最小空间完成</p>
</blockquote>
<h4 id="常用命令-7"><a href="#常用命令-7" class="headerlink" title="常用命令"></a>常用命令<img src="/2022/05/21/redis/1653272674988.png" alt="1653272674988" loading="lazy"></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">----------PFADD--PFCOUNT---------------------</span><br><span class="line">127.0.0.1:6379&gt; PFADD myelemx a b c d e f g h i j k # 添加元素</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; type myelemx # hyperloglog底层使用String</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemx # 估算myelemx的基数</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; PFADD myelemy i j k z m c b v p q s</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemy</span><br><span class="line">(integer) 11</span><br><span class="line"></span><br><span class="line">----------------PFMERGE-----------------------</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE myelemz myelemx myelemy # 合并myelemx和myelemy 成为myelemz</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemz # 估算基数</span><br><span class="line">(integer) 17</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>如果允许容错，使用hyperloglog即可</strong></p>
<h3 id="BitMaps（位图）"><a href="#BitMaps（位图）" class="headerlink" title="BitMaps（位图）"></a>BitMaps（位图）</h3><blockquote>
<p>使用位存储，信息状态只有0和1</p>
<p> Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。 </p>
</blockquote>
<h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><p>签到统计、状态统计</p>
<h4 id="常用命令-8"><a href="#常用命令-8" class="headerlink" title="常用命令"></a>常用命令</h4><p><img src="/2022/05/21/redis/1653273030040.png" alt="1653273030040" loading="lazy"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">------------setbit--getbit--------------</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 0 1 # 设置sign的第0位为 1 </span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 1 # 设置sign的第2位为 1  不设置默认 是0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; type sign</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; getbit sign 2 # 获取第2位的数值</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 4 # 未设置默认是0</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">-----------bitcount----------------------------</span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT sign # 统计sign中为1的位数</span><br><span class="line">(integer) 4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote>
<p>Redis的单条命令保证原子性，但redis事务不能保证原子性</p>
</blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>Redis事务本质：一组命令的集合</p>
<p>事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。</p>
<ul>
<li>一次性</li>
<li>顺序性</li>
<li>排他性</li>
</ul>
</blockquote>
<p>redis事务没有隔离级别的概念</p>
<p>Redis单条命令是保证原子性的，但是事务不保证原子性</p>
<p>Redis事务的主要作用是串联多个命令防止别的命令插队</p>
<h3 id="事务操作过程"><a href="#事务操作过程" class="headerlink" title="事务操作过程"></a>事务操作过程</h3><ul>
<li>开启事务（multi）</li>
<li>命令入队</li>
<li>执行事务（exec）</li>
</ul>
<p>所有事务中的命令在加入时都没有被执行，直到提交时才会开始执行（exec）一次性完成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi # 开启事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1 # 命令入队</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2 # ..</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec # 事务执行</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) &quot;v1&quot;</span><br><span class="line">4) OK</span><br><span class="line">5) 1) &quot;k3&quot;</span><br><span class="line">   2) &quot;k2&quot;</span><br><span class="line">   3) &quot;k1&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>取消事务（discurd）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD # 放弃事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXEC </span><br><span class="line">(error) ERR EXEC without MULTI # 当前未开启事务</span><br><span class="line">127.0.0.1:6379&gt; get k1 # 被放弃事务中命令并未执行</span><br><span class="line">(nil)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="事务错误"><a href="#事务错误" class="headerlink" title="事务错误"></a>事务错误</h3><blockquote>
<p>代码语法错误（编译时异常）所有的命令都不执行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; error k1 # 这是一条语法错误命令</span><br><span class="line">(error) ERR unknown command `error`, with args beginning with: `k1`, # 会报错但是不影响后续命令入队 </span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors. # 执行报错</span><br><span class="line">127.0.0.1:6379&gt; get k1 </span><br><span class="line">(nil) # 其他命令并没有被执行</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>代码逻辑错误（运行时异常）其他命令都可以正常执行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCR k1 # 这条命令逻辑错误（对字符串进行增量）</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) (error) ERR value is not an integer or out of range # 运行时报错</span><br><span class="line">4) &quot;v2&quot; # 其他命令正常执行</span><br><span class="line"></span><br><span class="line"># 虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。</span><br><span class="line"># 所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p><strong>悲观锁：</strong></p>
<ul>
<li>很悲观，认为什么时候都会出现问题，无论做什么     都会加锁</li>
</ul>
<p><strong>乐观锁：</strong></p>
<ul>
<li>很乐观，认为什么时候都不会出现问题，所以不会上锁。更新数据的时候取判断一下，在此期间是否有人修改过这个数据</li>
<li>获取version</li>
<li>更新的时候比较version</li>
</ul>
<p>使用<strong>watch</strong>监控指定数据，相当于乐观锁功能</p>
<blockquote>
<p>正常执行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set money 100 # 设置余额:100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set use 0 # 支出使用:0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money # 监视money (上锁)</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY use 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec # 监视值没有被中途修改，事务正常执行</span><br><span class="line">1) (integer) 80</span><br><span class="line">2) (integer) 20</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试多线程修改值，使用watch可以当redis的乐观锁操作（相当于get version）</p>
</blockquote>
<p>启动另外一个客户端模拟插队线程。</p>
<p>线程1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money # money上锁</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY use 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; 	# 此时事务并没有执行</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>模拟线程插队，线程2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCRBY money 500 # 修改了线程一中监视的money</span><br><span class="line">(integer) 600</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回到线程1，执行事务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXEC # 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败</span><br><span class="line">(nil) # 没有结果，说明事务执行失败</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get money # 线程2 修改生效</span><br><span class="line">&quot;600&quot;</span><br><span class="line">127.0.0.1:6379&gt; get use # 线程1事务执行失败，数值没有被修改</span><br><span class="line">&quot;0&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>unwatch</strong></p>
<p>取消watch命令对所有key的监视</p>
<p>如果在执行watch命令之后，exec命令或discard命令先被执行了的话，那么就不需要再执行unwatch</p>
<h3 id="Redis事务三特性"><a href="#Redis事务三特性" class="headerlink" title="Redis事务三特性"></a>Redis事务三特性</h3><ul>
<li><p>单独隔离操作</p>
<p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
</li>
<li><p>没有隔离级别的概念</p>
<p>n队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</p>
</li>
<li><p>不保证原子性</p>
<p>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</p>
</li>
</ul>
<h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p> 使用Java来操作Redis，Jedis是Redis官方推荐使用的Java连接redis的客户端。 </p>
<p>1.导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入jredis的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--fastjson--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.70<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.编码测试</p>
<p>修改redis的配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/bin/myconfig/redis.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将只绑定本地注释</p>
<p>保护模式改为no</p>
<p>允许后台运行</p>
<p>3.开放端口6379</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=6379/tcp --permanet</span><br></pre></td></tr></table></figure>

<p>重启防火墙服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart firewalld.service</span><br></pre></td></tr></table></figure>

<p>阿里云服务器配置安全组</p>
<p>重启redis-server</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@AlibabaECS bin]# redis-server myconfig/redis.conf </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TestPing.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.xx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> jedis.ping();</span><br><span class="line">        System.out.println(response); <span class="comment">// PONG</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>事务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTX</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;39.99.xxx.xx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        jsonObject.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;kuangshen&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jsonObject.toJSONString();</span><br><span class="line">        <span class="comment">// jedis.watch(result)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            multi.set(<span class="string">&quot;user1&quot;</span>, result);</span><br><span class="line">            multi.set(<span class="string">&quot;user2&quot;</span>, result);</span><br><span class="line">            <span class="comment">// 执行事务</span></span><br><span class="line">            multi.exec();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">// 放弃事务</span></span><br><span class="line">            multi.discard();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user1&quot;</span>));</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user2&quot;</span>));</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h5 id="什么是RDB"><a href="#什么是RDB" class="headerlink" title="什么是RDB"></a>什么是RDB</h5><p>在指定时间间隔内，将内存中的数据集快照写入数据库，在恢复时，直接读取快照文件，进行数据恢复<img src="/2022/05/21/redis/1653275490810.png" alt="1653275490810" loading="lazy"></p>
<p>默认情况下，Redis将数据库快照保存在名为dump.rdb的二进制文件中。</p>
<h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>在进行RDB的时候，redis的主线程是不会做io操作的，主线程fork一个子线程来完成操作</p>
<p>1.Redis fork子线程，同时拥有父进程和子进程</p>
<p>2.子进程将数据集写入到一个临时rdb文件</p>
<p>3.当子进程完成对新rdb文件的写入时，redis用新的rdb文件替换就rdb文件，并删除旧的rdb文件</p>
<p> 这种工作方式使得 Redis 可以<strong>从写时复制（</strong>copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。) <img src="/2022/05/21/redis/1653275944665.png" alt="1653275944665" loading="lazy"></p>
<p><strong>关于fork进程</strong></p>
<p>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值和原进程一致，但是是一个全新的进程。并作为原进程的子进程</p>
<ul>
<li>在Linux中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，处于效率，Linux引入了“写时复制技术”</li>
<li>一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</li>
</ul>
<p><img src="/2022/05/21/redis/1653294337487.png" alt="1653294337487" loading="lazy"></p>
<h5 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h5><p>1.save的规则满足的情况下，会自动触发rdb原则</p>
<p>2.执行flushall命令，也会触发rdb原则</p>
<p>3.退出redis，也会自动产生rdb文件</p>
<h5 id="bgsave与save"><a href="#bgsave与save" class="headerlink" title="bgsave与save"></a>bgsave与save</h5><p><strong>save</strong></p>
<p>使用<strong>save</strong>命令，会立刻对当前内存中的数据进行持久化，但会阻塞，不再接收其他的操作</p>
<blockquote>
<p>由于save命令是同步命令，会占用redis主进程，若Redis数据非常多时，save命令执行速度会非常慢，阻塞所有客户端的请求</p>
</blockquote>
<p><img src="/2022/05/21/redis/1653294598612.png" alt="1653294598612" loading="lazy"></p>
<p><strong>触发持久化规则</strong></p>
<p>满足配置条件中的触发条件：</p>
<blockquote>
<p>可以通过配置文件对Redis配置，让它“n秒内数据集至少有m个改动”这一条件满足时，自动进行数据集的保存<img src="/2022/05/21/redis/1653294726249.png" alt="1653294726249" loading="lazy"></p>
</blockquote>
<p><img src="/2022/05/21/redis/1653294731554.png" alt="1653294731554" loading="lazy"></p>
<p><strong>bgsave</strong></p>
<p>bgsave是异步进行，进行持久化的时候，redis还可以响应客户端请求：<img src="/2022/05/21/redis/1653294841831.png" alt="1653294841831" loading="lazy"></p>
<p><strong>bgsave与save对比</strong></p>
<p><img src="/2022/05/21/redis/1653294885309.png" alt="1653294885309" loading="lazy"></p>
<h5 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h5><p><strong>优点</strong></p>
<ul>
<li>适合大规模数据恢复</li>
<li>对数据的完整性要求不高</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>需要一定时间间隔进行操作，如果redis意外宕机，最后一次修改的数据（最后一次持久化之后的修改）没有了</li>
<li>fork进程的时候，会占用一定的内存空间</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p><img src="/2022/05/21/redis/1653296931612.png" alt="1653296931612" loading="lazy"></p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h5 id="什么是AOF"><a href="#什么是AOF" class="headerlink" title="什么是AOF"></a>什么是AOF</h5><p>以日志形式记录每个写操作，将redis所执行的所有指令记录下来（读操作不记录），只需追加不可以改写文件</p>
<ul>
<li>redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</li>
</ul>
<h5 id="aof的配置"><a href="#aof的配置" class="headerlink" title="aof的配置"></a>aof的配置</h5><p><img src="/2022/05/21/redis/1653295245127.png" alt="1653295245127" loading="lazy"></p>
<p> 默认是不开启AOF，开启RDB<br>可以在redis.conf中配置文件名称，默认为 <code>appendonly.aof</code><br>AOF文件的保存路径，同RDB的路径一致 </p>
<p>插入其数据的时候，在日志里面会看到数据的添加<br>如果直接在日志添加一些无法识别的数据，启动redis会启动不了<br>可以通通过/usr/local/bin/redis-check-aof–fix appendonly.aof进行恢复<br>在当前目录下有redis-check-aof这个文件</p>
<h5 id="AOF持久化流程"><a href="#AOF持久化流程" class="headerlink" title="AOF持久化流程"></a>AOF持久化流程</h5><ul>
<li>客户端的请求写命令被append追加到AOF缓冲区内</li>
<li>AOF缓冲区根据AOF持久化策略（always、everysec、no）将操作sync同步到磁盘的AOF文件</li>
<li>AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量</li>
<li>Rqedis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的</li>
</ul>
<p><img src="/2022/05/21/redis/1653295577875.png" alt="1653295577875" loading="lazy">45</p>
<h5 id="AOF启动与修复"><a href="#AOF启动与修复" class="headerlink" title="AOF启动与修复"></a>AOF启动与修复</h5><ul>
<li><p>AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</p>
</li>
<li><p>正常恢复</p>
<ul>
<li>修改默认的appendonly no，改为yes</li>
<li>将有数据的aof文件复制一份保存到对应目录(查看目录，config get dir)</li>
<li>恢复：重启redis然后再次加载</li>
</ul>
</li>
<li><p>异常恢复</p>
<ul>
<li>修改默认的appendonly no，改为 yes</li>
<li>如遇到AOF文件损坏，通过/usr/loval.bin/redis-check-aof–fix appendonly.aof进行恢复</li>
<li>备份被写坏的AOF文件</li>
<li>恢复：重启redis，然后再次加载</li>
</ul>
</li>
</ul>
<h5 id="AOF同步频率设置"><a href="#AOF同步频率设置" class="headerlink" title="AOF同步频率设置"></a>AOF同步频率设置</h5><p><strong>appendfsync always</strong></p>
<p>始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好</p>
<p><strong>appendfsync everysec</strong></p>
<p>每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p>
<p><strong>appendfsync no</strong></p>
<p>redis不主动进行同步，把同步时机交给操作系统。</p>
<h5 id="Rewrite压缩"><a href="#Rewrite压缩" class="headerlink" title="Rewrite压缩"></a>Rewrite压缩</h5><blockquote>
<p>是什么</p>
</blockquote>
<p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</p>
<blockquote>
<p>重写原理，如何实现重写</p>
</blockquote>
<p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，实际上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。</p>
<ul>
<li><p>no-appendfsync-on-rewrite：</p>
<p>如果 <strong>no-appendfsync-on-rewrite=yes</strong> ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</p>
<p>如果 <strong>no-appendfsync-on-rewrite=no</strong>,  还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</p>
</li>
</ul>
<blockquote>
<p>什么时候重写？触发？</p>
</blockquote>
<p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的<strong>一倍且文件大于64M</strong>时触发</p>
<p>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。</p>
<p>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）</p>
<p>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。</p>
<p>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB</p>
<p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,</p>
<p>如果Redis的<strong>AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。</strong> </p>
<blockquote>
<p>重写流程</p>
</blockquote>
<p>（1）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有则等待该命令结束后再继续执行</p>
<p>（2）主进程fork出子进程执行重写操作，保证主进程不会阻塞</p>
<p>（3）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证aof文件完整和新aof文件生成期间新的数据修改动作不会丢失</p>
<p>（4）1.子进程写完新的aof文件后，向主进程发信号，父进程更新统计信息</p>
<p>​          2.主进程把aof_rewrite_buf中的数据写入新的aof文件</p>
<p>（5）使用新的aof文件覆盖旧的aof文件，完成aof文件重写</p>
<p><img src="/2022/05/21/redis/1653296701954.png" alt="1653296701954" loading="lazy"></p>
<h5 id="优点与缺点-1"><a href="#优点与缺点-1" class="headerlink" title="优点与缺点"></a>优点与缺点</h5><p><strong>优点</strong></p>
<p><img src="/2022/05/21/redis/1653296818155.png" alt="1653296818155" loading="lazy"></p>
<ul>
<li>备份机制更稳健，丢失数据概率更低</li>
<li>可读的日志文本，通过操作AOF稳健，可以处理误操作</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>比起rdb占用更多的磁盘空间、</li>
<li>恢复备份速度要慢</li>
<li>每次读写都同步的话，有一定性能压力</li>
<li>存在个别bug，造成恢复不能</li>
</ul>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p><img src="/2022/05/21/redis/1653296912552.png" alt="1653296912552" loading="lazy"></p>
<h3 id="RDB与AOF选择"><a href="#RDB与AOF选择" class="headerlink" title="RDB与AOF选择"></a>RDB与AOF选择</h3><blockquote>
<p>两者对比</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>丢数据</td>
<td>根据决策决定</td>
</tr>
</tbody></table>
<blockquote>
<p>应该用哪个</p>
</blockquote>
<p>如果对数据不敏感，可以选用RDB</p>
<p>不建议单独使用AOF，因为可能会出现bug</p>
<p>如果只是单纯做内存缓存，可以都不用</p>
<p><strong>官网建议</strong></p>
<ul>
<li><p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</p>
</li>
<li><p>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾. </p>
</li>
<li><p>Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</p>
</li>
<li><p>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</p>
</li>
<li><p>同时开启两种持久化方式</p>
</li>
<li><p>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</p>
</li>
<li><p>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ </p>
</li>
<li><p>建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</p>
</li>
<li><p>性能建议</p>
<p>因为RDB文件只用做后背用途，建议只在<strong>Slave上持久化RDB文件</strong>，而且只要15分钟备份一次就够了，只保留<strong>save 900 1</strong>这条规则</p>
<p>如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。</p>
<p>代价,一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。</p>
<p>只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。</p>
<p>默认超过原大小100%大小时重写可以改到适当的数值。</p>
</li>
</ul>
<h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><h3 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h3><p> 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， <strong>数据的复制是单向的！只能由主节点复制到从节点</strong>（主节点以写为主、从节点以读为主）。</p>
<p>默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li>
<li>故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。</li>
<li>高可用基石：主从复制还是哨兵和集群能够实施的基础。</li>
</ul>
<p><img src="/2022/05/21/redis/1653356212657.png" alt="1653356212657" loading="lazy"></p>
<blockquote>
<p>为什么使用集群？</p>
</blockquote>
<p>1.单台服务器难以负载大量请求</p>
<p>2.单台服务器故障率高，系统崩坏概率大</p>
<p>3.单台服务器内存容量有限</p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>查看当前库的信息：info replication</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master # 角色</span><br><span class="line">connected_slaves:0 # 从机数量</span><br><span class="line">master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcff</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>既然需要启动多个服务，就需要多个配置文件，每个配置文件对应修改以下内容：</p>
<ul>
<li>端口号</li>
<li>pid文件名</li>
<li>日志文件名</li>
<li>rdb文件名</li>
</ul>
<p><strong>启动单机多服务器集群</strong>：<img src="/2022/05/21/redis/1653356578925.png" alt="1653356578925" loading="lazy"></p>
<h3 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h3><p>拷贝多个redis.conf文件include(写绝对路径)</p>
<p>开启daemonize yes</p>
<p>Pid文件名字pidfile</p>
<p>指定端口port</p>
<p>Log文件名字</p>
<p>dump.rdb名字dbfilename</p>
<p>Appendonly 关掉或者换名字</p>
<p><strong>新建redis6379.conf，填写以下内容：</strong></p>
<p><img src="/2022/05/21/redis/1653356777962.png" alt="1653356777962" loading="lazy"></p>
<p><strong>新建redis6380.conf，填写以下内容：</strong></p>
<p><img src="/2022/05/21/redis/1653356803978.png" alt="1653356803978" loading="lazy"></p>
<p><strong>新建redis6381.conf，填写以下内容：</strong></p>
<p><img src="/2022/05/21/redis/1653356820075.png" alt="1653356820075" loading="lazy"></p>
<p>slave-priority 10</p>
<p>设置从机的优先级，值越小，优先级越改，用于选举主机时使用。默认100</p>
<p><strong>启动三台redis服务器</strong></p>
<p><img src="/2022/05/21/redis/1653357332228.png" alt="1653357332228" loading="lazy"></p>
<p>检查是否启动</p>
<p><img src="/2022/05/21/redis/1653357345406.png" alt="1653357345406" loading="lazy"></p>
<p><strong>查看三台主机运行情况</strong></p>
<p>info erplication</p>
<p>打印主从复制信息<img src="/2022/05/21/redis/1653357487556.png" alt="1653357487556" loading="lazy"></p>
<p><strong>配从(库)不配主(库)</strong></p>
<p>slaveof <ip> <port></port></ip></p>
<p>称为某个实例的从服务器</p>
<p>1.在6380，6381上执行：slaveof 127.0.0.1 6379<img src="/2022/05/21/redis/1653358942835.png" alt="1653358942835" loading="lazy"></p>
<p>2.在主机上写，在从机上读数据</p>
<p>在从机上写数据报错<img src="/2022/05/21/redis/1653359016114.png" alt="1653359016114" loading="lazy"></p>
<p>3.主机挂掉，重启即可，一切如初</p>
<p>4.从机重启需要重设：slaveof 127.0.0.1 6379</p>
<p>可以将配置增加到文件中。永久生效<img src="/2022/05/21/redis/1653359092761.png" alt="1653359092761" loading="lazy"></p>
<h3 id="常用三招"><a href="#常用三招" class="headerlink" title="常用三招"></a>常用三招</h3><h4 id="1-一主二仆"><a href="#1-一主二仆" class="headerlink" title="1.一主二仆"></a>1.一主二仆</h4><p>切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1,k2,k3是否也可以复制？</p>
<p>从机是否可以写？set可否？ </p>
<p>主机shutdown后情况如何？从机是上位还是原地待命？</p>
<p>主机又回来了后，主机新增记录，从机还能否顺利复制？ </p>
<p>其中一台从机down后情况如何？依照原有它能跟上大部队吗？<img src="/2022/05/21/redis/1653359216384.png" alt="1653359216384" loading="lazy"></p>
<h4 id="2-薪火相传"><a href="#2-薪火相传" class="headerlink" title="2.薪火相传"></a>2.薪火相传</h4><p>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。</p>
<p>用 slaveof  <ip><port></port></ip></p>
<p>中途变更转向:会清除之前的数据，重新建立拷贝最新的</p>
<p>风险是一旦某个slave宕机，后面的slave都没法备份</p>
<p>主机挂了，从机还是从机，无法写数据了</p>
<h4 id="3-反客为主"><a href="#3-反客为主" class="headerlink" title="3.反客为主"></a>3.反客为主</h4><p>当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。</p>
<p>用 slaveof  no one  将从机变为主机。</p>
<p><img src="/2022/05/21/redis/1653359345948.png" alt="1653359345948" loading="lazy"></p>
<h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3><ul>
<li><p>Slave启动成功连接到master后会发送一个sync命令</p>
</li>
<li><p>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</p>
</li>
<li><p>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
</li>
<li><p>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</p>
</li>
<li><p>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</p>
</li>
</ul>
<h3 id="哨兵模式（sentinel）"><a href="#哨兵模式（sentinel）" class="headerlink" title="哨兵模式（sentinel）"></a>哨兵模式（sentinel）</h3><p><strong>反客为主自动版</strong>，能够后台监控主机是否故障，如果故障了根据投票自动将从库转换为主库<img src="/2022/05/21/redis/1653361444997.png" alt="1653361444997" loading="lazy"></p>
<p>哨兵的作用</p>
<ul>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li>
<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让它们切换主机。</li>
</ul>
<p>其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例<img src="/2022/05/21/redis/1653361752396.png" alt="1653361752396" loading="lazy"></p>
<p>一个哨兵进程对Redis服务器监控，可能出现问题，为此，可以使用多个哨兵进行监控。各个哨兵之间进行监控，这样就形成了多哨兵模式</p>
<p><img src="/2022/05/21/redis/1653361854255.png" alt="1653361854255" loading="lazy"></p>
<p>假设主服务器宕机，哨兵1先检测到这个结果，系统不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。<br>切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p>
<h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><p>1.调整为一主二仆模式，6379带着6380、6381<img src="/2022/05/21/redis/1653361516881.png" alt="1653361516881" loading="lazy"></p>
<p>配置哨兵配置文件 sentinel.conf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sentinel monitor 被监控的名称 host port 1</span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 后面的这个数字1，至少有多少个哨兵同意才迁移 </p>
<p>2.启动哨兵</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen bin]# redis-sentinel kconfig/sentinel.conf</span><br><span class="line">26607:X 31 Mar 2020 21:13:10.027 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">26607:X 31 Mar 2020 21:13:10.027 # Redis version=5.0.8, bits=64,</span><br><span class="line">commit=00000000, modified=0, pid=26607, just started</span><br><span class="line">26607:X 31 Mar 2020 21:13:10.027 # Configuration loaded</span><br><span class="line">_._</span><br><span class="line">_.-``__ &#x27;&#x27;-._</span><br><span class="line">_.-`` `. `_. &#x27;&#x27;-._ Redis 5.0.8 (00000000/0) 64 bit</span><br><span class="line">.-`` .-```. ```\/ _.,_ &#x27;&#x27;-._</span><br><span class="line">( &#x27; , .-` | `, ) Running in sentinel mode</span><br><span class="line">|`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;| Port: 26379</span><br><span class="line">| `-._ `._ / _.-&#x27; | PID: 26607</span><br><span class="line">`-._ `-._ `-./ _.-&#x27; _.-&#x27;</span><br><span class="line">|`-._`-._ `-.__.-&#x27; _.-&#x27;_.-&#x27;|</span><br><span class="line">| `-._`-._ _.-&#x27;_.-&#x27; | http://redis.io</span><br><span class="line"></span><br><span class="line">26607:X 31 Mar 2020 21:13:10.029 # WARNING: The TCP backlog setting of 511</span><br><span class="line">cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value</span><br><span class="line">of 128.</span><br><span class="line">26607:X 31 Mar 2020 21:13:10.031 # Sentinel ID is</span><br><span class="line">4c780da7e22d2aebe3bc20c333746f202ce72996</span><br><span class="line">26607:X 31 Mar 2020 21:13:10.031 # +monitor master myredis 127.0.0.1 6379 quorum</span><br><span class="line">1</span><br><span class="line">26607:X 31 Mar 2020 21:13:10.031 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @</span><br><span class="line">myredis 127.0.0.1 6379</span><br><span class="line">26607:X 31 Mar 2020 21:13:10.033 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @</span><br><span class="line">myredis 127.0.0.1 6379</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.当主机挂掉后，从机选举中产生新的主机</p>
<p>哪个从机会被选举为主机呢？根据优先级别：slave-priority </p>
<p>原主机重启后会变为从机。 <img src="/2022/05/21/redis/20210125225350321.png" alt="在这里插入图片描述" loading="lazy"> </p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：<br>1、哨兵集群，基于主从复制模式，所有的主从配置优点，它全有<br>2、 主从可以切换，故障可以转移，系统的可用性就会更好<br>3、哨兵模式就是主从模式的升级，手动到自动，更加健壮！</p>
<p>缺点：<br>1、Redis 不好啊在线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦！<br>2、实现哨兵模式的配置其实是很麻烦的，里面有很多选择！</p>
<h4 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h4><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>
<h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复<img src="/2022/05/21/redis/1653362562517.png" alt="1653362562517" loading="lazy"></h3><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>容量不够，如何进行扩容？</p>
<p>并发写操作，如何分摊？</p>
<p>主从模式、薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p>
<p>之前通过代理主机解决，但redis3.0中提供了<strong>无中心化集群</strong>配置</p>
<h3 id="什么是集群"><a href="#什么是集群" class="headerlink" title="什么是集群"></a>什么是集群</h3><p>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。</p>
<p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>
<h3 id="删除持久化数据"><a href="#删除持久化数据" class="headerlink" title="删除持久化数据"></a>删除持久化数据</h3><p>将rdb，aof文件都删除</p>
<h3 id="制作6个实例"><a href="#制作6个实例" class="headerlink" title="制作6个实例"></a>制作6个实例</h3><p>6379，6380，6381，6389，6390，6391</p>
<h4 id="配置基本信息"><a href="#配置基本信息" class="headerlink" title="配置基本信息"></a>配置基本信息</h4><p>开启daemonize yes</p>
<p>Pid文件名字</p>
<p>指定端口</p>
<p>Log文件名字</p>
<p>Dump.rdb名字</p>
<p>Appendonly 关掉或者换名字</p>
<h4 id="redis-cluster配置修改"><a href="#redis-cluster配置修改" class="headerlink" title="redis cluster配置修改"></a>redis cluster配置修改</h4><p>cluster-enabled yes  打开集群模式</p>
<p>cluster-config-file nodes-6379.conf 设定节点配置文件名</p>
<p>cluster-node-timeout 15000  设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。<img src="/2022/05/21/redis/1653378879859.png" alt="1653378879859" loading="lazy"></p>
<h4 id="修改好redis6379-conf文件，拷贝多个"><a href="#修改好redis6379-conf文件，拷贝多个" class="headerlink" title="修改好redis6379.conf文件，拷贝多个"></a>修改好redis6379.conf文件，拷贝多个</h4><p><img src="/2022/05/21/redis/1653378907009.png" alt="1653378907009" loading="lazy"></p>
<h4 id="使用查找替换修改另外五个文件"><a href="#使用查找替换修改另外五个文件" class="headerlink" title="使用查找替换修改另外五个文件"></a>使用查找替换修改另外五个文件</h4><p>例如：:%s/6379/6380  </p>
<h4 id="启动六个redis服务"><a href="#启动六个redis服务" class="headerlink" title="启动六个redis服务"></a>启动六个redis服务</h4><p><img src="/2022/05/21/redis/1653378969679.png" alt="1653378969679" loading="lazy"></p>
<h4 id="将六个节点合成一个集群"><a href="#将六个节点合成一个集群" class="headerlink" title="将六个节点合成一个集群"></a>将六个节点合成一个集群</h4><p>组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。<img src="/2022/05/21/redis/1653378996005.png" alt="1653378996005" loading="lazy"></p>
<ul>
<li>合体</li>
</ul>
<p>cd  /opt/redis-6.2.1/src</p>
<p>此处不要用127.0.0.1， 请用真实IP地址</p>
<p>–replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。</p>
<p><img src="/2022/05/21/redis/wps1.png" alt="img" loading="lazy"> </p>
<p><img src="/2022/05/21/redis/wps2.png" alt="img" loading="lazy"> </p>
<p>l 普通方式登录</p>
<p>可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。</p>
<p><img src="/2022/05/21/redis/wps3.png" alt="img" loading="lazy"> </p>
<h4 id="c-采用集群策略连接，设置数据会自动切换到相应的写主机"><a href="#c-采用集群策略连接，设置数据会自动切换到相应的写主机" class="headerlink" title="*-c 采用集群策略连接，设置数据会自动切换到相应的写主机*"></a><em><strong>*-c 采用集群策略连接，设置数据会自动切换到相应的写主机*</strong></em></h4><p><img src="/2022/05/21/redis/wps4.png" alt="img" loading="lazy"> </p>
<p><em><strong>*通过 cluster nodes 命令查看集群信息*</strong></em></p>
<p><img src="/2022/05/21/redis/wps5.png" alt="img" loading="lazy"> </p>
<h4 id="redis-cluster-如何分配这六个节点"><a href="#redis-cluster-如何分配这六个节点" class="headerlink" title="*redis cluster 如何分配这六个节点?*"></a><em><strong>*redis cluster 如何分配这六个节点?*</strong></em></h4><p>一个集群至少要有三个主节点。</p>
<p>选项 –cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。</p>
<p>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</p>
<h4 id="什么是slots"><a href="#什么是slots" class="headerlink" title="什么是slots"></a><strong>什么是slots</strong></h4><p><em><strong>*[OK] All nodes agree about slots configuration.*</strong></em></p>
<p><em><strong>*&gt;&gt;&gt; Check for open slots…*</strong></em></p>
<p><em><strong>*&gt;&gt;&gt; Check slots coverage…*</strong></em></p>
<p><em><strong>*[OK] All*</strong></em> <em><strong>*16384*</strong></em> <em><strong>*slots covered.*</strong></em></p>
<p>一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个， </p>
<p>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p>
<p>集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中：</p>
<p>节点 A 负责处理 0 号至 5460 号插槽。</p>
<p>节点 B 负责处理 5461 号至 10922 号插槽。</p>
<p>节点 C 负责处理 10923 号至 16383 号插槽。</p>
<h4 id="在集群中录入值"><a href="#在集群中录入值" class="headerlink" title="*在集群中录入值*"></a><em><strong>*在集群中录入值*</strong></em></h4><p>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。</p>
<p>redis-cli客户端提供了 –c 参数实现自动重定向。</p>
<p>如 redis-cli  -c –p 6379 登入后，再录入、查询键值对可以自动重定向。</p>
<p>不在一个slot下的键值，是不能使用mget,mset等多键操作。</p>
<p><img src="/2022/05/21/redis/wps6.png" alt="img" loading="lazy"> </p>
<p>可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。</p>
<p><img src="/2022/05/21/redis/wps7.png" alt="img" loading="lazy"> </p>
<h4 id="查询集群中的值"><a href="#查询集群中的值" class="headerlink" title="*查询集群中的值*"></a><em><strong>*查询集群中的值*</strong></em></h4><p>CLUSTER GETKEYSINSLOT <slot><count> 返回 count 个 slot 槽中的键。</count></slot></p>
<p><img src="/2022/05/21/redis/wps8.png" alt="img" loading="lazy"> </p>
<h4 id="故障恢复-1"><a href="#故障恢复-1" class="headerlink" title="*故障恢复*"></a><em><strong>*故障恢复*</strong></em></h4><p>如果主节点下线？从节点能否自动升为主节点？注意：<em><strong>*15秒超时*</strong></em></p>
<p><img src="/2022/05/21/redis/wps9.png" alt="img" loading="lazy"> </p>
<p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p>
<p><img src="/2022/05/21/redis/wps10.png" alt="img" loading="lazy"> </p>
<p>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?</p>
<p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉</p>
<p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。</p>
<p>redis.conf中的参数  cluster-require-full-coverage</p>
<h3 id="Redis集群的好处与不足"><a href="#Redis集群的好处与不足" class="headerlink" title="Redis集群的好处与不足"></a>Redis集群的好处与不足</h3><p>好处： 实现扩容 分摊压力 务中心配置相对简单</p>
<p>不足：多建操作不支持 多建的Redis事务不支持。lua脚本不支持 由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</p>
<h3 id="Redis应用问题"><a href="#Redis应用问题" class="headerlink" title="Redis应用问题"></a>Redis应用问题</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。<img src="/2022/05/21/redis/1653379491071.png" alt="1653379491071" loading="lazy"></p>
<h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义</p>
<p>（1） <strong>对空值缓存：</strong>如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</p>
<blockquote>
<p>​            这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间</p>
<p>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p>
</blockquote>
<p><img src="/2022/05/21/redis/1653379760933.png" alt="1653379760933" loading="lazy"></p>
<p>（2） <strong>设置可访问的名单（白名单）：</strong></p>
<p>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p>
<p>（3） <strong>采用布隆过滤器</strong>：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。</p>
<p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)</p>
<p>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</p>
<p><img src="/2022/05/21/redis/1653379771259.png" alt="1653379771259" loading="lazy"></p>
<p>（4） <strong>进行实时监控：</strong>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</p>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p> 相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。</p>
<p> 比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。</p>
<h5 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h5><p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p>
<p>解决问题：</p>
<p><strong>（1）设置热点数据永不过期：</strong> 这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。 </p>
<p><strong>（2）实时调整：</strong>现场监控哪些数据热门，实时调整key的过期时长</p>
<p><strong>（3）使用锁：</strong></p>
<p>（1） 就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</p>
<p>（2） 先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key</p>
<p>（3） 当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；</p>
<p>（4） 当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。<img src="/2022/05/21/redis/1653380028485.png" alt="1653380028485" loading="lazy"></p>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，缓存击穿则是某一个key</p>
<p><strong>正常访问</strong></p>
<p><img src="/2022/05/21/redis/1653380693916.png" alt="1653380693916" loading="lazy"></p>
<p><strong>缓存失效瞬间</strong></p>
<p><img src="/2022/05/21/redis/1653380710105.png" alt="1653380710105" loading="lazy"></p>
<h5 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h5><ul>
<li><p>redis高可用</p>
<p>搭建redis集群，将热定数据均匀分布在不同的redis库</p>
</li>
<li><p>限流降级</p>
<p>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。 比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。 </p>
</li>
<li><p>数据预热</p>
<p> 数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。</p>
</li>
<li><p>将缓存失效时间分开</p>
<p>比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
</li>
</ul>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/images/alipay.jpg"><img loading="lazy" src="/images/alipay.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/wechatpay.png"><img loading="lazy" src="/images/wechatpay.png" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>翔仔</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://example.com/2022/05/21/redis/" title="redis">http://example.com/2022/05/21/redis/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022/05/24/Redis-%E8%B7%B3%E8%B7%83%E8%A1%A8/" rel="prev" title="Redis-跳跃表"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">Redis-跳跃表</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2022/05/02/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8/" rel="next" title="哈希函数与哈希表"><span class="post-nav-text">哈希函数与哈希表</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2022 </span><span class="with-love" id="animate" title="云游君的赞助者们"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 翔仔</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.2</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.8.11</span></div><div class="live-time"><span>本博客已运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2022-04-10T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} 天 ${passHour} 小时 ${passMinute} 分 ${passSecond} 秒`;
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>