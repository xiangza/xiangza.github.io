<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="翔仔"><meta name="copyright" content="翔仔"><meta name="generator" content="Hexo 5.4.2"><meta name="theme" content="hexo-theme-yun"><title>Sysnchronized锁升级 | 翔仔的博客</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.2.4/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/@unocss/runtime/mini.global.js"></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"example.com","root":"/","title":"翔仔的小站","version":"1.8.11","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]},"vendors":{"darken":"https://cdn.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="Synchronized原理synchronized锁的底层原理，分为锁方法和锁代码块。分别利用monitorenter和monitorexit指令和由方法调用指令读取运行时常量池中方法的ACC_SYNCHRONIZED标志来实现。 理解java对象头和monitor 在jvm虚拟机中对象的存储分为三部分，对象头、实例数据、对其填充  实例数据：存放对象的所有属性信息，包括父类的属性信息，如果是数">
<meta property="og:type" content="article">
<meta property="og:title" content="Sysnchronized锁升级">
<meta property="og:url" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/index.html">
<meta property="og:site_name" content="翔仔的博客">
<meta property="og:description" content="Synchronized原理synchronized锁的底层原理，分为锁方法和锁代码块。分别利用monitorenter和monitorexit指令和由方法调用指令读取运行时常量池中方法的ACC_SYNCHRONIZED标志来实现。 理解java对象头和monitor 在jvm虚拟机中对象的存储分为三部分，对象头、实例数据、对其填充  实例数据：存放对象的所有属性信息，包括父类的属性信息，如果是数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/image-20220226164959223.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/1660555064015.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/1660555119807.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/1660557676506.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/20170604114223462.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/image-20220226164959223.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/11b5a74429f042d1b73121d2d34acf98.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/1657807202150.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/2018111713424283.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/e4a9527bc2e2421da4e68fc2b23bbda3.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/f308f5b84373429e8397de8cded9b5c0.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/57dbe9a2084f465485c6dc298d865526.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/4a6f258c2cd04a6cb534c892ede208f7.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/77047ccb305540cc83d04c0856803978.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/20190415130541918.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/dce7badac65d49ffa1f9e7d36e54dd8f-1657854826475.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/dce7badac65d49ffa1f9e7d36e54dd8f-1657854826475.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/0e1fe418fca84681a11ea8c708eaa5fa.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/1657849305777.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/study/blog/blog/source_posts/Sysnchronized锁升级/1661248852531.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/445efcc461cf4099953108589986d944.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/f180e8c5363442a8a207524ee589c4d3.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/89da391a7b7d49cbac3c814e84ebc86c.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/study/blog/blog/source_posts/Sysnchronized锁升级/java-thread-x-key-schronized-7.png">
<meta property="og:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/6c8febd362e56d6573991b5bf4eeed31.png">
<meta property="article:published_time" content="2022-07-14T13:26:37.000Z">
<meta property="article:modified_time" content="2022-08-23T10:00:55.884Z">
<meta property="article:author" content="翔仔">
<meta property="article:tag" content="synchronized">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/image-20220226164959223.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="翔仔"><img width="96" loading="lazy" src="/images/tx.jpg" alt="翔仔"><span class="site-author-status" title="不想上学">😭</span></a><div class="site-author-name"><a href="/about/">翔仔</a></div><span class="site-name">翔仔的博客</span><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="我的主页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">28</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">10</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">19</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&amp;uin=910426929&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/YunYouJun" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="985391895@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Synchronized%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">Synchronized原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3java%E5%AF%B9%E8%B1%A1%E5%A4%B4%E5%92%8Cmonitor"><span class="toc-number">1.1.</span> <span class="toc-text">理解java对象头和monitor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#monitor%EF%BC%88%E7%9B%91%E8%A7%86%E5%99%A8%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">monitor（监视器）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.2.</span> <span class="toc-text">同步代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">同步方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Synchronized%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">Synchronized的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.1.</span> <span class="toc-text">原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">2.2.</span> <span class="toc-text">java对象头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">锁升级模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">2.4.</span> <span class="toc-text">偏向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="toc-number">2.4.1.</span> <span class="toc-text">介绍：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84"><span class="toc-number">2.4.2.</span> <span class="toc-text">目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.4.3.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">2.4.4.</span> <span class="toc-text">过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E9%80%BB%E8%BE%91"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">偏向锁逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E8%A7%A3%E9%94%81"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">锁解锁**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E6%92%A4%E9%94%80"><span class="toc-number">2.4.4.3.</span> <span class="toc-text">锁撤销</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91%E5%92%8C%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80"><span class="toc-number">2.4.4.4.</span> <span class="toc-text">批量重偏向和批量撤销</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.4.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">2.5.</span> <span class="toc-text">轻量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.5.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84-1"><span class="toc-number">2.5.2.</span> <span class="toc-text">目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">2.5.3.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">2.5.4.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">2.5.5.</span> <span class="toc-text">流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3"><span class="toc-number">2.5.5.1.</span> <span class="toc-text">入口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81"><span class="toc-number">2.5.5.2.</span> <span class="toc-text">加锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%94%81"><span class="toc-number">2.5.5.3.</span> <span class="toc-text">解锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.5.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">2.6.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E6%B6%88%E9%99%A4"><span class="toc-number">2.7.</span> <span class="toc-text">锁的消除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B"><span class="toc-number">2.8.</span> <span class="toc-text">锁的升级流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E4%B8%8Esynchronized"><span class="toc-number">3.</span> <span class="toc-text">线程中断与synchronized</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="翔仔"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="翔仔的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Sysnchronized锁升级</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2022-07-14 21:26:37" itemprop="dateCreated datePublished" datetime="2022-07-14T21:26:37+08:00">2022-07-14</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2022-08-23 18:00:55" itemprop="dateModified" datetime="2022-08-23T18:00:55+08:00">2022-08-23</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">多线程</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/synchronized/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">synchronized</span></a></span></div><div class="post-author"><span class="author-name">翔仔</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h1><p>synchronized锁的底层原理，分为锁方法和锁代码块。分别利用monitorenter和monitorexit指令和由方法调用指令读取运行时常量池中方法的ACC_SYNCHRONIZED标志来实现。</p>
<h2 id="理解java对象头和monitor"><a href="#理解java对象头和monitor" class="headerlink" title="理解java对象头和monitor"></a>理解java对象头和monitor</h2><p><img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/image-20220226164959223.png" alt="image-20220226164959223" loading="lazy"></p>
<p>在jvm虚拟机中对象的存储分为三部分，对象头、实例数据、对其填充</p>
<ul>
<li><p>实例数据：存放对象的所有属性信息，包括父类的属性信息，如果是数还包括数组的长度。</p>
</li>
<li><p>对齐填充：虚拟机要求对象内存起始地址必须是8字节的整数倍。</p>
</li>
<li><p>对象头：是实现synchronized锁对象的基础，synchronized锁对象由存储在对象头里的引用指向。jvm中用2个字节来存储对象头(数组用3个字节，存储长度)，由mark word和类型指针组成。</p>
</li>
</ul>
<p>对象头中mark word存储的信息主要有：hashcode、分代年龄、锁标记位、是否偏向锁等<img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/1660555064015.png" alt="1660555064015" loading="lazy"></p>
<p>除了默认的mark word信息外，还有以下变化：<img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/1660555119807.png" alt="1660555119807" loading="lazy"></p>
<h3 id="monitor（监视器）"><a href="#monitor（监视器）" class="headerlink" title="monitor（监视器）"></a>monitor（监视器）</h3><p>无论是同步代码块加锁还是同步方法加锁，本质上都是线程获取锁对象相关联的monitor锁监视器对象。</p>
<p>每个对象都有一个自己的monitor，线程需要先获取锁对象的monitor，才可以执行同步代码，未获取到则陷入阻塞。</p>
<p><img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/1660557676506.png" alt="1660557676506" loading="lazy"><strong>ObjectMonitor</strong></p>
<p>java中的monitor是基于c++实现的，由object实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化monitor，除了semaphore，其他字段都是简单的int或者指针类型</span></span><br><span class="line"><span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>;</span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ;</span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">    _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>_owner：指向持有objectmonitor对象的线程</p>
<p>_waitSet：处于wait状态的线程队列</p>
<p>_entryList：处于等待锁释放状态的线程队列</p>
<p>recusions：锁重入次数</p>
<p>_count：记录线程获取锁的次数</p>
<p>ObjectMonitor中有两个队列，_waitSet和_EntryList，用来保存ObjectWauter对象列表(每个等待锁的线程都被封装为ObjectWaiter对象)，_owner指向当前获取ObjectMonitor对象的线程，当多个线程同时访问同一段同步代码后，首先会进入<strong>EntryList</strong>队列里，当线程获取到对象的monitor后，markword里会生成指针指向monitor对象。 _owner会指向当前线程，同时monior的count加1。若此时线程调用wait()方法，将会释放占有的monitor，owner变为null，count减1，同时该线程会进入WaitSet队列等待被唤醒。若当前线程执行完毕将释放monitor(锁)并复位owner的值，以便其他线程进入获取monitor（锁）。 <img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/20170604114223462.png" alt="img" loading="lazy"> </p>
<blockquote>
<p>为什么wait属于object方法，只能在同步代码块或方法中</p>
</blockquote>
<p>因此，每个对象关联一个monitor，当一个线程获取对象锁后，对象头的mark word中产生指向monitor的指针，并且monitor的owner指向当前线程，synchronized锁通过这样的方式获取锁。</p>
<p>也是因此，任意object都可以为锁对象，且wai/botify/noyifyAll等方法属于object方法，且只能运行在同步方法或同步块中。</p>
<h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>写一个测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Synchronized</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">husband</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">new</span> <span class="title class_">Volatile</span>())&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过javap -c xxx.class 命令查看反编译文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro-<span class="number">3</span>:juc aobing$ javap -p -v -c Synchronized.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">Classfile</span> /Users/aobing/IdeaProjects/Thanos/laogong/target/classes/juc/Synchronized.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2020</span>-<span class="number">5</span>-<span class="number">17</span>; size <span class="number">375</span> bytes</span><br><span class="line">  MD5 checksum 4f5451a229e80c0a6045b29987383d1a</span><br><span class="line">  Compiled from <span class="string">&quot;Synchronized.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">juc</span>.Synchronized</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">49</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">3.</span>#<span class="number">14</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">15</span>            <span class="comment">// juc/Synchronized</span></span><br><span class="line">   #<span class="number">3</span> = Class              #<span class="number">16</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">4</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">5</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">6</span> = Utf8               Code</span><br><span class="line">   #<span class="number">7</span> = Utf8               LineNumberTable</span><br><span class="line">   #<span class="number">8</span> = Utf8               LocalVariableTable</span><br><span class="line">   #<span class="number">9</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">10</span> = Utf8               Ljuc/Synchronized;</span><br><span class="line">  #<span class="number">11</span> = Utf8               husband</span><br><span class="line">  #<span class="number">12</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">13</span> = Utf8               Synchronized.java</span><br><span class="line">  #<span class="number">14</span> = NameAndType        #<span class="number">4</span>:#<span class="number">5</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">15</span> = Utf8               juc/Synchronized</span><br><span class="line">  #<span class="number">16</span> = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> juc.Synchronized();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Ljuc/Synchronized;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">husband</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED  <span class="comment">// 这里</span></span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// class juc/Synchronized</span></span><br><span class="line">         <span class="number">2</span>: dup</span><br><span class="line">         <span class="number">3</span>: astore_1</span><br><span class="line">         <span class="number">4</span>: monitorenter   <span class="comment">// 这里</span></span><br><span class="line">         <span class="number">5</span>: aload_1</span><br><span class="line">         <span class="number">6</span>: monitorexit    <span class="comment">// 这里</span></span><br><span class="line">         <span class="number">7</span>: goto          <span class="number">15</span></span><br><span class="line">        <span class="number">10</span>: astore_2</span><br><span class="line">        <span class="number">11</span>: aload_1</span><br><span class="line">        <span class="number">12</span>: monitorexit    <span class="comment">// 这里</span></span><br><span class="line">        <span class="number">13</span>: aload_2</span><br><span class="line">        <span class="number">14</span>: athrow</span><br><span class="line">        <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">5</span>     <span class="number">7</span>    <span class="number">10</span>   any</span><br><span class="line">            <span class="number">10</span>    <span class="number">13</span>    <span class="number">10</span>   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">5</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">15</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">16</span>     <span class="number">0</span>  <span class="built_in">this</span>   Ljuc/Synchronized;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Synchronized.java&quot;</span></span><br></pre></td></tr></table></figure>

<p>从上面字节码可知，同步代码块的实现是利用monitorenter和monitorexit指令，其中前者是同步代码开始的位置，后者是同步代码结束的位置。</p>
<p>当执行monitorenter指令时，试图获取monitor对象的所有权，此时如果monitor计数器的值为0，则使其加一。当前这个线程就是monitor的owner。如果当前线程再次进入，则会重入monitor，计数器值再加一。如果其他线程是monitor的owner，则当前线程会阻塞，直到正在执行的线程执行完毕。</p>
<p>而同步代码中有两个monitorexit指令。无论方法是正常还是异常结束，编译器会产生一个异常处理器，处理所有异常，目的是执行monitorexit指令，字节码也可以看出来多一个monitorexit，就是为了保证异常结束时可以释放monitor。</p>
<h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>同步方法的同步是<strong>隐式</strong>的，即无需通过字节码指令显式去控制。jvm通过从常量池中的方法表结构(method_info Structure)中的ACC_SYNCHRONIZED访问标志区分是否是同步方法。</p>
<p>当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问呢标志区分是否是同步方法，如果是同步方法，则线程将会先取获取monitor，然后再执行方法，最后方法完成后释放monitor。期间其他线程无法获取monitor</p>
<h1 id="Synchronized的优化"><a href="#Synchronized的优化" class="headerlink" title="Synchronized的优化"></a>Synchronized的优化</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>传统的锁监视器monitor依赖于底层的操作系统的Mutex Lock实现，而操作系统实现线程之间的切换需要从用户态到内核态。这种状态的转换非常耗时，而如果同步代码过于简单，状态的转换反而比同步代码执行时间还长，这种方式的同步锁成为<strong>重量锁</strong></p>
<p>而java开发者发现，对于大部分同步代码大多数时候，并没有多线程竞争，或是两个线程近乎交替的执行，这种情况，频繁的锁获取和释放<strong>会损耗大量的性能和上下文切换</strong>。</p>
<p>因此，jdk1.6之后对synchronized锁进行了优化，引入，偏向锁、轻量级锁。</p>
<h2 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h2><p>在jvm中，java对象分为三部分：对象头、示例数据、对其填充。</p>
<p><img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/image-20220226164959223.png" alt="image-20220226164959223" loading="lazy"></p>
<p> <img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/11b5a74429f042d1b73121d2d34acf98.png" alt="在这里插入图片描述" loading="lazy"> </p>
<ul>
<li><p>对象头(两个字存储，数组三个字，记录数组长度)</p>
<ul>
<li>mark word：用于存储自身运行时数据，如hashcode、分代年龄、锁标志位、偏向时间戳、线程持有的锁</li>
<li>类型指针，指向对象是哪个类的实例</li>
</ul>
</li>
<li><p>示例数据</p>
<p>存放类的属性数据，包括父类属性信息</p>
</li>
<li><p>对其填充</p>
<p>非必须，虚拟机要求对象起始地址为8字节整数倍</p>
</li>
</ul>
<p>mark word是synchronized锁的关键。默认情况下，存储hashcode、gc分代年龄、锁标志位、是否是偏向锁。</p>
<p><img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/1657807202150.png" alt="1657807202150" loading="lazy"></p>
<h2 id="锁升级模型"><a href="#锁升级模型" class="headerlink" title="锁升级模型"></a>锁升级模型</h2><p> <img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/2018111713424283.png" alt="img" loading="lazy">  </p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><blockquote>
<p>背景：在大多实际开发环境中，锁不仅不存在多线程竞争，而且总是由同一线程获取，那么多次的获取和释放只会带来很多不必要的性能开销和上下文切换</p>
</blockquote>
<h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>如果一个线程获得锁，那么进入偏向锁模式，此时mark word进入偏向锁结构，当同一线程再次请求时，无需获取锁，减少获取锁的性能损耗</p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SyncDemo1</span> <span class="variable">syncDemo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncDemo1</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            syncDemo1.addString(<span class="string">&quot;test:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        list.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>加synchronized关键字保证list的安全，但只有一个线程重复访问。对于这种情况，传统的synchronized会大量无用性能损耗。</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>jvm开发者发现大多数情况下，在java运行期间，同步块代码只有一个线程去不断的获取和释放锁，这种情况下，引入偏向锁</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点： 加锁解锁无需额外的消耗，和非同步方法时间相差纳秒级别。 </p>
<p>缺点： 如果竞争的线程多，那么会带来额外的锁撤销的消耗（撤销时会暂停原所有者线程）。 </p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>偏向锁 在<strong>第一次</strong>获得锁时，会有一个<em><strong>CAS</strong></em>操作，之后该线程再获取锁，只会执行几个简单的命令，而不是开销相对较大的<em>CAS</em>命令。 </p>
<p><strong>工作流程</strong></p>
<p> <img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/e4a9527bc2e2421da4e68fc2b23bbda3.png" alt="在这里插入图片描述" loading="lazy"> </p>
<p><strong>对象创建</strong></p>
<p>当新创建一个对象时，如果对象所属class没有关闭偏向锁模式，那么新建对象的mark word就是可偏向状态，此时mark word的thread id为0，表示未偏向任何线程，也叫做<strong>匿名偏向</strong></p>
<blockquote>
<p>需要注意的是，即使模式默认开启，出于性能（启动时间）的原因，在JVM启动后的的头4秒钟这个feature是被禁止的。这也意味着在此期间，_prototype_header会将它的locked_bias位设置为0，以禁止实例化的对象被偏向。4秒钟之后，所有的_prototype_header的locked_bias位会被重设为1，如此新的对象就可以被偏向锁定了。</p>
</blockquote>
<p><strong>初始状态</strong></p>
<p><strong>1.当对象头的locked_bias为0时</strong>，此对象处于未锁定不可偏向的状态。</p>
<p>在此状态下，如果有线程尝试获取此锁，会升级为轻量级锁。如果有多个线程尝试获取此锁，会升级为重量级锁。 <img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/f308f5b84373429e8397de8cded9b5c0.png" alt="在这里插入图片描述" loading="lazy"> </p>
<p> 注：对象的<code>hashCode</code>并不是一创建就计算好的，而是在调用<em>hasCode</em>方法后,储存在对象头中的。且一旦被偏向的对象进行<code>hashcode</code>计算时，不管该对象有没有被锁定，都会触发偏向锁撤销。 </p>
<p>此状态出现的可能：</p>
<ul>
<li>计算hashcode</li>
<li>偏向锁被禁用</li>
<li>偏向锁被撤销</li>
</ul>
<p><strong>2.当对象头locked_bias为1时，</strong>此对象会处于以下三种状态：</p>
<ul>
<li><p><strong>匿名偏向</strong></p>
<p>在此状态下threadid为0，意味着还没有线程获取偏向锁。<strong>第一个试图获取锁的线程会面临这个情况</strong>，使用后原子<strong>cas</strong>指令可将该锁对象绑定到当前线程。这是<strong>允许偏向锁的类对象的初始状态</strong> <img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/57dbe9a2084f465485c6dc298d865526.png" alt="在这里插入图片描述" loading="lazy"> </p>
</li>
<li><p><strong>可重偏向</strong></p>
<p>在此状态下，偏向锁的epoch字段是无效的(与 锁对象对应<code>InstanceKlass</code>的<code>_prototype_header</code>的<code>epoch</code>值不匹配 )。<strong>下一个</strong>试图获取锁的线程会面临这个情况，使用cas指令可将该锁对象绑定于当前对象 <img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/4a6f258c2cd04a6cb534c892ede208f7.png" alt="在这里插入图片描述" loading="lazy"> </p>
</li>
<li><p><strong>已偏向</strong></p>
<p>在此状态下，Thread id不为空，且epoch为有效值——意味着其他线程正在使用该对象 <img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/77047ccb305540cc83d04c0856803978.png" alt="在这里插入图片描述" loading="lazy"> </p>
</li>
</ul>
<h4 id="偏向锁逻辑"><a href="#偏向锁逻辑" class="headerlink" title="偏向锁逻辑"></a><strong>偏向锁逻辑</strong></h4><p> <img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/20190415130541918.png" alt="img" loading="lazy"> </p>
<ol>
<li><p>当线程第一次尝试获取同步块时，会先检查对象头mark word的锁标记位是否为01，来判断当前锁对象是否处于偏向锁或轻量级锁状态</p>
</li>
<li><p>判断偏向锁标记位是否为1，是则执行下一步，不是则进入轻量级锁逻辑</p>
</li>
<li><p>当前锁对象处于匿名偏向状态，cas将对象头mark word的Thread id由0改为当前线程id，如果成功则获取偏向锁，继续执行。否则，将偏向锁撤销，升级轻量级锁</p>
</li>
<li><p>若当前锁对象处于已偏向状态，判断对象头mark word的Thread id于当前线程id是否一样，若一样执行5；否则执行6</p>
</li>
<li><p>对象头mark word的Thread id于当前线程id一样，说明是锁的重入，不需要cas进行加锁，只会往当前线程的栈中添加一条 Displaced Mark Word为空的Lock Record(锁记录)中，用来统计重入的次数（ 如图为当对象所处于偏向锁时，当前线程重入3次，线程栈帧中Lock Record记录 ）  <img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/dce7badac65d49ffa1f9e7d36e54dd8f-1657854826475.png" alt="在这里插入图片描述" loading="lazy"></p>
</li>
<li><p>对象头mark word的Thread id和当前线程不一样，对象锁被假定为匿名状态，尝试cas将mark word替换为当前线程id(当epoch不相同时会成功，快速重定向)，<strong>否则</strong>会进入偏向锁撤销阶段，此时会<strong>等待全局安全点</strong>（safe point，代表了一个状态，在该状态下所有线程都是暂停的），暂停所有持有偏向锁的线程，检查持有偏向锁线程的状态，<strong>如果还存活</strong>，则<strong>检查是否还在同步</strong>：</p>
<blockquote>
<p>为什么偏向锁线程id与当前线程di不同还要尝试cas获取偏向？</p>
<p>因为有可能存在对象头epoch与class对象epoch不一样情况，即允许重偏向。 假如这次CAS成功，则此</p>
<p>对象锁可以重新偏向于获取锁的线程 </p>
</blockquote>
</li>
<li><p><strong>若是</strong>，则升级为轻量级锁，原持有锁线程继续持有锁，当前线程进入锁升级逻辑，自旋请求获取锁‘；</p>
</li>
<li><p><strong>如果偏向的线程已不存活或不再同步</strong>，则进行校验<strong>是否允许重偏向</strong>，若允许，则设置为匿名偏向锁状态，cas将mark word设置为当前线程id；  若不允许，则撤销偏向锁，将mark word设置为未锁定不可偏向状态，然后升级为轻量级锁，进行竞争。</p>
</li>
<li><p>唤醒暂停的线程，继续执行</p>
</li>
</ol>
<blockquote>
<p>偏向锁升级的时机为：当锁已经发生偏向后，只要有另一个线程尝试获得偏向锁，则该偏向锁就会升级成轻量级锁。当然这个说法不绝对，因为还有批量重偏向这一机制 </p>
</blockquote>
<h4 id="锁解锁"><a href="#锁解锁" class="headerlink" title="锁解锁**"></a>锁解锁**</h4><p>当偏向锁被一个线程获取到时，会往所有者线程的栈中添加一条 <code>Displaced Mark Word</code>为空的<code>Lock Record</code>。  <img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/dce7badac65d49ffa1f9e7d36e54dd8f-1657854826475.png" alt="在这里插入图片描述" loading="lazy"> </p>
<p> 当有其他线程尝试获得锁时，根据遍历偏向线程的<code>lock record</code>来确定该线程是否还在执行同步块中的代码。因此偏向锁的解锁很简单，仅仅将栈中的最近一条<code>lock record</code>的<code>obj</code>字段设置为null。需要注意的是，偏向锁的解锁步骤中<strong>并不会修改对象头中的thread id。</strong>  <img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/0e1fe418fca84681a11ea8c708eaa5fa.png" alt="在这里插入图片描述" loading="lazy"> </p>
<h4 id="锁撤销"><a href="#锁撤销" class="headerlink" title="锁撤销"></a>锁撤销</h4><p>偏向锁的撤销有三种情况：</p>
<ol>
<li><p>被偏向的对象进行hashcode计算时，不管有无锁定都会触发所撤销，通过cas将hahcode存入markword中</p>
</li>
<li><p>当前的对象是已偏向未锁定状态，即所有者已经退出同步代码块；此时有其他线程进来，若允许重偏向，会恢复成匿名未偏向状态；若不允许重偏向，则锁撤销，设定为未锁定不可偏向状态。</p>
</li>
<li><p>当前线程处于已偏向已锁定状态，即所有者正在执行代码，有其他线程进入，触发锁撤销</p>
</li>
</ol>
<h4 id="批量重偏向和批量撤销"><a href="#批量重偏向和批量撤销" class="headerlink" title="批量重偏向和批量撤销"></a>批量重偏向和批量撤销</h4><p><strong>批量重偏向：</strong>避免短时间内大量偏向锁的撤销。 例如一个线程创建了大量对象并执行了初始的同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，这样会导致大量的偏向锁撤销操作。当执行批量重偏向后，如果原偏向锁持有者线程不再执行同步块，则锁可以偏向于新线程。 </p>
<p><strong>批量撤销：</strong> 在明显多线程竞争剧烈的场景下使用偏向锁是不合适的，例如生产生-消费者模式，会有多个线程参与竞争。当执行批量撤销后，会直接把class中的<code>locked_bias</code>字段置0，该class已经是偏向锁模式的实例会批量撤销偏向锁，该class新分配的对象的<code>mark word</code>则是无锁模式。 </p>
<p><strong>思考</strong></p>
<p>当偏向锁已经偏向于一个线程时，即使所有者线程不再占用此锁，也很难偏向于新的对象。如果有其它的线程试图获取此偏向锁，则会撤销偏向锁，进入锁升级的流程。需要注意的是，在执行撤销操作的时候，会等待线程进入safe point，然后暂停线程。当该class衍生出的多个对象都执行偏向锁撤销的话，也是一笔不小的性能开销。<br><strong>成因</strong></p>
<p>从偏向锁的加锁解锁过程中可看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时，再将偏向锁撤销为无锁状态或升级为轻量级，会消耗一定的性能，所以在多线程竞争频繁的情况下，偏向锁不仅不能提高性能，还会导致性能下降。<br>于是，就有了批量重偏向与批量撤销的机制。<br><strong>原理</strong></p>
<p>以class为单位，为每个class维护一个<strong>偏向锁撤销计数器</strong>，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的mark word中也有该字段，其初始值为创建该对象时，class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其mark word的Thread Id 改成当前线程Id。</p>
<p> 当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。 </p>
<p>详细图解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qicha3705/article/details/120459815">https://blog.csdn.net/qicha3705/article/details/120459815</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>偏向锁的适用场景</strong></p>
<p>在一个时间段内每一时刻都只有一个线程适用同一个对象，但不是每一个时刻都是同一个对象</p>
<p><strong>如何关闭偏向锁和延迟</strong></p>
<p>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。</p>
<p><strong>怎样确定偏向锁有没有被线程占有</strong></p>
<p>如果锁对象属于匿名可偏向的状态，即线程ID=0，那么线程可以直接获取到偏向锁；如果锁对象属于已偏向的状态，那么就从记录的线程ID去查找锁记录，如果未找到，则说明此对象锁属于已偏向未锁定状态，此时会先判断是否允许重偏向来决定获取偏向锁还是走锁升级的逻辑；如果找到了锁记录，则说明此对象锁属锁属于已偏向已锁定状态，此时会直接走锁升级逻辑的判断（依旧存在重偏向的可能）。</p>
<p><strong>什么情况允许重偏向</strong></p>
<p>当偏向锁处于已偏向未锁定状态，通过对比对象头和原型头的epoch，如果不相等，则代表已经达到批量偏向的阈值，允许重偏向，其他情况，只要该锁已偏向于线程，则不允许重偏向。</p>
<p><strong>重偏向需要先撤销偏向锁吗</strong></p>
<p>不需要， 重偏向仅仅需要通过CAS更新线程的id，如果成功对象锁会重偏向于新的线程，如果失败代表发生了竞争，此时才会撤销偏向锁，走锁升级的逻辑。 </p>
<p><strong>为什么JVM进程启动的4秒内偏向锁关闭，4秒以后才延迟开启</strong></p>
<p>jvm进程刚开始启动时，会有很多地方用到synchronized，如果直接开启偏向，产生竞争就要有锁撤销和锁升级，会带来额外性能损耗。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p> 倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为<strong>轻量级锁</strong>的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构 <img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/1657849305777.png" alt="1657849305777" loading="lazy"></p>
<p>轻量级锁并不是替代重量级锁的，它的<strong>本意是在没有多线程竞争的前提下，减少传统的重量级锁使用的操作系统互斥量产生的性能损耗</strong></p>
<p> 轻量级锁能够提升程序性能的依据是“<strong>对绝大部分的锁，在整个同步周期内都不存在竞争</strong>”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是<strong>线程交替执行同步块的场合</strong>，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。 </p>
<h3 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h3><p> JVM的开发者发现在很多情况下，在Java程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此JVM引入了轻量级锁的概念。 </p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>竞争的线程不会阻塞，使用自旋，提高响应速度</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p> 适用于少量线程竞争锁对象，且线程持有锁的时间不长，追求响应速度的场景。 </p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p> <img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/study\blog\blog\source_posts\Sysnchronized锁升级\1661248852531.png" alt="1661248852531" loading="lazy"> </p>
<h4 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h4><p>轻量级锁的进入方式有三种：</p>
<ul>
<li><p>对象处于未锁定不可偏向状态 <img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/445efcc461cf4099953108589986d944.png" alt="在这里插入图片描述" loading="lazy"> </p>
<blockquote>
<p>此状态下，不能进入偏向锁模式，当有线程尝试获取锁时，会通过轻量级锁的方式获取锁</p>
</blockquote>
</li>
<li><p>对象处于已经偏向于线程(不考虑重偏向) <img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/f180e8c5363442a8a207524ee589c4d3.png" alt="在这里插入图片描述" loading="lazy"> </p>
<blockquote>
<p>当锁已经偏向于线程， 且线程处于锁定状态或处于未锁定但不允许重偏向的情况下，其它的线程尝试获取锁时，会触发偏向锁撤销，然后升级为轻量级或重量级锁定。 </p>
</blockquote>
</li>
<li><p>对象被轻量级锁定 <img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/89da391a7b7d49cbac3c814e84ebc86c.png" alt="在这里插入图片描述" loading="lazy"> </p>
<blockquote>
<p>当对象已经被轻量级锁定的时候，会判断是否是锁重入，如果是重入的话，会记录一条Displaced Mark Word为空的Lock Record。如果不是重入，会膨胀为重量级锁。需要注意的是，即使膨胀为重量级锁，没有获取到锁的线程也不会马上阻塞，而是通过适应性自旋尝试获取锁，当自旋次数达到临界值后，才会阻塞未获取到的线程。JVM认为获取到锁的线程大概率会很快的释放锁，这样做是为了尽可能的避免用户态到内核态的切换。</p>
</blockquote>
</li>
</ul>
<h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p> <img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/study\blog\blog\source_posts\Sysnchronized锁升级\java-thread-x-key-schronized-7.png" alt="img" loading="lazy"> </p>
<ol>
<li>判断对象是否是无锁状态(低三位001)，如果是执行2；否则执行4</li>
<li>在栈中建立一个Lock Record，将无锁的mark word拷贝到锁记录的 <code>Displaced Mark Word</code>中，将<code>owner</code>指向当前对象。 </li>
<li>尝试通过CAS将锁对象的mark word 更新为指向Lock Record 的指针，如果成功，该线程获取到轻量级锁，并且需要吧对象头的mark word 的低两位改成0 0（ 注意这里修改的是对象头的<code>Mark Word</code>，<code>Lock Record</code>中记录的还是无锁状态的<code>Mark Word</code> ）；如果更新失败，执行4</li>
<li>对象是轻量级锁定状态，判断对象头的mark word 是否指向当前线程的栈帧，如果是，则这次为锁的重入，将刚刚建立的Locak Record 中的 <code>Displaced Mark Word</code>设置为<code>null</code>  记录重入，该线程重入轻量级锁。如果不是，执行<code>code 5</code>。 </li>
<li>线程获取轻量锁失败，竞争者线程自旋请求获取锁，自旋一定次数后未获取到锁，升级为重量级锁。</li>
<li>锁膨胀为重量级锁后，对象头的mark ord 改为指向重量级锁monitor的指针。阻塞该线程，直到被唤醒。</li>
</ol>
<p><strong>适应性自旋</strong></p>
<p>自适应意味着自旋的时间(次数)不再固定，而是由<strong>前一次在同一个锁上的自旋时间及锁的拥有者的状态</strong>来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>轻量级锁加锁时有重入锁的可能，同样的，解锁时也需要判断是否是锁重入解锁</p>
<ol>
<li>检索当前线程栈中的锁记录空间，从低位往高位找到第一条和此对象有关的Lock Record。加锁时，如果是锁重入，会将 Displaced Mark Word 设置为 null，相应的，在解锁时需要判断Displaced Mark Word是否为 null，如果是，则说明是锁重入解锁，移除onwer的指向，不做替换操作；如果不是，执行2</li>
<li> 通过<em>CAS</em>把当前线程栈帧<code>Lock Record</code>中的<code>Displaced Mark Word</code>替换到对象头的<code>Mark Word</code>中去，如果替换成功，则轻量级解锁成功；如果替换失败，则说明发生了锁膨胀，对象现在是重量级锁定状态，执行3</li>
<li>执行重量级锁释放流程。，同时唤醒被阻塞的线程</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>轻量级锁的适用场景</strong><br>少量的线程竞争锁，且所有者线程占用锁的事件补偿，追求响应速度的场景。</p>
<p><strong>什么时候会升级为轻量级锁</strong><br>当对象的偏向模式被关闭、对象处于已偏向已锁定、已偏向未锁定但不支持重偏向的场景下，就会升级为轻量级锁。</p>
<p><strong>什么时候会升级为重量级锁</strong></p>
<p>竞争者线程适应性自旋一定次数后，未获取到锁，升级为重量级锁，</p>
<p><strong>轻量级锁怎样实现锁重入</strong><br>当轻量级锁已经被线程持有，且对象头的Mark Word指向的是当前线程的栈帧时，会把本条Lock Record的Displaced Mark Word 设置为 null，实现锁重入。当重入解锁时，只需要修改所有者onwer的指向。</p>
<p><strong>轻量级锁是否会自旋</strong><br>轻量级锁流程不会自旋，自旋发生在产生竞争后，获取失败的线程将先尝试适应性自旋，等待所有者释放锁，当到达临界值还未获取锁就升级为重量级锁。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。</p>
<p>适应性自旋：线程的自旋时间由同一个锁前一次自旋时间和结果决定，如果前一次自旋获取到锁，则自旋时间会长一些，而一个锁线程从没自旋获取到，则自旋时间会很短甚至不自旋。</p>
<h2 id="锁的消除"><a href="#锁的消除" class="headerlink" title="锁的消除"></a>锁的消除</h2><p> 消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间 </p>
<h2 id="锁的升级流程"><a href="#锁的升级流程" class="headerlink" title="锁的升级流程"></a>锁的升级流程</h2><p> <img src="/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/6c8febd362e56d6573991b5bf4eeed31.png" alt="img" loading="lazy"> </p>
<h1 id="线程中断与synchronized"><a href="#线程中断与synchronized" class="headerlink" title="线程中断与synchronized"></a>线程中断与synchronized</h1><p>线程中断指的是在运行期间打断线程的运行，在java中有三个方法和线程中断相关：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中断线程（实例方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Thread.interrupt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断线程是否被中断（实例方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> Thread.isInterrupted();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否被中断并清除当前中断状态（静态方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> Thread.interrupted();</span><br></pre></td></tr></table></figure>

<p>对于处于阻塞状态的线程（sleep或wait），调用interrupt方法会中断线程，并重置标记位，而处于运行状态的线程并不会相应中断。同时对于等待获取锁对象的阻塞线程，interrupt方法也不起作用。</p>
<p>所以synchronized是不相应中断的。</p>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/images/alipay.jpg"><img loading="lazy" src="/images/alipay.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/wechatpay.png"><img loading="lazy" src="/images/wechatpay.png" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>翔仔</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/" title="Sysnchronized锁升级">http://example.com/2022/07/14/Sysnchronized%E9%94%81%E5%8D%87%E7%BA%A7/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022/08/12/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" rel="prev" title="动态代理"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">动态代理</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2022/07/11/ThreadLocal/" rel="next" title="ThreadLocal"><span class="post-nav-text">ThreadLocal</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2022 </span><span class="with-love" id="animate" title="云游君的赞助者们"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 翔仔</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.2</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.8.11</span></div><div class="live-time"><span>本博客已运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2022-04-10T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} 天 ${passHour} 小时 ${passMinute} 分 ${passSecond} 秒`;
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>