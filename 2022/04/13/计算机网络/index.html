<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="翔仔"><meta name="copyright" content="翔仔"><meta name="generator" content="Hexo 5.4.2"><meta name="theme" content="hexo-theme-yun"><title>计算机网络 | 翔仔的博客</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.2.4/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/@unocss/runtime/mini.global.js"></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"example.com","root":"/","title":"翔仔的小站","version":"1.8.11","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]},"vendors":{"darken":"https://cdn.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="计算机网络OSI七层模型osi七层模型是国际标准化组织提出一个网络分层模型，大体结构如下： 每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。 OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。 抽象模型：  关于七层模型的总结图片：    TCP&#x2F;IP">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="翔仔的博客">
<meta property="og:description" content="计算机网络OSI七层模型osi七层模型是国际标准化组织提出一个网络分层模型，大体结构如下： 每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。 OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。 抽象模型：  关于七层模型的总结图片：    TCP&#x2F;IP">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649780488105.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649780532070.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/osi-model-detail.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649780713585.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649780875148.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649952105878.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649953015794.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649953658017.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649953669703.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649953852321.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649955885555.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649956215608.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649956400998.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650126891141.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650127346049.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650127557440.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650127923386.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650128030873.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650128163019.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650128320946.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650129009056.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650177935596.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650178045546.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650178222978.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650178448125.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650178824220.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650179425065.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650179941878.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650180122342.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650181290876.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650181470913.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650182147347.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650182291831.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650182382267.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650182471249.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650182602747.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650182860327.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650765674220.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650765761136.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650766348779.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650766543494.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650766618698.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650766728909.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650766831637.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650766941214.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650767685736.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650767893978.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650768177797.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650768510654.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650769004407.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650850040631.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650850498501.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650850544506.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650850812912.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650851343072.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650851841672.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650936953548.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650937429026.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650937964190.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650938280921.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650938528091.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651109430166.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651109996567.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651110475405.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651111474435.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651111700981.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651202363597.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651235128573.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651372998197.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651373019484.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651373073865.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651373175721.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651373299165.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651373380779.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651373535944.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651453559612.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651453640594.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651453756249.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651453958420.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651454303719.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651454438808.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651454608205.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651454839878.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651456030778.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651456125470.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651456163201.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651543397114.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651543481810.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651543531644.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651544139181.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651544985173.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651545864049.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651545880301.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651545952495.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651546093737.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651548758795.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651549121242.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651594479152.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651594840136.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651595587363.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651712759081.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651713424223.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651975934075.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651976382010.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651976741814.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651976968065.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651977218404.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651979196562.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651980925642.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652062282109.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652063276493.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652063425512.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652063510480.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652063744953.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652063922604.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652065055837.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652066744372.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652066880463.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652150723649.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652151450462.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652153061307.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652153577363.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652323407315.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652324231581.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652324852164.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652325019010.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652325265475.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652325496614.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652325889640.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652340958174.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652341178543.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652341725943.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652407074661.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652407519584.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652407891295.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652407934345.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652408341312.png">
<meta property="og:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652409149192.png">
<meta property="article:published_time" content="2022-04-12T16:18:45.000Z">
<meta property="article:modified_time" content="2022-05-13T07:51:35.350Z">
<meta property="article:author" content="翔仔">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649780488105.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="翔仔"><img width="96" loading="lazy" src="/images/tx.jpg" alt="翔仔"><span class="site-author-status" title="不想上学">😭</span></a><div class="site-author-name"><a href="/about/">翔仔</a></div><span class="site-name">翔仔的博客</span><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="我的主页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">12</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">4</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">7</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&amp;uin=910426929&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/YunYouJun" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="985391895@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">1.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">OSI七层模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">TCP&#x2F;IP四层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82-%E7%BB%99%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%80%9A%E4%BF%A1%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">应用层(给应用程序的通信提供服务)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82-%E7%AB%AF%E5%88%B0%E7%AB%AF%E9%80%9A%E4%BF%A1"><span class="toc-number">1.2.2.</span> <span class="toc-text">传输层(端到端通信)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82-%E4%B8%BB%E6%9C%BA%E4%B8%8E%E4%B8%BB%E6%9C%BA%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">1.2.3.</span> <span class="toc-text">网络层(主机与主机间通信)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E3%80%81%E7%89%A9%E7%90%86"><span class="toc-number">1.2.4.</span> <span class="toc-text">网络接口层(数据链路、物理)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82-%E5%B0%86%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7%EF%BC%8C%E8%BF%9B%E8%A1%8C%E5%8F%91%E9%80%81%EF%BC%8C%E4%B8%BA%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E9%93%BE%E8%B7%AF%E7%BA%A7%E5%88%AB%E7%9A%84%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">1.数据链路层(将数据封装成帧，进行发送，为网络层提供链路级别的传输服务)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%89%A9%E7%90%86%E5%B1%82-%E4%B8%BA%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E6%8F%90%E4%BE%9B%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2.物理层(为数据链路提供二进制服务)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP"><span class="toc-number">1.3.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">三次握手与四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-TCP%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">1.TCP基本认识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81TCP%E5%8D%8F%E8%AE%AE%EF%BC%9FTCP%E5%B7%A5%E4%BD%9C%E5%9C%A8%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">2.为什么需要TCP协议？TCP工作在哪一层？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AFTCP%EF%BC%9F"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">3.什么是TCP？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AFTCP%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">4.什么是TCP连接？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E5%94%AF%E4%B8%80%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">5.如何唯一确定一个TCP连接？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">6.TCP与UDP的区别及应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.3.1.7.</span> <span class="toc-text">7.TCP建立连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-TCP%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.3.1.8.</span> <span class="toc-text">8.TCP断开连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">1.3.2.</span> <span class="toc-text">重传机制、滑动窗口、流量控制、拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">重传机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">超时重传</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="toc-number">1.3.2.1.2.</span> <span class="toc-text">快速重传</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SACK%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.1.3.</span> <span class="toc-text">SACK方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#D-SACK-Duplicate-SACK"><span class="toc-number">1.3.2.1.4.</span> <span class="toc-text">D-SACK(Duplicate SACK)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%85%B3%E9%97%AD"><span class="toc-number">1.3.2.3.1.</span> <span class="toc-text">窗口关闭</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E5%BE%81"><span class="toc-number">1.3.2.3.2.</span> <span class="toc-text">糊涂窗口综合征</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="toc-number">1.3.2.4.1.</span> <span class="toc-text">慢启动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.2.4.2.</span> <span class="toc-text">拥塞避免算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F"><span class="toc-number">1.3.2.4.3.</span> <span class="toc-text">拥塞发生</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D"><span class="toc-number">1.3.2.4.4.</span> <span class="toc-text">快速恢复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">1.3.2.4.5.</span> <span class="toc-text">拥塞算法示意图</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP"><span class="toc-number">1.4.</span> <span class="toc-text">IP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">IP基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">基本认识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">IP地址基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.1.2.1.</span> <span class="toc-text">IP地址分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E5%88%86%E7%B1%BB%E5%9C%B0%E5%9D%80CIDR"><span class="toc-number">1.4.1.2.2.</span> <span class="toc-text">无分类地址CIDR</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E6%9C%89IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%A7%81%E6%9C%89IP%E5%9C%B0%E5%9D%80"><span class="toc-number">1.4.1.2.3.</span> <span class="toc-text">公有IP地址与私有IP地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E8%B7%AF%E7%94%B1%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.1.2.4.</span> <span class="toc-text">IP地址与路由控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IP%E5%88%86%E7%89%87%E4%B8%8E%E9%87%8D%E7%BB%84"><span class="toc-number">1.4.1.2.5.</span> <span class="toc-text">IP分片与重组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IPv6%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86"><span class="toc-number">1.4.1.2.6.</span> <span class="toc-text">IPv6基本认识</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IPv4%E9%A6%96%E9%83%A8%E4%B8%8EIPv6%E9%A6%96%E9%83%A8"><span class="toc-number">1.4.1.2.7.</span> <span class="toc-text">IPv4首部与IPv6首部</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF"><span class="toc-number">1.4.2.</span> <span class="toc-text">IP协议相关技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">DNS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARP"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">ARP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DHCP"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">DHCP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ping%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.3.</span> <span class="toc-text">ping的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8A%A9%E6%89%8B%E2%80%94%E2%80%94ICMP%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">IP协议的助手——ICMP协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">查询报文类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%AE%E9%94%99%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">差错报文类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ping%E2%80%94%E2%80%94%E6%9F%A5%E8%AF%A2%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">ping——查询报文类型的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#traceroute%E2%80%94%E2%80%94%E5%B7%AE%E9%94%99%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">traceroute——差错报文类型的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BB%BC%E5%90%88%E7%AF%87"><span class="toc-number">1.5.</span> <span class="toc-text">网络综合篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.键入网址到网页显示，期间发生了什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">HTTP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%9F%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%9F%A5%E8%AF%A2%E2%80%94%E2%80%94DNS"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">真实地址查询——DNS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%8D%97%E5%B8%AE%E6%89%8B%E2%80%94%E2%80%94%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">指南帮手——协议栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E2%80%94%E2%80%94TCP"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">可靠传输——TCP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94IP"><span class="toc-number">1.5.1.5.</span> <span class="toc-text">远程定位——IP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%82%B9%E4%BC%A0%E8%BE%93%E2%80%94%E2%80%94MAC"><span class="toc-number">1.5.1.6.</span> <span class="toc-text">两点传输——MAC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E5%8F%A3%E2%80%94%E2%80%94%E7%BD%91%E5%8D%A1"><span class="toc-number">1.5.1.7.</span> <span class="toc-text">出口——网卡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%81%E5%88%AB%E8%80%85%E2%80%94%E2%80%94%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">1.5.1.8.</span> <span class="toc-text">送别者——交换机</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="翔仔"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="翔仔的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">计算机网络</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2022-04-13 00:18:45" itemprop="dateCreated datePublished" datetime="2022-04-13T00:18:45+08:00">2022-04-13</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2022-05-13 15:51:35" itemprop="dateModified" datetime="2022-05-13T15:51:35+08:00">2022-05-13</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">计算机基础</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">计算机网络</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>osi<strong>七层模型</strong>是国际标准化组织提出一个网络分层模型，大体结构如下：<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649780488105.png" alt="1649780488105" loading="lazy"></p>
<p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</p>
<p><strong>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。</strong></p>
<p>抽象模型：</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649780532070.png" alt="1649780532070" loading="lazy"></p>
<p>关于七层模型的总结图片：</p>
<p> <img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/osi-model-detail.png" alt="img" loading="lazy"> </p>
<h2 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h2><p> 我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成： </p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ol>
<p>需要注意的是不能将TCP/IP四层模型和OSI七层模型完全精确匹配，但可以将两者简单对应：<br><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649780713585.png" alt="1649780713585" loading="lazy"></p>
<h3 id="应用层-给应用程序的通信提供服务"><a href="#应用层-给应用程序的通信提供服务" class="headerlink" title="应用层(给应用程序的通信提供服务)"></a>应用层(给应用程序的通信提供服务)</h3><blockquote>
<p><strong>应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交互的服务，</strong>定义了信息交换的格式，消息会交给下一层传输层来传输，将应用层交互的数据成为报文</p>
</blockquote>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649780875148.png" alt="1649780875148" loading="lazy"></p>
<p> <strong>应用层协议定义了网络通信规则</strong>，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。 </p>
<p>我们手机或电脑使用的应用软件就是再应用层实现，当两个设备的应用需要通信时，应用把应用数据传给下一层</p>
<p>所以，<strong>应用层只专注于为用户提供应用功能，不关心数据如何传输</strong></p>
<h3 id="传输层-端到端通信"><a href="#传输层-端到端通信" class="headerlink" title="传输层(端到端通信)"></a>传输层(端到端通信)</h3><p>应用层的数据包会传给传输层，<strong>传输层是为应用层提供网路支持</strong></p>
<p><strong>因此传输层的主要任务时负责两台设备的进程之间的通信提供通用的数据传输服务</strong>， 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。 <img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649952105878.png" alt="1649952105878" loading="lazy"></p>
<p>传输层有两种协议：</p>
<ol>
<li><strong>传输控制协议TCP，提供面向连接、可靠的传输服务</strong>。大部分应用使用tcp协议，如HTTP应用层协议。TCP比UDP多了很多特性，如<strong>流量控制、超时重传、拥塞控制</strong>等，这些保证了数据可靠的传输</li>
<li>用户数据协议UDP，提供<strong>无连接的，尽最大努力的数据传输服务(不保证数据传输的可靠性</strong>），UDP相对简单，只负责发送数据包，不保证发送的数据包是否抵达对方，但它的实时性更好，传输效率也更高</li>
</ol>
<p>应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此<strong>当传输层的数据包大于MSS(最大报文长度</strong>)时，就要将数据包分片，这样即使途中有一个分片丢失，也只需要传输这一个分片即可。再TCP协议中，把每一个分片叫做TCP段<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649953015794.png" alt="1649953015794" loading="lazy"></p>
<p>当设备作为接收方时，传输层则要负责把数据包传给应用，而一台设备上可能会有很多应用再接收或者传输数据，因此<strong>需要一个编号进行区分应用程序</strong>，这个编号就是<strong>端口</strong></p>
<p>⽐如 80 端⼝通常是 Web 服务器⽤的，22 端⼝通常是远程登录服务器⽤的。⽽对于浏览器（客户端）中的每个标 </p>
<p>签栏都是⼀个独⽴的进程，操作系统会为这些进程分配临时的端⼝号。 </p>
<p>由于传输层的报⽂中会携带端⼝号，因此接收⽅可以识别出该报⽂是发送给哪个应⽤。</p>
<h3 id="网络层-主机与主机间通信"><a href="#网络层-主机与主机间通信" class="headerlink" title="网络层(主机与主机间通信)"></a>网络层(主机与主机间通信)</h3><blockquote>
<p>实际场景中的网络错综复杂，中间有各种各样的线路和岔路，复杂且多变，而传输层的设计理念是简单、高效、专注，也就是说我们不希望传输层协议处理太多事情，只需要作为应用间传输数据的媒介，而实际传输功能交给网络层即可</p>
</blockquote>
<p><strong>网络层主要负责为分组交换网的不同主机提供通信服务</strong>。 在发送数据时，网络层<strong>把运输层产生的报文段或用户数据报封装成分组和包进行传送</strong>。在 TCP/IP 体系结构中，由于<strong>网络层使用 IP 协议</strong>，因此分组也叫 <strong>IP 数据报，简称数据报</strong>。 <img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649953658017.png" alt="1649953658017" loading="lazy"></p>
<p><strong>注意:不要把传输层的”用户数据报UDP”和网络层的”IP数据报”搞混</strong></p>
<p> 互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP 层</strong>。 </p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649953669703.png" alt="1649953669703" loading="lazy"></p>
<p>网络层最常用的是IP协议，IP协议会将<strong>传输层的报文作为数据部分</strong>，<strong>再加上IP包头组成IP报文</strong>，<strong>如果ip报文超过MTU(以太网中一般1500字节)就会再次分片</strong>，得到一个即将发送到网络的IP报文。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649953852321.png" alt="1649953852321" loading="lazy"></p>
<p>网络层负责将数据从一个设备传输到另一个设备，世界上设备很多，有如何找到呢?因此网络层需要有区分设备的编号。</p>
<p>一般将IP地址给设备进行编号，对于IPV4协议，IP地址共32位，分成四段，每段八位。然而只有一个IP地址虽然做到了设备的区分，但</p>
<p>寻址起来特别麻烦，因为全世界设备过多，无法做到一 一匹配。</p>
<p>因此需要将IP地址分成两种意义：</p>
<ul>
<li>网络号，负责标识该IP地址是属于哪个子网的</li>
<li>主机号，负责标识同一子网下的不同主机</li>
</ul>
<p>而要划分出一台主机的网络号和主机号，则还需要<strong>子网掩码</strong>的配合：</p>
<p>子网掩码：32位二进制数，网络号都为1，主机号都为0，因此，将子网掩码与IP地址做”&amp;”运算，所得结果相同的主机即为同一子网。</p>
<p>所以，<strong>IP</strong> <strong>协议的寻址作⽤是告诉我们去往下⼀个⽬的地该朝哪个⽅向⾛，路由则是根据「下⼀个⽬的地」选择路径。寻址更像在导航，路由更像在操作⽅向盘</strong>。</p>
<h3 id="网络接口层-数据链路、物理"><a href="#网络接口层-数据链路、物理" class="headerlink" title="网络接口层(数据链路、物理)"></a>网络接口层(数据链路、物理)</h3><p> 我们可以把网络接口层看作是数据链路层和物理层的合体。 </p>
<ol>
<li><p>数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。<strong>数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</strong></p>
</li>
<li><p><strong>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong></p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649955885555.png" alt="1649955885555" loading="lazy"></p>
</li>
</ol>
<h4 id="1-数据链路层-将数据封装成帧，进行发送，为网络层提供链路级别的传输服务"><a href="#1-数据链路层-将数据封装成帧，进行发送，为网络层提供链路级别的传输服务" class="headerlink" title="1.数据链路层(将数据封装成帧，进行发送，为网络层提供链路级别的传输服务)"></a>1.数据链路层(将数据封装成帧，进行发送，为网络层提供链路级别的传输服务)</h4><blockquote>
<p>再实际场景中，网络并不是一个整体。比如你家和我家不属于一个网路，因此数据不仅可以再同一个网络中传输，也可以跨网络进行传输</p>
</blockquote>
<p>⼀旦数据需要跨⽹络传输，就需要有⼀个设备同时在两个⽹络当中，这个设备⼀般是<strong>路由器</strong>，路由器可以通过路由 表计算出下⼀个要去的 IP 地址。</p>
<p>那问题来了，路由器怎么知道这个 IP 地址是哪个设备的呢？</p>
<p>于是，就需要有⼀个专⻔的层来标识⽹络中的设备，让数据在⼀个链路中传输，这就是<strong>数据链路层</strong>（<em>Data Link</em> </p>
<p><em>Layer</em>），它主要为⽹络层提供链路级别传输的服务。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649956215608.png" alt="1649956215608" loading="lazy"></p>
<p>每⼀台设备的⽹卡都会有⼀个 MAC 地址，它就是⽤来唯⼀标识设备的。路由器计算出了下⼀个⽬的地 IP 地址，再 </p>
<p>通过 ARP 协议找到该⽬的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了。</p>
<h4 id="2-物理层-为数据链路提供二进制服务"><a href="#2-物理层-为数据链路提供二进制服务" class="headerlink" title="2.物理层(为数据链路提供二进制服务)"></a>2.物理层(为数据链路提供二进制服务)</h4><p>当数据准备要从设备发送到⽹络时，需要把数据包转换成电信号，让其可以在物理介质中传输，这⼀层就是<strong>物理层</strong>（<em>Physical Layer</em>），它<strong>主要是为数据链路层提供⼆进制传输的服务。</strong><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1649956400998.png" alt="1649956400998" loading="lazy"></p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h3><h4 id="1-TCP基本认识"><a href="#1-TCP基本认识" class="headerlink" title="1.TCP基本认识"></a>1.TCP基本认识</h4><p>TCP头的格式：<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650126891141.png" alt="1650126891141" loading="lazy"></p>
<p><strong>序列号：</strong>在建立连接时由计算机<strong>生成的随机数</strong>作为初始值，通过<strong>SYN包传给接收端主机</strong>，每发送一次数据，就<strong>累加一次该数据字节数的大小</strong>。<strong>用来解决网络包乱序的问题</strong>。</p>
<p><strong>确认应答号：</strong>指下一次期望接收到的数据的序列号，发送端收到这个确认应答号以后就认为这个序号之前的数据都已被正常接收。<strong>用来解决不丢包问题</strong></p>
<p><strong>控制位：</strong></p>
<ul>
<li>ACK:该位为1时，确认应答字段认为有效，TCP除了最初建立连接时的SYN包外该位必须置为1</li>
<li><em>RST</em>：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYN</em>：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的 主机之间就可以相互交换 FIN 位为 1 的 TCP 段。</li>
</ul>
<h4 id="2-为什么需要TCP协议？TCP工作在哪一层？"><a href="#2-为什么需要TCP协议？TCP工作在哪一层？" class="headerlink" title="2.为什么需要TCP协议？TCP工作在哪一层？"></a>2.为什么需要TCP协议？TCP工作在哪一层？</h4><p>IP层是不可靠的，它不保证网络包的交付、不保证网络包按序交付、也不保证网络包中数据的完整性。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650127346049.png" alt="1650127346049" loading="lazy"></p>
<p>如果需要保证网络数据包的可靠性，那么就需要由上一层(传输层)的TCP协议来负责。</p>
<p>因为TCP是一个工作在传输层的可靠数据传输的服务，因此能确保接收端接收到的网络包是无损坏、无间隔、非冗余和按序的。</p>
<h4 id="3-什么是TCP？"><a href="#3-什么是TCP？" class="headerlink" title="3.什么是TCP？"></a>3.什么是TCP？</h4><p>TCP是面向连接的、可靠的、基于字节流的传输层通信协议。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650127557440.png" alt="1650127557440" loading="lazy"></p>
<ul>
<li>面向连接:一定是 <strong>一对一</strong> 才能连接，不能像UDP协议一样可以一个主机同时向多个主机发消息。</li>
<li>可靠的:无论网络链路中出现了怎样的链路变化，TCP都可以保证一个报文<strong>可以到达接收端</strong></li>
<li>字节流:消息是<strong>没有边界</strong>的，所以无论消息有多大都可以传输，并且<strong>消息是有序</strong>的。当前一个消息没有收到额 的时候，即使先收到了后一个字节，也不能扔给应用层处理，同时<strong>对重复的报文会丢弃。</strong></li>
</ul>
<h4 id="4-什么是TCP连接？"><a href="#4-什么是TCP连接？" class="headerlink" title="4.什么是TCP连接？"></a>4.什么是TCP连接？</h4><p>简单来说就是，用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小成为连接<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650127923386.png" alt="1650127923386" loading="lazy"></p>
<p>所以我们可以知道，建⽴⼀个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识。 </p>
<ul>
<li><strong>Socket</strong>：由 IP 地址和端⼝号组成 </li>
<li><strong>序列号</strong>：⽤来解决乱序问题等 </li>
<li><strong>窗⼝⼤⼩</strong>：⽤来做流ᰁ控制</li>
</ul>
<h4 id="5-如何唯一确定一个TCP连接？"><a href="#5-如何唯一确定一个TCP连接？" class="headerlink" title="5.如何唯一确定一个TCP连接？"></a>5.如何唯一确定一个TCP连接？</h4><p>TCP四元组：</p>
<ul>
<li>源地址</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口</li>
</ul>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650128030873.png" alt="1650128030873" loading="lazy"></p>
<p>源地址和⽬的地址的字段（32位）是在 IP 头部中，作⽤是通过 IP 协议发送报⽂给对⽅主机。 </p>
<p>源端⼝和⽬的端⼝的字段（16位）是在 TCP 头部中，作⽤是告诉 TCP 协议应该把报⽂发给哪个进程。</p>
<blockquote>
<p>一个IP的服务器监听了一个端口，它的TCP最大连接数多少？</p>
</blockquote>
<p>服务器通常固定在某个本地端⼝上监听，等待客户端的连接请求。 </p>
<p>因此，客户端 IP 和 端⼝是可变的，其理论值计算公式如下:<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650128163019.png" alt="1650128163019" loading="lazy"></p>
<p>对 IPv4，客户端的 IP 数最多为 2 的 32 次⽅，客户端的端⼝数最多为 2 的 16 次⽅，也就是服务端单机最 </p>
<p>⼤ TCP 连接数，约为 2 的 48 次⽅。 </p>
<p>当然，服务端最⼤并发 TCP 连接数远不能达到理论上限。 </p>
<ul>
<li>⾸先主要是<strong>⽂件描述符限制</strong>，Socket 都是⽂件，所以⾸先要通过 ulimit 配置⽂件描述符的数⽬； </li>
<li>另⼀个是<strong>内存限制</strong>，每个 TCP 连接都要占⽤⼀定内存，操作系统的内存是有限的。</li>
</ul>
<h4 id="6-TCP与UDP的区别及应用场景"><a href="#6-TCP与UDP的区别及应用场景" class="headerlink" title="6.TCP与UDP的区别及应用场景"></a>6.TCP与UDP的区别及应用场景</h4><p>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。</p>
<p>UDP协议头部只有8个字节(64位)，头部格式如下：<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650128320946.png" alt="1650128320946" loading="lazy"></p>
<ul>
<li>⽬标和源端⼝：主要是告诉 UDP 协议应该把报⽂发给哪个进程。 </li>
<li>包⻓度：该字段保存了 UDP ⾸部的⻓度跟数据的⻓度之和。 </li>
<li>校验和：校验和是为了提供可靠的 UDP ⾸部和数据⽽设计。</li>
</ul>
<p><strong>区别：</strong></p>
<ol>
<li>连接<ul>
<li>TCP是面向连接的传输层协议，传输数据前先要建立连接</li>
<li>UDP不需要连接，即刻传输</li>
</ul>
</li>
<li>服务对象<ul>
<li>TCP是一对一的两点服务</li>
<li>UDP支持一对一、一对多、多对多</li>
</ul>
</li>
<li>可靠性<ul>
<li>TCP是可靠交付数据，数据可以不丢失、不重复、按序到达</li>
<li>UDP是尽最大可能交付，不保证可靠传输</li>
</ul>
</li>
<li>拥塞控制、流量控制<ul>
<li>TCP由拥塞控制、流量控制机制，保证数据传输的安全性</li>
<li>UDP则没有，即使网络非常堵塞，也不会影响UDP的发送速率</li>
</ul>
</li>
<li>首部开销<ul>
<li>TCP首部长度较长，会有一定的开销，在没有使用选项的时候，是20个字节，使用后则会变长</li>
<li>UDP首部只有8个字节，并且是固定不变的，开销较小</li>
</ul>
</li>
<li>传输方式<ul>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>
<li> UDP 是⼀个包⼀个包的发送，是有边界的，但可能会丢包和乱序。</li>
</ul>
</li>
<li>分片不同<ul>
<li>TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在传输层进⾏分⽚，⽬标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚。</li>
<li> UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会在 IP 层进⾏分⽚，⽬标主机收到后，在 IP 层组装完数据，接着 再传给传输层，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则就需要重传所有的数据包，这样 传输效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU。</li>
</ul>
</li>
</ol>
<p><strong>TCP与UDP的应用场景：</strong></p>
<p>由于 TCP 是⾯向连接，能保证数据的可靠性交付，因此经常⽤于： </p>
<ul>
<li>FTP ⽂件传输 </li>
<li>HTTP / HTTPS </li>
</ul>
<p>由于 UDP ⾯向⽆连接，它可以随时发送数据，再加上UDP本身的处理既简单⼜⾼效，因此经常⽤于： </p>
<ul>
<li>包总量较少的通信，如 DNS 、 SNMP 等 </li>
<li>视频、⾳频等多媒体通信 </li>
<li>⼴播通信</li>
</ul>
<blockquote>
<p>为什么 UDP 头部没有「⾸部⻓度」字段，⽽ TCP 头部有「⾸部⻓度」字段呢？</p>
</blockquote>
<p>原因是 TCP 有<strong>可变⻓</strong>的「选项」字段，⽽ UDP 头部⻓度则是<strong>不会变化</strong>的，⽆需多⼀个字段去记录 UDP 的⾸部⻓度。</p>
<blockquote>
<p>为什么 UDP 头部有「包⻓度」字段，⽽ TCP 头部则没有「包⻓度」字段呢？</p>
</blockquote>
<p>TCP计算负载数据长度：<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650129009056.png" alt="1650129009056" loading="lazy"></p>
<p>其中 IP 总⻓度 和 IP ⾸部⻓度，在 IP ⾸部格式是已知的。TCP ⾸部⻓度，则是在 TCP ⾸部格式已知的，所以就 </p>
<p>可以求得 TCP 数据的⻓度。 </p>
<p>⼤家这时就奇怪了问：“ UDP 也是基于 IP 层的呀，那 UDP 的数据⻓度也可以通过这个公式计算呀？ 为何还要有 </p>
<p>「包⻓度」呢？” </p>
<p>这么⼀问，确实感觉 UDP 「包⻓度」是冗余的。 </p>
<p><strong>因为为了⽹络设备硬件设计和处理⽅便，⾸部⻓度需要是</strong> <strong>4</strong> <strong>字节的整数倍。</strong> </p>
<p>如果去掉 UDP 「包⻓度」字段，那 UDP ⾸部⻓度就不是 4 字节的整数倍了，所以这可能是为了补全 UDP ⾸部⻓度是 4 字节的整数倍，才补充了「包⻓度」字段。</p>
<h4 id="7-TCP建立连接"><a href="#7-TCP建立连接" class="headerlink" title="7.TCP建立连接"></a>7.TCP建立连接</h4><blockquote>
<p>TCP三次握手过程和状态变迁</p>
</blockquote>
<p>TCP 是⾯向连接的协议，所以使⽤ TCP 前必须先建⽴连接，⽽<strong>建⽴连接是通过三次握⼿来进⾏的。</strong><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650177935596.png" alt="1650177935596" loading="lazy"></p>
<ul>
<li>一开始客户端与服务端都处于 CLOSED 状态，首先服务端主动监听某个端口，处于 LISTEN 状态<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650178045546.png" alt="1650178045546" loading="lazy"></li>
<li>客户端会随机初始化序列号(client_isn)，将此序列号置于TCP首部的序列号字段里，同时把 SYN 标志位置为1，表示SYN报文。接着把SYN报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于SYN_SENT状态。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650178222978.png" alt="1650178222978" loading="lazy"></li>
<li>服务端收到客户端的 SYN 报文后，首先随机初始化自己的序列号(server_isn)，填入TCP首部的序号字段中，其次把TCP首部的确认应答号填入client_isn+1，接着把SYN和ACK标志位置为1.最好把该报文发送给客户端，该报文也不包含应用层数据，之后服务端处于SYN_RCVD。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650178448125.png" alt="1650178448125" loading="lazy"></li>
<li>客户端接收到服务端的报文后，还要向服务端回应一个应答报文，首先把TCP首部确认应答号填入server_isn+1,接着将ACK标志位置为1，最后把该报文发送给服务端，此次报文可以携带客户端到服务端的数据，之后客户端处于ESTAbLISHED。</li>
<li>服务端收到客户端的报文后，也处于ESTAbLISHED状态</li>
</ul>
<p>从上面过程可以发现<strong>第三此握手是可以携带数据的，前两次握手不能。</strong></p>
<p>⼀旦完成三次握⼿，双⽅都处于 ESTABLISHED 状态，此时连接就已建⽴完成，客户端和服务端就可以相互发送 </p>
<p>数据了。</p>
<blockquote>
<p><strong>如何在Linux系统查看TCP状态？</strong></p>
</blockquote>
<p>TCP 的连接状态查看，在 Linux 可以通过 <strong>netstat -napt</strong> 命令查看。</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650178824220.png" alt="1650178824220" loading="lazy"></p>
<blockquote>
<p><strong>为什么是三次握手？不是两次、四次</strong></p>
</blockquote>
<p>在前面知道了什么是TCP连接：</p>
<ul>
<li>⽤于保证可靠性和流ᰁ控制维护的某些状态信息，这些信息的组合，包括<strong>Socket****、序列号和窗⼝⼤⼩</strong>称为连 接。</li>
</ul>
<p>所以最重要的是<strong>为什么三次握手才可以初始化Socket、序列号和窗口大小并建立TCP连接。</strong></p>
<ul>
<li>三次握手才可以阻止重复历史连接的建立</li>
<li>三次握手才可以同步双方的初始化序列号</li>
<li>三次握手才可以避免浪费资源</li>
</ul>
<p><strong>原因一：避免出现历史连接</strong></p>
<p>简单来说，三次握手<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong></p>
<p>网络环境错综复杂，有时由于网络阻塞等乱七八糟的原因，可能导致旧的数据包先到达目标主机，那么这种情况三次握手怎么避免呢？<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650179425065.png" alt="1650179425065" loading="lazy"></p>
<p>客户端在连续发送多次SYN建立连接的报文，在网络阻塞情况下：</p>
<ul>
<li>一个旧的SYN报文比最新的SYN报文早到达了服务器</li>
<li>那么此时服务端会回一个ACK+SYN报文给客户端</li>
<li>客户端收到后，可以根据自身上下文判断这是一个历史连接(序列号过期或超时)，那么客户端就会发送RST报文给服务端，表示中止这一次连接</li>
</ul>
<p>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端(发送方)准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：</p>
<ul>
<li>如果是历史连接(序列号过期或超时)，则第三次握手发送的报文是RST报文，以此中断历史连接</li>
<li>如果不是历史连接，则第三次发送的报文时ACK应答报文，通信双方成功建立连接</li>
</ul>
<p>所以，TCP 使⽤三次握⼿建⽴连接的最主要原因是<strong>防⽌历史连接初始化了连接。</strong></p>
<p><strong>原因二：同步双方初始序列号</strong></p>
<p>TCP 协议的通信双⽅， 都必须维护⼀个「序列号」， 序列号是可靠传输的⼀个关键因素，它的作⽤：  </p>
<ul>
<li>接收⽅可以去除᯿复的数据； </li>
<li>接收⽅可以根据数据包的序列号按序接收； </li>
<li>可以标识发送出去的数据包中， 哪些是已经被对⽅收到的； </li>
</ul>
<p>可⻅，序列号在 TCP 连接中占据着⾮常᯿要的作⽤，所以当客户端发送携带「初始序列号」的 SYN 报⽂的时 候，需要服务端回⼀个 ACK 应答报⽂，表示客户端的 SYN 报⽂已被服务端成功接收，那当服务端发送「初始序 列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样⼀来⼀回，才能确保双⽅的初始序列号能被可靠的</strong> <strong>同步。</strong><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650179941878.png" alt="1650179941878" loading="lazy"></p>
<p>四次握⼿其实也能够可靠的同步双⽅的初始化序号，但由于<strong>第⼆步和第三步可以优化成⼀步</strong>，所以就成了「三次握⼿」。 </p>
<p>⽽两次握⼿只保证了⼀⽅的初始序列号能被对⽅成功接收，没办法保证双⽅的初始序列号都能被确认接收。</p>
<p><strong>原因三：避免浪费资源</strong></p>
<p>如果只有「两次握⼿」，当客户端的 SYN 请求连接在⽹络中阻塞，客户端没有接收到 ACK 报⽂，就会᯿新发 送 SYN ，由于没有第三次握⼿，服务器不清楚客户端是否收到了⾃⼰发送的建⽴连接的 ACK 确认信号，所以 每收到⼀个 SYN 就只能先主动建⽴⼀个连接，这会造成什么情况呢？ </p>
<p>如果客户端的 SYN 阻塞了，᯿复发送多次 SYN 报⽂，那么服务器在收到请求后就会<strong>建⽴多个冗余的⽆效链接，造成不必要的资源浪费</strong><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650180122342.png" alt="1650180122342" loading="lazy"></p>
<p>即两次握⼿会造成消息滞留情况下，服务器᯿复接受⽆⽤的连接请求 SYN 报⽂，⽽造成重复分配资源。</p>
<p><strong>小结</strong></p>
<p>TCP 建⽴连接时，通过三次握⼿<strong>能防⽌历史连接的建⽴，能减少双⽅不必要的资源开销，能帮助双⽅同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。 </p>
<p>不使⽤「两次握⼿」和「四次握⼿」的原因： </p>
<ul>
<li>「两次握⼿」：⽆法防⽌历史连接的建⽴，会造成双⽅资源的浪费，也⽆法可靠的同步双⽅序列号； </li>
<li>「四次握⼿」：三次握⼿就已经理论上最少可靠连接建⽴，所以不需要使⽤更多的通信次数。</li>
</ul>
<blockquote>
<p>为什么客户端和服务端的初始序列号 ISN 是不相同的？</p>
</blockquote>
<p>如果⼀个已经失效的连接被重⽤了，但是该旧连接的历史报⽂还残留在⽹络中，如果序列号相同，那么就⽆法分辨 出该报⽂是不是历史报⽂，如果历史报⽂被新的连接接收了，则会产⽣数据错乱。 </p>
<p>所以，每次建⽴连接前重新初始化⼀个序列号主要是为了通信双⽅能够根据序号将不属于本连接的报⽂段丢弃。 </p>
<p>另⼀⽅⾯是为了安全性，防⽌⿊客伪造的相同序列号的 TCP 报⽂被对⽅接收。</p>
<blockquote>
<p>初始序列号 ISN 是如何随机产⽣的？</p>
</blockquote>
<p>起始 ISN 是基于时钟的，每 4 毫秒 + 1，转⼀圈要 4.55 个⼩时。 </p>
<p>RFC1948 中提出了⼀个较好的初始化序列号 ISN 随机⽣成算法。 </p>
<p><em>ISN = M + F (localhost, localport, remotehost, remoteport)</em></p>
<ul>
<li>M 是⼀个计时器，这个计时器每隔 4 毫秒加 1。 </li>
<li>F 是⼀个 Hash 算法，根据源 IP、⽬的 IP、源端⼝、⽬的端重⽣成⼀个随机数值。要保证 Hash 算法不能被外部轻易推算得出，⽤ MD5 算法是⼀个⽐较好的选择。</li>
</ul>
<blockquote>
<p>既然 IP 层会分⽚，为什么 TCP 层还需要 MSS 呢？</p>
</blockquote>
<p>我们先来认识下MTU和MSS<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650181290876.png" alt="1650181290876" loading="lazy"></p>
<ul>
<li>MTU ：⼀个⽹络包的最⼤⻓度，以太⽹中⼀般为 1500 节；</li>
<li> MSS ：除去 IP 和 TCP 头部之后，⼀个⽹络包所能容纳的TCP 数据的最⼤⻓度；</li>
</ul>
<p>如果在 TCP 的整个报⽂（头部 + 数据）交给 IP 层进⾏分⽚，会有什么异常呢？ </p>
<p>当 IP 层有⼀个超过 MTU ⼤⼩的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进⾏分⽚，把数据分⽚成 </p>
<p>若⼲⽚，保证每⼀个分⽚都⼩于 MTU。把⼀份 IP 数据报进⾏分⽚以后，由⽬标主机的 IP 层来进⾏᯿新组装后， </p>
<p>再交给上⼀层 TCP 传输层。 </p>
<p>这看起来井然有序，但这存在隐患的，<strong>那么当如果⼀个</strong> <strong>IP</strong> <strong>分⽚丢失，整个</strong> <strong>IP</strong> <strong>报⽂的所有分⽚都得重传</strong>。 </p>
<p>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。 </p>
<p>当接收⽅发现 TCP 报⽂（头部 + 数据）的某⼀⽚丢失后，则不会响应 ACK 给对⽅，那么发送⽅的 TCP 在超时后，就会重发「整个 TCP 报⽂（头部 + 数据）」。 </p>
<p>因此，可以得知由 IP 层进⾏分⽚传输，是⾮常没有效率的。 </p>
<p>所以，为了达到最佳的传输效能 TCP 协议在<strong>建⽴连接的时候通常要协商双⽅的</strong> <strong>MSS</strong> <strong>值</strong>，当 TCP 层发现数据超过 </p>
<p>MSS 时，则就先会进⾏分⽚，当然由它形成的 IP 包的⻓度也就不会⼤于 MTU ，⾃然也就不⽤ IP 分⽚了。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650181470913.png" alt="1650181470913" loading="lazy"></p>
<p>经过 TCP 层分⽚后，如果⼀个 TCP 分⽚丢失后，<strong>进⾏重发时也是以</strong> <strong>MSS</strong> <strong>为单位</strong>，⽽不⽤᯿传所有的分⽚，⼤⼤ 增加了重传的效率。</p>
<blockquote>
<p>什么是SYN攻击？如何避免SYN攻击？</p>
</blockquote>
<p><strong>SYN攻击</strong></p>
<p>我们都知道 TCP 连接建⽴是需要三次握⼿，假设攻击者短时间伪造不同 IP 地址的 SYN 报⽂，服务端每接收到 ⼀个 SYN 报⽂，就进⼊ SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报⽂，⽆法得到未知 IP 主机的 ACK 应答，久⽽久之就会<strong>占满服务端的</strong> <strong>SYN</strong> <strong>接收队列（未连接队列）</strong>，使得服务器不能为正常⽤户服务。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650182147347.png" alt="1650182147347" loading="lazy"></p>
<p><strong>避免SYN攻击方式一</strong></p>
<p>其中⼀种解决⽅式是通过修改 Linux 内核参数，控制队列⼤⼩和当队列满时应做什么处理。 </p>
<ul>
<li><p>当⽹卡接收数据包的速度⼤于内核处理的速度时，会有⼀个队列保存这些数据包。控制该队列的最⼤值如下 参数： </p>
<p>net.core.netdev_max_backlog </p>
</li>
<li><p>SYN_RCVD 状态连接的最⼤个数： </p>
<p>net.ipv4.tcp_max_syn_backlog</p>
</li>
<li><p>超出处理能时，对新的 SYN 直接回报 RST，丢弃连接： </p>
<p>net.ipv4.tcp_abort_on_overflow</p>
</li>
</ul>
<p><strong>避免SYN攻击方式二</strong></p>
<p>我们先来看下 Linux 内核的 SYN （未完成连接建⽴）队列与 Accpet （已完成连接建⽴）队列是如何⼯作的？</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650182291831.png" alt="1650182291831" loading="lazy"></p>
<p>正常流程： </p>
<ul>
<li><strong>当服务端接收到客户端的 SYN 报⽂时，会将其加⼊到内核的「 SYN 队列」；</strong> </li>
<li><strong>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报⽂；</strong> </li>
<li><strong>服务端接收到 ACK 报⽂后，从「 SYN 队列」移除放⼊到「 Accept 队列」；</strong> </li>
<li><strong>应⽤通过调⽤ accpet() socket 接⼝，从「 Accept 队列」取出连接。</strong></li>
</ul>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650182382267.png" alt="1650182382267" loading="lazy"></p>
<p>应用程序过慢：</p>
<ul>
<li><p>如果应用程序过慢时，就会导致Accept队列被占满</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650182471249.png" alt="1650182471249" loading="lazy"></p>
</li>
</ul>
<p>收到SYN攻击：</p>
<ul>
<li>如果不断受到SYN攻击，就会导致SYN队列占满。</li>
</ul>
<p>tcp_syncookies的方式可以应对SYN攻击方法：</p>
<p>net.ipv4.tcp_syncookies = 1</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650182602747.png" alt="1650182602747" loading="lazy"></p>
<ul>
<li>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进⼊「 SYN 队列」； </li>
<li>计算出⼀个 cookie 值，再以 SYN + ACK 中的「序列号」返回客户端， </li>
<li>服务端接收到客户端的应答报⽂时，服务器会检查这个 ACK 包的合法性。如果合法，直接放⼊到「 Accept 队列」。 </li>
<li>最后应⽤通过调⽤ accpet() socket 接⼝，从「 Accept 队列」取出的连接。</li>
</ul>
<h4 id="8-TCP断开连接"><a href="#8-TCP断开连接" class="headerlink" title="8.TCP断开连接"></a>8.TCP断开连接</h4><blockquote>
<p>TCP四次挥手过程和状态变迁</p>
</blockquote>
<p>天下没有不散的宴席，对于 TCP 连接也是这样， TCP 断开连接是通过<strong>四次挥⼿</strong>⽅式。 </p>
<p>双⽅都可以主动断开连接，断开连接后主机中的「资源」将被释放。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650182860327.png" alt="1650182860327" loading="lazy"></p>
<ul>
<li>客户端打算关闭连接，此时会发送⼀个 TCP ⾸部 FIN 标志位被置为 1 的报⽂，也即 FIN 报⽂，之后客户端进⼊ FIN_WAIT_1 状态。 </li>
<li>服务端收到该报⽂后，就向客户端发送 ACK 应答报⽂，接着服务端进⼊ CLOSED_WAIT 状态。 </li>
<li>客户端收到服务端的 ACK 应答报⽂后，之后进⼊ FIN_WAIT_2 状态。 </li>
<li>等待服务端处理完数据后，也向客户端发送 FIN 报⽂，之后服务端进⼊ LAST_ACK 状态。 </li>
<li>客户端收到服务端的 FIN 报⽂后，回⼀个 ACK 应答报⽂，之后进⼊ TIME_WAIT 状态 </li>
<li>服务器收到了 ACK 应答报⽂后，就进⼊了 CLOSED 状态，⾄此服务端已经完成连接的关闭。 </li>
<li>客户端在经过 2MSL ⼀段时间后，⾃动进⼊ CLOSED 状态，⾄此客户端也完成连接的关闭。</li>
</ul>
<p>每个⽅向都需要<strong>⼀个</strong> <strong>FIN</strong> <strong>和⼀个</strong> <strong>ACK</strong>，因此通常被称为<strong>四次挥⼿</strong>。</p>
<p>这⾥⼀点需要注意是：<strong>主动关闭连接的，才有</strong> <strong>TIME_WAIT</strong> <strong>状态。</strong></p>
<blockquote>
<p>为什么挥手需要四次</p>
</blockquote>
<p>再来回顾下四次挥⼿双⽅发 FIN 包的过程，就能理解为什么需要四次了。 </p>
<ul>
<li>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 </li>
<li>服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂，⽽服务端可能还有数据需要处理和发送，等 服务端不再发送数据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接。 </li>
</ul>
<p>从上⾯过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN ⼀般都会分开发送，从⽽⽐三次握⼿导致多了⼀次。</p>
<blockquote>
<p>为什么TIME_WAIT等待时间时2MSL？</p>
</blockquote>
<p>MSL是Maximum Segment Lifetime，<strong>报⽂最⼤⽣存时间</strong>，它是任何报⽂在⽹络上存在的最⻓时间，超过这个时 间报⽂将被丢弃。因为 TCP 报⽂基于是 IP 协议的，⽽ IP 头中有⼀个 TTL 字段，是 IP 数据报可以经过的最⼤路 由数，每经过⼀个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报⽂通知源主机。</p>
<p>MSL 与 TTL 的区别： MSL 的单位是时间，⽽ TTL 是经过路由跳数。所以 <strong>MSL</strong> <strong>应该要⼤于等于</strong> <strong>TTL</strong> <strong>消耗为</strong> <strong>0</strong> <strong>的时间</strong>，以确保报⽂已被⾃然消亡。</p>
<p>TIME_WAIT 等待 2 倍的 MSL，⽐较合理的解释是： ⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包 被接收⽅处理后⼜会向对⽅发送响应，所以<strong>⼀来⼀回需要等待</strong> <strong>2</strong> <strong>倍的时间</strong>。</p>
<p>2MSL 的时间是从<strong>客户端接收到</strong> <strong>FIN</strong> <strong>后发送</strong> <strong>ACK</strong> <strong>开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端⼜接收到了服务端重发的 FIN 报⽂，那么 <strong>2MSL</strong> <strong>时间将重新计时</strong>。 </p>
<p>在 Linux 系统⾥ 2MSL 默认是 60 秒，那么⼀个 MSL 也就是 30 秒。<strong>Linux</strong> <strong>系统停留在</strong> <strong>TIME_WAIT</strong> <strong>的时间为固定的</strong> <strong>60</strong> <strong>秒</strong>。 </p>
<p>其定义在 Linux 内核代码⾥的名称为 TCP_TIMEWAIT_LEN：</p>
<p>#define TCP_TIMEWAIT_LEN (60<em>HZ) /</em> how long to wait to destroy TIME-WAIT state, about 60 seconds */</p>
<p>如果要修改 TIME_WAIT 的时间⻓度，只能修改 Linux 内核代码⾥ TCP_TIMEWAIT_LEN 的值，并重新编译 Linux 内核。 </p>
<blockquote>
<p>为什么需要TIME_WAIT状态？</p>
</blockquote>
<p>主动发起关闭连接的⼀⽅，才会有 TIME-WAIT 状态。 </p>
<p>需要 TIME-WAIT 状态，主要是两个原因：</p>
<ul>
<li>防止具有相同 四元组 的旧数据包被收到</li>
<li>保证 被动关闭连接的一方能正确关闭，即保证最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正常关闭；</li>
</ul>
<p>原因⼀：防⽌旧连接的数据包</p>
<p>假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发⽣什么呢？<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650765674220.png" alt="1650765674220" loading="lazy"></p>
<ul>
<li>如上图⻩⾊框框服务端在关闭连接之前发送的 SEQ = 301 报⽂，被⽹络延迟了。 </li>
<li>这时有相同端⼝的 TCP 连接被复⽤后，被延迟的 SEQ = 301 抵达了客户端，那么客户端是有可能正常接收这个过期的报⽂，这就会产⽣数据错乱等严᯿的问题。</li>
</ul>
<p>所以，TCP 就设计出了这么⼀个机制，经过 2MSL 这个时间，<strong>⾜以让两个⽅向上的数据包都被丢弃，使得原来连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣的。</strong></p>
<p>原因⼆：保证连接正确关闭</p>
<p>TIME-WAIT 作⽤是<strong>等待⾜够的时间以确保最后的</strong> <strong>ACK</strong> <strong>能让被动关闭⽅接收，从⽽帮助其正常关闭。</strong> </p>
<p>假设 TIME-WAIT 没有等待时间或时间过短，断开连接会造成什么问题呢？</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650765761136.png" alt="1650765761136" loading="lazy"></p>
<p>如上图红⾊框框客户端四次挥⼿的最后⼀个 ACK 报⽂如果在⽹络中被丢失了，此时如果客户端 TIME-WAIT 过短或没有，则就直接进⼊了 CLOSED 状态了，那么服务端则会⼀直处在 LASE_ACK 状态。 </p>
<p>当客户端发起建⽴连接的 SYN 请求报⽂后，服务端会发送 RST 报⽂给客户端，连接建⽴的过程就会被 终⽌。</p>
<p>如果 TIME-WAIT 等待⾜够⻓的情况就会遇到两种情况： </p>
<ul>
<li>服务端正常收到四次挥⼿的最后⼀个 ACK 报⽂，则服务端正常关闭连接。 </li>
<li>服务端没有收到四次挥⼿的最后⼀个 ACK 报⽂时，则会᯿发 FIN 关闭连接报⽂并等待新的 ACK 报 ⽂。 </li>
</ul>
<p>所以客户端在 TIME-WAIT 状态等待 2MSL 时间后，就可以<strong>保证双⽅的连接都可以正常的关闭。</strong></p>
<blockquote>
<p>TIME_WAIT过多危害</p>
</blockquote>
<p>如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器⽅主动发起的断开请求。 </p>
<p>过多的 TIME-WAIT 状态主要的危害有两种： </p>
<ul>
<li>第⼀是内存资源占⽤； </li>
<li>第⼆是对端⼝资源的占⽤，⼀个 TCP 连接⾄少消耗⼀个本地端⼝；</li>
</ul>
<p>第⼆个危害是会造成严᯿的后果的，要知道，端⼝资源也是有限的，⼀般可以开启的端⼝为 32768～61000 ，也 </p>
<p>可以通过如下参数设置指定 net.ipv4.ip_local_port_range</p>
<p><strong>如果发起连接⼀⽅的</strong> <strong>TIME_WAIT</strong> <strong>状态过多，占满了所有端⼝资源，则会导致⽆法创建新连接。</strong></p>
<p>客户端受端⼝资源限制： </p>
<ul>
<li>客户端TIME_WAIT过多，就会导致端⼝资源被占⽤，因为端⼝就65536个，被占满就会导致⽆法创建新的连接。 </li>
</ul>
<p>服务端受系统资源限制： </p>
<ul>
<li>由于⼀个四元组表示 TCP 连接，理论上服务端可以建⽴很多连接，服务端确实只监听⼀个端⼝ 但是会把连接扔给处理线程，所以理论上监听的端⼝可以继续监听。但是线程池处理不了那么多⼀直不断的连接了。所以当服务端出现⼤ᰁ TIME_WAIT 时，系统资源被占满时，会导致处理不过来新的连接。</li>
</ul>
<h3 id="重传机制、滑动窗口、流量控制、拥塞控制"><a href="#重传机制、滑动窗口、流量控制、拥塞控制" class="headerlink" title="重传机制、滑动窗口、流量控制、拥塞控制"></a>重传机制、滑动窗口、流量控制、拥塞控制</h3><h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><blockquote>
<p>TCP 实现可靠传输的⽅式之⼀，是通过序列号与确认应答。</p>
<p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回⼀个确认应答消息，表示已收到消息。</p>
</blockquote>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650766348779.png" alt="1650766348779" loading="lazy"></p>
<p>但在错综复杂的⽹络，并不⼀定能如上图那么顺利能正常的数据传输，万⼀数据在传输过程中丢失了呢？ </p>
<p>所以 TCP 针对数据包丢失的情况，会⽤<strong>重传机制</strong>解决。</p>
<p>常见重传机制：</p>
<ul>
<li>超时重传 </li>
<li>快速重传 </li>
<li>SACK </li>
<li>D-SACK</li>
</ul>
<h5 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h5><p>发送数据时，设定一个定时器，当超过指定时间后，没有收到对方的ack确认应答报文，就会重发该数据，就是超时重传</p>
<p>TCP 会在以下两种情况发⽣超时重传： </p>
<ul>
<li>数据包丢失 </li>
<li>确认应答丢失</li>
</ul>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650766543494.png" alt="1650766543494" loading="lazy"></p>
<blockquote>
<p>超时时间应该设置为多少</p>
</blockquote>
<p>了解⼀下什么是 RTT （Round-Trip Time 往返时延），从下图我们就可以知道：<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650766618698.png" alt="1650766618698" loading="lazy"></p>
<p>RTT就是数据包的往返时间。</p>
<p>超时重传时间以RTO表示，假设在重传情况下，超时时间RTO较长或较短，会怎样？<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650766728909.png" alt="1650766728909" loading="lazy"></p>
<p>上图有两种情况：</p>
<ul>
<li>当超时时间 <strong>RTO</strong> <strong>较⼤</strong>时，᯿发就慢，丢了⽼半天才᯿发，没有效率，性能差； </li>
<li>当超时时间 <strong>RTO</strong> <strong>较⼩</strong>时，会导致可能并没有丢就᯿发，于是᯿发的就快，会增加⽹络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>根据上述的两种情况，我们可以得知，<strong>超时重传时间</strong> <strong>RTO</strong> <strong>的值应该略⼤于报⽂往返</strong> <strong>RTT</strong> <strong>的值</strong>。</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650766831637.png" alt="1650766831637" loading="lazy"></p>
<h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><p>快速重传不以时间为驱动，而是以数据驱动重传。</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650766941214.png" alt="1650766941214" loading="lazy"></p>
<p>如上图，发送方发出了1，2，3，4，5份数据：</p>
<ul>
<li>在第一份Seq1先发送到了，于是Ack就回2；</li>
<li>结果Seq2因为某些原因没收到，Seq3先到达了，于是还是Ack回2；</li>
<li>后面的Seq4，5都到了，但Ack还是回2，因为Seq2没收到；</li>
<li>发送端收到了三个Ack=2的确认，知道了Seq2没有收到，就在定时器过期之前，重传丢失的Seq2.</li>
<li>最后，收到了Seq2，此时因为Seq3，4，5都收到了，于是Ack就回6</li>
</ul>
<p>所以，快速᯿传的⼯作⽅式是当收到三个相同的 ACK 报⽂时，会在定时器过期之前，重传丢失的报⽂段。</p>
<p>快速᯿传机制只解决了⼀个问题，就是超时时间的问题，但是它依然⾯临着另外⼀个问题。就是<strong>重传的时候，是重传之前的⼀个，还是重传所有的问题。</strong></p>
<p>⽐如对于上⾯的例⼦，是重传 Seq2 呢？还是᯿传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。</p>
<p>为了解决不知道该重传哪些TCP报文，于是就有<strong>SACK</strong>方法。</p>
<h5 id="SACK方法"><a href="#SACK方法" class="headerlink" title="SACK方法"></a>SACK方法</h5><p>还有一种实现超时重传的方法叫SACK（选择性确认）</p>
<p>这种方式需要在TCP头部的选项字段里加一个SACK的东西，它可以将缓存地图发给发送方，这样发送方就知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p>
<p>如下图，发送⽅收到了三次同样的 ACK 确认报⽂，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则᯿发时，就只选择了这个 TCP 段进⾏重发</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650767685736.png" alt="1650767685736" loading="lazy"></p>
<p>如果要⽀持 SACK ，必须双⽅都要⽀持。在 Linux 下，可以通过 net.ipv4.tcp_sack 参数打开这个功能（Linux 2.4 后默认打开）。</p>
<h5 id="D-SACK-Duplicate-SACK"><a href="#D-SACK-Duplicate-SACK" class="headerlink" title="D-SACK(Duplicate SACK)"></a>D-SACK(Duplicate SACK)</h5><p>D-SACK主要使用了SACK来告诉发送方有哪些数据重复接收了</p>
<p>下面举两个例子</p>
<p>例子一：ACK丢包<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650767893978.png" alt="1650767893978" loading="lazy"></p>
<ul>
<li>接收方发给发送方的两个ACK确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000-3499）</li>
<li>于是接收方发现数据时重复收到的，于是回了一个SACK=3000-3500，告诉发送方3000-3500的数据已接受了，因为ACK到了4000，意味着4000之前的数据都接收了，所以这个的ACK代表D-SACK</li>
<li>这样发送方就知道了，数没有丢失，是接受放的ACK确认报文丢失</li>
</ul>
<p>例子二：网络延时</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650768177797.png" alt="1650768177797" loading="lazy"></p>
<ul>
<li>数据包（1000~1499） 被⽹络延迟了，导致「发送⽅」没有收到 Ack 1500 的确认报⽂。 </li>
<li>⽽后⾯报⽂到达的三个相同的 ACK 确认报⽂，就触发了快速重传机制，但是在重复传后，被延迟的数据包 （1000~1499）⼜到了「接收⽅」； </li>
<li><strong>所以「接收⽅」回了⼀个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。</strong></li>
<li>这样发送⽅就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，⽽是因为⽹络 延迟了。</li>
</ul>
<p>可⻅， D-SACK 有这么⼏个好处： </p>
<ol>
<li><p>可以让「发送⽅」知道，是发出去的包丢了，还是接收⽅回应的 ACK 包丢了; </p>
</li>
<li><p>可以知道是不是「发送⽅」的数据包被⽹络延迟了; </p>
</li>
<li><p>可以知道⽹络中是不是把「发送⽅」的数据包给复制了; </p>
</li>
</ol>
<p>在 Linux 下可以通过 net.ipv4.tcp_dsack 参数开启/关闭这个功能（Linux 2.4 后默认打开）。</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><blockquote>
<p>我们知道TCP是没发送一个数据，就进行一次确认应答，当上一个数据包收到应答，才发送下一个。这个模式就有点像我和你⾯对⾯聊天，你⼀句我⼀句。但这种⽅式的缺点是效率⽐较低的。 </p>
<p>如果你说完⼀句话，我在处理其他事情，没有及时回复你，那你不是要⼲等着我做完其他事情后，我回复你，你才能说下⼀句话，很显然这不现实。</p>
</blockquote>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650768510654.png" alt="1650768510654" loading="lazy"></p>
<p>这样的传输方式有一个缺点：数据包的往返时延越长，通信效率越低。</p>
<p>为此，TCP引入窗口的概念。即使在往返时间较长的情况下，也不会降低通信的效率。</p>
<p>难么，有了窗口，就要有窗口大小，窗口大小指的是无需等待确认应答，而可以连续发送数据的最大值。</p>
<p>窗口的实现实际上是操作系统开辟了一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓存区保留发送的数据，如果按期说到确认应答就可以清除。</p>
<p>假设窗⼝⼤⼩为 3 个 TCP 段，那么发送⽅就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以 </p>
<p>通过「下⼀个确认应答进⾏确认」。如下图：</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650769004407.png" alt="1650769004407" loading="lazy"></p>
<p>图中的ACK600确认应答报文丢失，也没关系。因为可以通过下一个确认应答进行确认，只要发送方收到700确认应答，就以为着700之前的数据被接收方收到，这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p>
<blockquote>
<p>窗口大小由哪一方决定</p>
</blockquote>
<p>TCP头部有一个字段叫Window，也就是窗口大小。</p>
<p><strong>这个字段是接收端告诉发送端⾃⼰还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能⼒来发送数据，⽽不会导致接收端处理不过来。</strong></p>
<p>所以，通常窗口大小由接收方的窗口大小决定</p>
<p>发送放发送的数据大小不能超过接收方的窗口大小，或者接收方无法正常接收数据</p>
<blockquote>
<p>发送方的滑动窗口</p>
</blockquote>
<p>下图是发送方缓存的数据，根据处理情况分成四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650850040631.png" alt="1650850040631" loading="lazy"></p>
<ul>
<li>1是已发送并受到ACK确认的数据：1-31字节</li>
<li>2是已发送但未收到ACK确认的数据：32-45字节</li>
<li>3是未发送但总大小再接收方处理范围内(接收方还有空间)：46-51</li>
<li>4是未发送但总大小超过接收方处理范围(接收方没有空间)：52-以后</li>
</ul>
<p>如下图，当发送方把数据全部发送出去，可用窗口的大小就为0了。表明可用窗口用尽了，再没有到ACK确认之前无法继续发送数据</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650850498501.png" alt="1650850498501" loading="lazy"></p>
<p>在下图，当收到之前发送的数据 32<del>36 字节的 ACK 确认应答后，如果发送窗⼝的⼤⼩没有变化，则<strong>滑动窗口往右边移动</strong> <strong>5</strong> <strong>个字节，因为有</strong> <strong>5</strong> <strong>个字节的数据被应答确认</strong>，接下来 52</del>56 字节⼜变成了可⽤窗⼝，那么后续也就 可以发送 52~56 这 5 个字节的数据了。</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650850544506.png" alt="1650850544506" loading="lazy"></p>
<blockquote>
<p>程序如何表示发送方的四个部分</p>
</blockquote>
<p>TCP滑动窗口使用三个指针来跟踪在四个传输类别中的每一个类别中的字节，其中两个指针是绝对指针(指特定的序列号)一个是相对指针(需要做偏移)。</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650850812912.png" alt="1650850812912" loading="lazy"></p>
<ul>
<li>SND.WND：表示发送窗口的大小（大小由接收方指定）</li>
<li>SND.UNA：是一个绝对指针，它所指向的是已发送但未收到确认的第一个字节的序列号</li>
<li>SND.NXT：也是一个绝对指针，它指向未发送但在可发送范围的第一个字节的序列号</li>
<li>指向4的第一个字节的是相对指针，需要SND,UNA指针加上SND.WND大小的偏移量，就可以指向</li>
</ul>
<p>可用窗口大小 = SND.WND-(SND.NXT-SND.UNA)</p>
<blockquote>
<p>接收方的滑动窗口</p>
</blockquote>
<p>按照处理情况划分成三个部分：</p>
<ul>
<li>1*2是以成功接收并确认的数据（等待应用进程读取）</li>
<li>3是未收到数据但可以接收的数据</li>
<li>4是未收到数据并不可以接收的数据</li>
</ul>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650851343072.png" alt="1650851343072" loading="lazy"></p>
<p>使用连个指针划分：</p>
<ul>
<li>RCV.WND ：表示接收窗⼝的⼤⼩，它会通告给发送⽅。 </li>
<li>RCV.NXT ：是⼀个指针，它指向期望从发送⽅发送来的下⼀个数据字节的序列号，也就是 #3 的第⼀个字节。 </li>
<li>指向 #4 的第⼀个字节是个相对指针，它需要 RCV.NXT 指针加上 RCV.WND ⼤⼩的偏移量，就可以指向 4 的第⼀个字节了。</li>
</ul>
<blockquote>
<p>接收窗口和发送窗口的大小是相等的吗</p>
</blockquote>
<p>并不是完全相等，接收窗⼝的⼤⼩是<strong>约等于</strong>发送窗⼝的⼤⼩的。 </p>
<p>因为滑动窗⼝并不是⼀成不变的。⽐如，当接收⽅的应⽤进程读取数据的速度⾮常快的话，这样的话接收窗⼝可以很快的就空缺出来。那么新的接收窗⼝⼤⼩，是通过 TCP 报⽂中的 Windows 字段来告诉发送⽅。那么这个传输过程是存在时延的，所以接收窗⼝和发送窗⼝是约等于的关系。</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>发送方不能无脑发送数据给接收方，要考虑接收方处理能力。</p>
<p>如果⼀直⽆脑的发数据给对⽅，但对⽅处理不过来，那么就会导致触发重发机制，从⽽导致⽹络流ᰁ的⽆端的浪费。</p>
<p>为了解决这种现象发⽣，<strong>TCP</strong> <strong>提供⼀种机制可以让「发送⽅」根据「接收⽅」的实际接收能⼒控制发送的数据量这就是所谓的流量控制。</strong></p>
<p>举例：</p>
<ul>
<li>客户端是接收方，服务端是发送方</li>
<li>假设接收窗口和发送窗口相同，都为200</li>
<li>假设两个设备在整个传输过程中都保持相同的窗口大小，不受外界影响</li>
</ul>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650851841672.png" alt="1650851841672" loading="lazy"></p>
<p>根据上图的流ᰁ控制，说明下每个过程： </p>
<ol>
<li><p>客户端向服务端发送请求数据报⽂。这⾥要说明下，本次例⼦是把服务端作为发送⽅，所以没有画出服务端的接收窗⼝。 </p>
</li>
<li><p>服务端收到请求报⽂后，发送确认报⽂和 80 字节的数据，于是可⽤窗⼝ Usable 减少为 120 字节，同时SND.NXT 指针也向右偏移 80 字节后，指向 321，<strong>这意味着下次发送数据的时候，序列号是</strong> <strong>321****。</strong> </p>
</li>
<li><p>客户端收到 80 字节数据后，于是接收窗⼝往右移动 80 字节， RCV.NXT 也就指向 321，<strong>这意味着客户端期望的下⼀个报⽂的序列号是</strong> <strong>321</strong>，接着发送确认报⽂给服务端。 </p>
</li>
<li><p>服务端再次发送了 120 字节数据，于是可⽤窗⼝耗尽为 0，服务端⽆法再继续发送数据。 </p>
</li>
<li><p>客户端收到 120 字节的数据后，于是接收窗⼝往右移动 120 字节， RCV.NXT 也就指向 441，接着发送确认报⽂给服务端。 </p>
</li>
<li><p>服务端收到对 80 字节数据的确认报⽂后， SND.UNA 指针往右偏移后指向 321，于是可⽤窗⼝ Usable增⼤到 80。 </p>
</li>
<li><p>服务端收到对 120 字节数据的确认报⽂后， SND.UNA 指针往右偏移后指向 441，于是可⽤窗⼝ Usable增⼤到 200。 </p>
</li>
<li><p>服务端可以继续发送了，于是发送了 160 字节的数据后， SND.NXT 指向 601，于是可⽤窗⼝ Usable 减少到 40。 </p>
</li>
<li><p>客户端收到 160 字节后，接收窗⼝往右移动了 160 字节， RCV.NXT 也就是指向了 601，接着发送确认报⽂给服务端。 </p>
</li>
<li><p>服务端收到对 160 字节数据的确认报⽂后，发送窗⼝往右移动了 160 字节，于是 SND.UNA 指针偏移了160 后指向 601，可⽤窗⼝ Usable 也就增⼤⾄了 200。</p>
</li>
</ol>
<p><strong>操作系统缓冲区和滑动窗口的关系</strong></p>
<p>前⾯的流量控制例⼦，我们假定了发送窗⼝和接收窗⼝是不变的，但是实际上，发送窗⼝和接收窗⼝中所存放的字节数，都是放在操作系统内存缓冲区中的，⽽操作系统的缓冲区，会<strong>被操作系统调整</strong>。 </p>
<p>当应⽤进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响</p>
<blockquote>
<p>那操作系统的缓冲区，是如何影响发送窗⼝和接收窗⼝的呢？</p>
</blockquote>
<p>当应用程序没有即使读取缓存时，发送窗口和接收敞口的变化。</p>
<p>考虑一下场景：</p>
<ul>
<li>客户端作为发送方，服务端作为接收端，发送窗口和接收窗口大小300</li>
<li>服务端非常繁忙，当收到客户端数据时，应用层不能及时读取数据</li>
</ul>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650936953548.png" alt="1650936953548" loading="lazy"></p>
<p>根据上图的流ᰁ控制，说明下每个过程：</p>
<p>   1.客户端发送 140 字节数据后，可⽤窗⼝变为 220 （360 - 140）。 </p>
<ol start="2">
<li><p>服务端收到 140 字节数据，<strong>但是服务端⾮常繁忙，应⽤进程只读取了</strong> <strong>40</strong> <strong>个字节，还有</strong> <strong>100</strong> <strong>字节占⽤着缓冲区，于是接收窗⼝收缩到了</strong> <strong>260</strong> <strong>（<strong><strong>360 - 100</strong></strong>）</strong>，最后发送确认信息时，将窗⼝⼤⼩通告给客户端。 </p>
</li>
<li><p>客户端收到确认和窗⼝通告报⽂后，发送窗⼝减少为 260。 </p>
</li>
<li><p>客户端发送 180 字节数据，此时可⽤窗⼝减少到 80。 </p>
</li>
<li><p>服务端收到 180 字节数据，<strong>但是应⽤程序没有读取任何数据，这</strong> <strong>180</strong> <strong>字节直接就留在了缓冲区，于是接收窗⼝收缩到了</strong> <strong>80</strong> <strong>（<strong><strong>260 - 180</strong></strong>）</strong>，并在发送确认信息时，通过窗⼝⼤⼩给客户端。 </p>
</li>
<li><p>客户端收到确认和窗⼝通告报⽂后，发送窗⼝减少为 80。 </p>
</li>
<li><p>客户端发送 80 字节数据后，可⽤窗⼝耗尽。 </p>
</li>
<li><p>服务端收到 80 字节数据，<strong>但是应⽤程序依然没有读取任何数据，这</strong> <strong>80</strong> <strong>字节留在了缓冲区，于是接收窗口收缩到了</strong> <strong>0</strong>，并在发送确认信息时，通过窗⼝⼤⼩给客户端。 </p>
</li>
<li><p>客户端收到确认和窗⼝通告报⽂后，发送窗⼝减少为 0。</p>
</li>
</ol>
<p>可见最后窗口都收缩为0，也就是发生了窗口关闭。当发送方可用窗口变为0时，发送方实际上会定时发送探测报文，以便知道接收方的窗口是否发生了变化。</p>
<p><strong>第二个例子</strong></p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650937429026.png" alt="1650937429026" loading="lazy"></p>
<p>说明下过程：</p>
<ol>
<li><p>客户端发送 140 字节的数据，于是可⽤窗⼝减少到了 220。 </p>
</li>
<li><p><strong>服务端因为现在⾮常的繁忙，操作系统于是就把接收缓存减少了</strong> <strong>120</strong> <strong>字节，当收到</strong> <strong>140</strong> <strong>字节数据后，⼜因为应⽤程序没有读取任何数据，所以</strong> <strong>140</strong> <strong>字节留在了缓冲区中，于是接收窗⼝⼤⼩从</strong> <strong>360</strong> <strong>收缩成了</strong> <strong>100</strong>，最后发送确认信息时，通告窗⼝⼤⼩给对⽅。 </p>
</li>
<li><p>此时客户端因为还没有收到服务端的通告窗⼝报⽂，所以不知道此时接收窗⼝收缩成了 100，客户端只会看⾃⼰的可⽤窗⼝还有 220，所以客户端就发送了 180 字节数据，于是可⽤窗⼝减少到 40。 </p>
</li>
<li><p>服务端收到了 180 字节数据时，<strong>发现数据⼤⼩超过了接收窗⼝的⼤⼩，于是就把数据包丢失了。</strong> </p>
</li>
<li><p>客户端收到第 2 步时，服务端发送的确认报⽂和通告窗⼝报⽂，尝试减少发送窗⼝到 100，把窗⼝的右端向左收缩了 80，此时可⽤窗⼝的⼤⼩就会出现诡异的负值。所以，如果发⽣了先减少缓存，再收缩窗⼝，就会出现丢包的现象。</p>
</li>
</ol>
<p><strong>为了防止出现减少缓存同时收缩窗口的丢包现象，TCP规定不允许同时减少缓存又收缩窗口，而是采用先收缩窗口，过段时间减少缓存。</strong></p>
<h5 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a><strong>窗口关闭</strong></h5><p>在前⾯我们都看到了，TCP 通过让接收⽅指明希望从发送⽅接收的数据⼤⼩（窗⼝⼤⼩）来进⾏流量控制。 </p>
<p><strong>如果窗⼝⼤⼩为</strong> <strong>0</strong> <strong>时，就会阻⽌发送⽅给接收⽅传递数据，直到窗⼝变为⾮</strong> <strong>0</strong> <strong>为⽌，这就是窗⼝关闭</strong></p>
<blockquote>
<p>窗口关闭潜在危险</p>
</blockquote>
<p>接收⽅向发送⽅通告窗⼝⼤⼩时，是通过 ACK 报⽂来通告的</p>
<p>那么，当发⽣窗⼝关闭时，接收⽅处理完数据后，会向发送⽅通告⼀个窗⼝⾮ 0 的 ACK 报⽂，如果这个通告窗⼝的 ACK 报⽂在⽹络中丢失了，那麻烦就⼤了。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650937964190.png" alt="1650937964190" loading="lazy"></p>
<p>此时会导致，发送方一直等待接收方的非0窗口通知，接收方也一直等待发送方发送的数据，如果不采取措施，这种互相等待的过程，会造成死锁的现象。</p>
<blockquote>
<p>如何解决窗口关闭时，潜在的死锁现象？</p>
</blockquote>
<p>为了解决这个问题，TCP为每个连接设有一个持续定时器，只要tcp连接的一方收到对方的零窗口通知，就启动持续计时器。</p>
<p>如果持续计时器超时，就会发送窗口探测报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650938280921.png" alt="1650938280921" loading="lazy"></p>
<ul>
<li>如果接收窗⼝仍然为 0，那么收到这个报⽂的⼀⽅就会᯿新启动持续计时器； </li>
<li>如果接收窗⼝不是 0，那么死锁的局⾯就可以被打破了。</li>
</ul>
<p>窗⼝探测的次数⼀般为 3 次，每次⼤约 30-60 秒（不同的实现可能会不⼀样）。如果 3 次过后接收窗⼝还是 0 的话，有的 TCP 实现就会发 <strong>RST 报⽂来中断连接。</strong></p>
<h5 id="糊涂窗口综合征"><a href="#糊涂窗口综合征" class="headerlink" title="糊涂窗口综合征"></a>糊涂窗口综合征</h5><p>如果接收⽅太忙了，来不及取⾛接收窗⼝⾥的数据，那么就会导致发送⽅的发送窗⼝越来越⼩。 </p>
<p>到最后，<strong>如果接收⽅腾出⼏个字节并告诉发送⽅现在有⼏个字节的窗⼝，⽽发送⽅会义⽆反顾地发送这⼏个字节，这就是糊涂窗⼝综合症</strong>。 </p>
<p>要知道，我们的 TCP + IP 头有 40 个字节，为了传输那⼏个字节的数据，要达上这么⼤的开销，这太不经济了。 </p>
<p>就好像⼀个可以承载 50 ⼈的⼤巴⻋，每次来了⼀两个⼈，就直接发⻋。除⾮家⾥有矿的⼤巴司机，才敢这样玩， </p>
<p>不然迟早破产。要解决这个问题也不难，⼤巴司机等乘客数ᰁ超过了 25 个，才认定可以发⻋。 </p>
<p>现举个糊涂窗⼝综合症的栗⼦，考虑以下场景： </p>
<p>接收⽅的窗⼝⼤⼩是 360 字节，但接收⽅由于某些原因陷⼊困境，假设接收⽅的应⽤层读取的能⼒如下：</p>
<ul>
<li>接收方每接收3个字节，应用程序就只能从缓冲区读取1个字节的数据</li>
<li>在下一个发送方的tcp段到达之前，应用程序还从缓冲区读取了40个字节的数据</li>
</ul>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1650938528091.png" alt="1650938528091" loading="lazy"></p>
<p>可以发现，窗口不断减少，并且发送的数据都比较小的了，所以糊涂窗口综合征的现象是可以发生在发送方和接收方：</p>
<ul>
<li>接收方可以通告一个小的窗口</li>
<li>而发送方可以发送小数据</li>
</ul>
<p>于是，要解决糊涂窗口综合征，就解决上面两个问题</p>
<ul>
<li>让接收方不通告小窗口给发送方</li>
<li>让发送方避免发送小数据</li>
</ul>
<blockquote>
<p>怎么让接收方不通告小窗口呢</p>
</blockquote>
<p>接收⽅通常的策略如下: </p>
<p>当「窗⼝⼤⼩」⼩于 min( MSS，缓存空间/2 ) ，也就是⼩于 MSS 与 1/2 缓存⼤⼩中的最⼩值时，就会向发送⽅通告窗⼝为 0 ，也就阻⽌了发送⽅再发数据过来。 </p>
<p>等到接收⽅处理了⼀些数据后，窗⼝⼤⼩ &gt;= MSS，或者接收⽅缓存空间有⼀半可以使⽤，就可以把窗⼝打开让发送⽅发送数据过来。</p>
<blockquote>
<p>怎么避免发送方发送小数据呢</p>
</blockquote>
<p>发送⽅通常的策略: </p>
<p>使⽤ Nagle 算法，该算法的思路是延时处理，它满⾜以下两个条件中的⼀条才可以发送数据： </p>
<ul>
<li>要等到窗⼝⼤⼩ &gt;= <strong>MSS</strong> 或是 数据⼤⼩ &gt;= <strong>MSS</strong></li>
<li>收到之前发送数据的 <strong>ack</strong> 回包 </li>
</ul>
<p>只要没满⾜上⾯条件中的⼀条，发送⽅⼀直在囤积数据，直到满⾜上⾯的发送条件。 </p>
<p>另外，Nagle 算法默认是打开的，如果对于⼀些需要⼩数据包交互的场景的程序，⽐如，telnet 或 ssh 这样的交互性⽐较强的程序，则需要关闭 Nagle 算法。 </p>
<p>可以在 Socket 设置 <strong>TCP_NODELAY</strong> 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应⽤⾃⼰的特点来关闭）</p>
<p>setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char *)&amp;value, sizeof(int));</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><blockquote>
<p>为什么要拥塞控制，不是有流量控制了吗</p>
</blockquote>
<p>前面的流量控制是避免发送方数据填满接收方的缓存，但并不知道网络中发生了什么。一般来说，计算机完了过都处于共享的环境。因此也有可能会因为其他主机之间的通信使得⽹络拥堵。</p>
<p><strong>在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时</strong> <strong>TCP</strong> <strong>就会重传数据，但是⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进⼊恶性循环被不断地放⼤</strong><strong>….</strong></p>
<p>所以，TCP 不能忽略⽹络上发⽣的事，它被设计成⼀个⽆私的协议，当⽹络发送拥塞时，TCP 会⾃我牺牲，降低发送的数据量。 </p>
<p>于是，就有了<strong>拥塞控制</strong>，控制的⽬的就是<strong>避免「发送⽅」的数据填满整个⽹络。</strong> </p>
<p>为了在「发送⽅」调节所要发送数据的量，定义了⼀个叫做「<strong>拥塞窗⼝</strong>」的概念。</p>
<blockquote>
<p>什么是拥塞窗口？和发送窗口有什么关系？</p>
</blockquote>
<p><strong>拥塞窗口cwnd</strong>是发送方维护的一个状态变量，他会根据<strong>网络的拥塞程度动态变化。</strong></p>
<p>我们在前⾯提到过发送窗⼝ swnd 和接收窗⼝ rwnd 是约等于的关系，那么由于加⼊了拥塞窗⼝的概念后，此时发送窗⼝的值是swnd = min(cwnd, rwnd)，也就是拥塞窗⼝和接收窗⼝中的最⼩值。</p>
<p>拥塞窗口cwnd变化的规则：</p>
<ul>
<li>只要网络中没有出现拥塞，cwnd就会增大</li>
<li>但网络中出现了拥塞，cwnd就减少</li>
</ul>
<blockquote>
<p>怎么知道当前网络是否出现了拥塞？</p>
</blockquote>
<p>只要「发送⽅」没有在规定时间内接收到 ACK 应答报⽂，也就是<strong>发⽣了超时重传，就会认为⽹络出现了⽤拥塞。</strong></p>
<blockquote>
<p>拥塞控制有哪些控制算法？</p>
</blockquote>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><p>TCP刚建立连接完成后，首先是有个慢启动的过程，这个<strong>慢启动的意思就是一点一点的提高发送数据包的数量</strong>如果一开始就发送大量的数据，会容易给网络添堵。</p>
<p>慢启动的算法就记住一个规则：<strong>当发送方每收到一个ACK，拥塞窗口cwnd大小就加一。</strong></p>
<p>这里假定拥塞窗口cwnd和发送窗口swnd相等，举个栗子：</p>
<ul>
<li>连接建立完成后，一开始初始化cwnd=1，表示可以传一个MSS大小的数据</li>
<li>当收到一个ACK确认应答后，cwnd增加1，于是一次能够发送2个</li>
<li>当收到2个ack的确认应答后，cwnd增加2，于是就可以比之前多发2个，一次可以发4个</li>
<li>当这4个的ack确认应答到来的时候，每个确认cwnd增加1，4个确认cwnd增加4，于是可以比之前多发4个，一次发8个</li>
</ul>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651109430166.png" alt="1651109430166" loading="lazy"></p>
<p>可以看出慢启动算法，发包的个数是<strong>指数性的增长</strong></p>
<blockquote>
<p>那么慢启动涨到什么时候呢？</p>
</blockquote>
<p>有一个叫慢启动门限ssthresh（slow start threshold）状态变量</p>
<ul>
<li>当cwnd &lt; ssthresh时，使用<strong>慢启动算法</strong></li>
<li>当cwnd &gt;= ssthresh时，就会使用<strong>拥塞避免算法</strong></li>
</ul>
<h5 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h5><p>之前说到当拥塞窗口cwnd超过慢启动门限ssthresh就会进入拥塞避免算法。</p>
<p>一般来说ssthresh的大小是65535字节</p>
<p>那么进入拥塞避免算法后，他的规则是：<strong>每收到一个ack时，cwnd增加 1/cwnd</strong></p>
<p>接着上边慢启动的栗子，现规定ssthresh为8时：</p>
<ul>
<li>当8个ack应答确认到来时，每个确认增加1/8，8个ack确认cwnd增加1，于是一次就可以发9个MSS大小的数据，变成了<strong>线性增长</strong><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651109996567.png" alt="1651109996567" loading="lazy"></li>
</ul>
<p>所以发现：拥塞避免算法就是将原来慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了些</p>
<p>就这么一直增长，网络就会慢慢进入拥塞的状况，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p>
<p>当触发了重传机制，也就进入了拥塞发生算法</p>
<h5 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h5><p>当网络出现了拥塞，也就是会发生数据包重传，重传机制有两种：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
</ul>
<p>这两种使用的拥塞发送算法是不同的，</p>
<blockquote>
<p>发生超时重传的拥塞发生算法</p>
</blockquote>
<p>当发生了超时重传，就会使用拥塞发生算法。</p>
<p>当发生了超时重传，则就会使用拥塞发生算法。</p>
<p>这个时候，ssthresh和cwnd的值会发生改变：</p>
<ul>
<li>ssthresh设为cwnd/2</li>
<li>cwnd重置为1</li>
</ul>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651110475405.png" alt="1651110475405" loading="lazy"></p>
<p>接着，就重新开始慢启动，慢启动是会突然减少数据流的，这种方式太激进，反应也很强烈，会造成网络卡顿。</p>
<blockquote>
<p>发生快速重传的拥塞发生算法</p>
</blockquote>
<p>还有更好的方式，前面讲过快速重传算法，当接收方发现丢了一个中间包的时候，发送三次前一个包的ACK，于是发送端就会快速重传，不必等待超时再重传。</p>
<p>TCP认为这种情况不严重，因为大部分没丢，只丢了一小部分，则sssthresh和cwnd变化如下：</p>
<ul>
<li>cwnd = cwnd/2</li>
<li>ssthresh = cwnd</li>
<li>进入快速恢复算法</li>
</ul>
<h5 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h5><p>快速重传和快速恢复算法一般同时使用，快速恢复算法认为，还能收到3个重复ACK说明网络也不那么糟糕，所以没必要像RTO超时那么强烈</p>
<p>进入快速恢复算法如下：</p>
<ul>
<li>拥塞窗口 cwnd=ssthresh+3(意思是确认3个数据包被收到了)</li>
<li>重传丢失的数据包</li>
<li>如果再收到重复的ACK，那么cwnd增加1</li>
<li>如果收到新数据的ACK后，把cwnd设置为第一步中的ssthresh的值，原因是该ACK的值确认了新的数据，说明从duplicated ACK时的数据都已被收到，该恢复过程已经结束，可以回到恢复之前之前的状态了，即在此进入拥塞避免状态</li>
</ul>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651111474435.png" alt="1651111474435" loading="lazy"></p>
<h5 id="拥塞算法示意图"><a href="#拥塞算法示意图" class="headerlink" title="拥塞算法示意图"></a>拥塞算法示意图</h5><p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651111700981.png" alt="1651111700981" loading="lazy"></p>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="IP基础知识"><a href="#IP基础知识" class="headerlink" title="IP基础知识"></a>IP基础知识</h3><h4 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h4><p>IP在TCO/IP参考模型中处于第三层，也就是网络层。</p>
<blockquote>
<p>网络层主要作用是：实现主机间的通信，也叫点对点通信</p>
</blockquote>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651202363597.png" alt="1651202363597" loading="lazy"></p>
<blockquote>
<p>网络层与数据链路层有什么关系</p>
</blockquote>
<p>在上面可以知道IP的作用是主机间的通信，而<strong>MAC地址作用是实现直连的两个设备间通信，而IP负责在没有直连的两个网络之间通信传输</strong></p>
<p>举个栗子：⼩林要去⼀个很远的地⽅旅⾏，制定了⼀个⾏程表，其间需先后乘坐⻜机、地铁、公交⻋才能抵达⽬的地，为此⼩林需要买⻜机票，地铁票等。 </p>
<p>⻜机票和地铁票都是去往特定的地点的，每张票只能够在某⼀限定区间内移动，此处的「<strong>区间内」就如同通信⽹络中数据链路</strong>。</p>
<p>在区间内移动相当于数据链路层，充当区间两个节点传输的功能，区间内的出发点好比源MAC地址，目标地点好比目的MAC地址。</p>
<p>整个旅游行程表就相当于网络层，充当远程定位功能，形成的开始好比源IP，行程的终点好比目的IP地址<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651235128573.png" alt="1651235128573" loading="lazy"></p>
<p>只有既有某个区间的车票又有整个旅行的行程表，才能保证到达目的地，于此类似，计算机网络中也<strong>需要数据链路层和网络层这个分层才能实现最终目标地址的通信。</strong></p>
<p>还有᯿要⼀点，旅⾏途中我们虽然不断变化了交通⼯具，但是旅⾏⾏程的起始地址和⽬的地址始终都没变。其实， 在⽹络中数据包传输中也是如此，<strong>源IP地址和⽬标IP地址在传输过程中是不会变化的，只有源MAC地址和⽬标MAC⼀直在变化。</strong></p>
<h4 id="IP地址基础知识"><a href="#IP地址基础知识" class="headerlink" title="IP地址基础知识"></a>IP地址基础知识</h4><p>在TCP/IP网络通信中，为了保护能正常通信，每个设备都需要配置正确的IP地址。</p>
<blockquote>
<p>IP地址(IPv4)由32位正整数表示，在计算机是以二进制方式处理</p>
</blockquote>
<p>采用十进制方式，每8位为组，共为四组，每组以.隔开，转换为十进制</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651372998197.png" alt="1651372998197" loading="lazy"></p>
<p>那么，IP地址最大值就是<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651373019484.png" alt="1651373019484" loading="lazy"></p>
<p>实际上，IP 地址并不是根据主机台数来配置的，⽽是以⽹卡。像服务器、路由器等设备都是有 2 个以上的⽹卡，也就是它们会有 2 个以上的 IP 地址。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651373073865.png" alt="1651373073865" loading="lazy"></p>
<p>因此，让 43 亿台计算机全部连⽹其实是不可能的，更何况 IP 地址是由「⽹络标识」和「主机标识」这两个部分组成的，所以实际能够连接到⽹络的计算机个数更是少了很多。</p>
<h5 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h5><p>IP地址分成5种类型，A,B,C,D,E<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651373175721.png" alt="1651373175721" loading="lazy"></p>
<p>黄色部分为分类号，用以区分IP地址</p>
<blockquote>
<p>什么是A,B,C类地址</p>
</blockquote>
<p>其中对于 A、B、C 类主要分为两个部分，分别是<strong>⽹络号和主机号</strong>。这很好理解，好⽐⼩林是 A ⼩区 1 栋 101 号，你是 B ⼩区 1 栋 101 号。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651373299165.png" alt="1651373299165" loading="lazy"></p>
<blockquote>
<p>最大主机个数如何算的</p>
</blockquote>
<p>看主机号的位数，如C类地址主机号占8位，那么最大主机个数:<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651373380779.png" alt="1651373380779" loading="lazy"></p>
<p>为什么要减2？</p>
<p>在IP地址种，有两个IP是特殊的，分别是主机号全0和全1的，<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651373535944.png" alt="1651373535944" loading="lazy"></p>
<ul>
<li>主机号全为1指定某个网络下的所有主机，用于广播</li>
<li>主机号全为1指定某个网络</li>
</ul>
<p>因此在分配过程种应该去掉</p>
<blockquote>
<p>广播地址用于干什么</p>
</blockquote>
<p>广播地址用于在<strong>同一个链路中相互连接的主机之间发送数据包</strong></p>
<p>学校班级中就有⼴播的例⼦，在准备上课的时候，通常班⻓会喊：“上课， 全体起⽴！”，班⾥的同学听到这句话是 不是全部都站起来了？这个句话就有⼴播的含义。</p>
<p>当主机号全为1时，就表示该网络的广播地址。例如172.20.0.0/16 用二进制表示如下：10101100.00010100.00000000.00000000；将这个地址的主机部分全部改为1，形成广播地址：10101100.00010100. 11111111.11111111，再将这个地址转为十进制172.20.255.255 。</p>
<p>广播地址分为本地广播和直接广播两种。</p>
<ul>
<li>在本地广播的叫本地广播。例如⽹络地址为 192.168.0.0/24 的情况下，⼴播地址是 192.168.0.255 。因为这个⼴播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0/24 以外的其他链路上。</li>
<li>在不同网络间的广播叫直接广播。例如⽹络地址为 192.168.0.0/24 的主机向 192.168.1.255/24 的⽬标地址发送 IP 包。收到这个包的路由器，将数据转发给 192.168.1.0/24，从⽽使得所有192.168.1.1~192.168.1.254 的主机都能收到这个包（由于直接⼴播有⼀定的安全问题，多数情况下会在路由器上设置为不转发。） 。</li>
</ul>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651453559612.png" alt="1651453559612" loading="lazy"></p>
<blockquote>
<p>什么是D、E类地址？</p>
</blockquote>
<p>而D类和E类地址是没有主机号的，所以不可用于主机IP，D类常被用于多播，E类是预留的分类，暂时未使用。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651453640594.png" alt="1651453640594" loading="lazy"></p>
<blockquote>
<p>多播地址用于什么？</p>
</blockquote>
<p>多播用于将包发送给特定组内的所有主机。</p>
<p>还是举班级的栗⼦，⽼师说：“最后⼀排的同学，上来做这道数学题。”，⽼师指定的是最后⼀排的同学，也就是多播的含义了。</p>
<p>由于⼴播⽆法穿透路由，若想给其他⽹段发送同样的包，就可以使⽤可以穿透路由的多播<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651453756249.png" alt="1651453756249" loading="lazy"></p>
<p>多播使⽤的 D 类地址，其前四位是 1110 就表示是多播地址，⽽剩下的 28 位是多播的组编号。 </p>
<ul>
<li>从 224.0.0.0 ~ 239.255.255.255 都是多播的可⽤范围，其划分为以下三类：</li>
<li>224.0.0.0 ~ 224.0.0.255 为预留的组播地址，只能在局域⽹中，路由器是不会进⾏转发的。224.0.1.0 ~ 238.255.255.255 为⽤户可⽤的组播地址，可以⽤于 Internet 上。 </li>
<li>239.0.0.0 ~ 239.255.255.255 为本地管理组播地址，可供内部⽹在内部使⽤，仅在特定的本地范围内有效。</li>
</ul>
<blockquote>
<p>IP分类的优点</p>
</blockquote>
<p>不管是路由器还是主机解析到⼀个 IP 地址时候，我们判断其 IP 地址的⾸位是否为 0，为 0 则为 A 类地址，那么就能很快的找出⽹络地址和主机地址。</p>
<p>其余分类判断方式参考下图：<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651453958420.png" alt="1651453958420" loading="lazy"></p>
<p>所以这种分类地址的优点就是简单明了、选路(基于网络地址)简单。</p>
<blockquote>
<p>IP分类的缺点</p>
</blockquote>
<p><strong>缺点一</strong></p>
<p>同一网络下没有地址层次，⽐如⼀个公司⾥⽤了 B 类地址，但是可能需要根据⽣产环境、测试环境、开发环境来划分地址层次，⽽这种 IP 分类是没有地址层次划分的功能，所以这就<strong>缺少地址的灵活性</strong>。</p>
<p><strong>缺点二</strong></p>
<p>A、B、C类都不能很好的与现实网络匹配。</p>
<ul>
<li>C 类地址能包含的最⼤主机数ᰁ实在太少了，只有 254 个，估计⼀个⽹吧都不够⽤。 </li>
<li>⽽ B 类地址能包含的最⼤主机数⼜太多了，6 万多台机器放在⼀个⽹络下⾯，⼀般的企业基本达不到这个规模，闲着的地址就是浪费。</li>
</ul>
<p>这两个缺点都在CIDR无分类地址解决</p>
<h5 id="无分类地址CIDR"><a href="#无分类地址CIDR" class="headerlink" title="无分类地址CIDR"></a>无分类地址CIDR</h5><p>这种方式不再有分类地址的概念，32比特的IP地址被划分为两部分。前面是网络号，后面是主机号。</p>
<blockquote>
<p>怎么划分网络号和主机号</p>
</blockquote>
<p>表示形式 a.b.c.d/x ，其中 /x 表示前 x 位属于<strong>⽹络号</strong>， x 的范围是 0 ~ 32 ，这就使得 IP 地址更加具有灵活性。 </p>
<p>⽐如 10.100.122.2/24，这种地址表示形式就是 CIDR，/24 表示前 24 位是⽹络号，剩余的 8 位是主机号。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651454303719.png" alt="1651454303719" loading="lazy"></p>
<p>还有一种划分网络号与主机号的方式，那就是子网掩码。掩码的意思是涵盖掉主机号，剩余的就是网络号。</p>
<p><strong>将子网掩码和IP地址按位计算AND，得到网络号。</strong></p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651454438808.png" alt="1651454438808" loading="lazy"></p>
<blockquote>
<p>为什么要分离网络号和主机号</p>
</blockquote>
<p>因为两台计算机要通讯，首先判断是否在同一广播域内，即网络号是否相同。如果网络号相同，则表明接收方在本网络上，那么就可以把数据直接发送到目标主机。</p>
<p>路由器寻址⼯作中，也就是通过这样的⽅式来找到对应的⽹络号的，进⽽把数据包转发给对应的⽹络内。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651454608205.png" alt="1651454608205" loading="lazy"></p>
<blockquote>
<p>怎么进行子网划分？</p>
</blockquote>
<p>在上面我们知道可以通过子网掩码划分出网络号和主机号，实际上子网掩码还有一个作用，那就是划分子网。</p>
<p><strong>子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机部分</strong>形式如下：<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651454839878.png" alt="1651454839878" loading="lazy"></p>
<ul>
<li>未作子网划分的IP地址：网络地址和主机地址</li>
<li>做子网划分的IP地址：网络地址+（子网网络地址+子网主机地址）</li>
</ul>
<p>假设对C类地址进行子网划分，网络地址192.168.1.0，使用子网掩码255.255.255.0对其进行子网划分。C类地址中前24位是网络号，最后8位是主机位中借了两位作为子网号<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651456030778.png" alt="1651456030778" loading="lazy"></p>
<p>由于子网网络地址被划分为2位，那么子网地址就有4个，分别是00、01、10、11，具体划分如下：<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651456125470.png" alt="1651456125470" loading="lazy"></p>
<p>划分后的4个子网如下：<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651456163201.png" alt="1651456163201" loading="lazy"></p>
<h5 id="公有IP地址与私有IP地址"><a href="#公有IP地址与私有IP地址" class="headerlink" title="公有IP地址与私有IP地址"></a>公有IP地址与私有IP地址</h5><p>在A,B,C分类地址，实际上又分共有IP地址和私有IP地址。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651543397114.png" alt="1651543397114" loading="lazy"></p>
<p>平时我们办公室、家⾥、学校⽤的 IP 地址，⼀般都是私有 IP 地址。因为这些地址允许组织内部的 IT ⼈员⾃⼰管 理、⾃⼰分配，⽽且可以᯿复。因此，你学校的某个私有 IP 地址和我学校的可以是⼀样的。就像每个⼩区都有⾃⼰的楼编号和⻔牌号，你⼩区家可以叫 1 栋 101 号，我⼩区家也可以叫 1 栋 101，没有任何问题。但⼀旦出了⼩区，就需要带上中⼭路 666 号（公⽹ IP 地址），是国家统⼀分配的，不能两个⼩区都叫中⼭路 666。 </p>
<p>所以，公有 IP 地址是有个组织统⼀分配的，假设你要开⼀个博客⽹站，那么你就需要去申请购买⼀个公有 IP，这样全世界的⼈才能访问。并且公有 IP 地址基本上要在整个互联⽹范围内保持唯⼀。</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651543481810.png" alt="1651543481810" loading="lazy"></p>
<blockquote>
<p>公有IP地址由谁管理</p>
</blockquote>
<p>私有 IP 地址通常是内部的 IT ⼈员管理，公有 IP 地址是由 ICANN 组织管理，中⽂叫「互联⽹名称与数字地址分配机构」。 </p>
<p>IANA 是 ICANN 的其中⼀个机构，它负责分配互联⽹ IP 地址，是按州的⽅式层层分配。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651543531644.png" alt="1651543531644" loading="lazy"></p>
<ul>
<li>ARIN 北美地区 </li>
<li>LACNIC 拉丁美洲和⼀些加勒⽐群岛 </li>
<li>RIPE NCC 欧洲、中东和中亚 </li>
<li>AfriNIC ⾮洲地区 </li>
<li>APNIC 亚太地区</li>
</ul>
<p>其中，在中国是由 CNNIC 的机构进⾏管理，它是中国国内唯⼀指定的全局 IP 地址管理的组织。</p>
<h5 id="IP地址与路由控制"><a href="#IP地址与路由控制" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h5><p>IP地址的网络地址是用于进行路由控制。</p>
<p>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在主机和路由器上都会有各自的路由控制表。</p>
<p>在发送IP包时，首先确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。如果路由控制表中有多个网络地址的记录，就选择相同位数最多的网络地址，也就是最长匹配。</p>
<p>举例：<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651544139181.png" alt="1651544139181" loading="lazy"></p>
<p>1.主机A要发送一个IP包，其源地址是10.1.1.30和目标地址是10.1.2.10，由于没有在主机A的路由表中找到与目标地址10.1.2.10相同的网络地址，于是包被转发到默认路由（路由器1）</p>
<p>2.路由器1收到IP包后，也在路由器1的路由表匹配与目标地址相同的网络地址，发现匹配到了。于是就把IP数据包转发到10.1.0.2这台路由器2</p>
<p>3.路由器2收到后，同样对比自身路由表，发现匹配到了，于是把IP包从路由器2的10.1.2.1这个接口出去，最终经过交换机把IP数据包 转发到了目标主机</p>
<blockquote>
<p>环回地址是不会流向网络的</p>
</blockquote>
<p>环回地址是指同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。</p>
<p>计算机使用一个特殊IP地址127.0.0.1作为环回地址。与该地址具有相同意义的一个叫做localhost的主机名。使用这个IP或主机名时，数据包不会流向网络。</p>
<h5 id="IP分片与重组"><a href="#IP分片与重组" class="headerlink" title="IP分片与重组"></a>IP分片与重组</h5><p>每种数据链路的最大传输单元MTU都使不相同的，如FDDI数据链路MTU4352、以太网的MTU是1500字节等。</p>
<p>每种数据链路的MTU之所以不同，是因为 每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的MTU也就不同。</p>
<p>其中，最常见数据链路是以太网，MTU是1500字节。</p>
<p>那么<strong>当IP数据包大小大于MTU时，IP数据包就会分片</strong>。</p>
<p>经过分片之后的IP数据报在被重组时候，只能由目标主机进行，路由器是不会进行重组的。</p>
<p>假设发送方发送一个4000字节的大数据报，若要传输在以太网链路，则需要把数据报分片成3个小数据报进行传输，再由接收方重组大数据报。</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651544985173.png" alt="1651544985173" loading="lazy"></p>
<p>在分片传输过程中，一旦某个分片丢失，则会造成整个IP数据报作废，所以TCP引入了MSS也就是在TCP层进行分片不由IP层分片，那么对于UDP我们尽量不要发送一个大于MTU的数据报文。</p>
<h5 id="IPv6基本认识"><a href="#IPv6基本认识" class="headerlink" title="IPv6基本认识"></a>IPv6基本认识</h5><p>IPv4 的地址是 32 位的，⼤约可以提供 42 亿个地址，但是早在 2011 年 IPv4 地址就已经被分配完了。 </p>
<p>但是 IPv6 的地址是 128 位的，这可分配的地址数ᰁ是⼤的惊⼈，说个段⼦ <strong>IPv6</strong> <strong>可以保证地球上的每粒沙⼦都能被分配到⼀个</strong> <strong>IP</strong> <strong>地址。</strong> </p>
<p>但 IPv6 除了有更多的地址之外，还有更好的安全性和扩展性，说简单点就是 IPv6 相⽐于 IPv4 能带来更好的⽹络体验。 </p>
<p>但是因为 IPv4 和 IPv6 不能相互兼容，所以不但要我们电脑、⼿机之类的设备⽀持，还需要⽹络运营商对现有的设备进⾏升级，所以这可能是 IPv6 普及率⽐较慢的⼀个原因。</p>
<blockquote>
<p>IPv6亮点</p>
</blockquote>
<ul>
<li>IPv6不仅仅可分配地址变多，还有许多亮点：</li>
<li>IPv6 可⾃动配置，即使没有 DHCP 服务器也可以实现⾃动分配IP地址，真是<strong>便捷到即插即⽤</strong>啊。 </li>
<li>IPv6 包头包⾸部⻓度采⽤固定的值 40 字节，去掉了包头校验和，简化了⾸部结构，减轻了路由器负荷，⼤⼤<strong>提⾼了传输的性能</strong>。 </li>
<li>IPv6 有应对伪造 IP 地址的⽹络安全功能以及防⽌线路窃听的功能，⼤⼤<strong>提升了安全性</strong>。 </li>
<li><strong>…</strong> （由你发现更多的亮点）</li>
</ul>
<blockquote>
<p>IPv6地址的标识方法</p>
</blockquote>
<p>IPv4 地址⻓度共 32 位，是以每 8 位作为⼀组，并⽤点分⼗进制的表示⽅式。 </p>
<p>IPv6 地址⻓度是 128 位，是以每 16 位作为⼀组，每组⽤冒号 「:」 隔开。</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651545864049.png" alt="1651545864049" loading="lazy"></p>
<p>如果出现连续的 0 时还可以将这些 0 省略，并⽤两个冒号 「::」隔开。但是，⼀个 IP 地址中只允许出现⼀次两个连续的冒号。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651545880301.png" alt="1651545880301" loading="lazy"></p>
<blockquote>
<p>IPv6地址结构</p>
</blockquote>
<p>IPv6 类似 IPv4，也是通过 IP 地址的前⼏位标识 IP 地址的种类。 </p>
<p>IPv6 的地址主要有以下类型地址： </p>
<ul>
<li>单播地址，⽤于⼀对⼀的通信 </li>
<li>组播地址，⽤于⼀对多的通信 </li>
<li>任播地址，⽤于通信最近的节点，最近的节点是由路由协议决定 </li>
<li>没有⼴播地址</li>
</ul>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651545952495.png" alt="1651545952495" loading="lazy"></p>
<blockquote>
<p>IPv6单播地址类型</p>
</blockquote>
<p>对于⼀对⼀通信的 IPv6 地址，主要划分了三类单播地址，每类地址的有效范围都不同。 </p>
<ul>
<li>在同⼀链路单播通信，不经过路由器，可以使⽤<strong>链路本地单播地址</strong>，IPv4 没有此类型 </li>
<li>在内⽹⾥单播通信，可以使⽤<strong>唯⼀本地地址</strong>，相当于 IPv4 的私有 IP </li>
<li>在互联⽹通信，可以使⽤<strong>全局单播地址</strong>，相当于 IPv4 的公有 IP</li>
</ul>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651546093737.png" alt="1651546093737" loading="lazy"></p>
<h5 id="IPv4首部与IPv6首部"><a href="#IPv4首部与IPv6首部" class="headerlink" title="IPv4首部与IPv6首部"></a>IPv4首部与IPv6首部</h5><p>两者差异：<br><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651548758795.png" alt="1651548758795" loading="lazy"></p>
<p>IPv6相比于IPv4首部的改进：</p>
<ul>
<li><strong>取消了⾸部校验和字段。</strong> 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。 </li>
<li><strong>取消了分⽚</strong>**/**<strong>重新组装相关字段。</strong> 分⽚与᯿组是耗时的过程，IPv6 不允许在中间路由器进⾏分⽚与᯿组，这种操作只能在源与⽬标主机，这将⼤⼤提⾼了路由器转发的速度。 </li>
<li><strong>取消选项字段。</strong> 选项字段不再是标准 IP ⾸部的⼀部分了，但它并没有消失，⽽是可能出现在 IPv6 ⾸部中的 「下⼀个⾸部」指出的位置上。删除该选项字段使的 IPv6 的⾸部成为固定⻓度的 40 字节。</li>
</ul>
<h3 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h3><p>与IP协议相关且重要常见的技术：</p>
<ul>
<li>DNS 域名解析 </li>
<li>ARP 与 RARP 协议 </li>
<li>DHCP 动态获取 IP 地址 </li>
<li>NAT ⽹络地址转换 </li>
<li>ICMP 互联⽹控制报⽂协议 </li>
<li>IGMP 因特⽹组管理协</li>
</ul>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>我们在上网时，通常使用的是域名。而不是IP地址，因为域名更方便记忆</p>
<p>而实现这一技术的就是DNS域名解析，DNS可以将域名网址自动转换为具体的IP地址。</p>
<blockquote>
<p>域名的层级关系</p>
</blockquote>
<p>DNS 中的域名都是⽤<strong>句点</strong>来分隔的，⽐如 <a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> ，这⾥的句点代表了不同层次之间的<strong>界限</strong>。 </p>
<p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越⾼</strong>。</p>
<p>毕竟域名是外国⼈发明，所以思维和中国⼈相反，⽐如说⼀个城市地点的时候，外国喜欢从⼩到⼤的⽅式顺序说起 （如 XX 街道 XX 区 XX 市 XX 省），⽽中国则喜欢从⼤到⼩的顺序（如 XX 省 XX 市 XX 区 XX 街道）。</p>
<p>根域是在最顶层，它的下⼀层就是 com 顶级域，再下⾯是 server.com。</p>
<p>所以域名的层级关系类似⼀个树状结构： </p>
<ul>
<li>根 DNS 服务器 </li>
<li>顶级域 DNS 服务器（com） </li>
<li>权威 DNS 服务器（server.com）</li>
</ul>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651549121242.png" alt="1651549121242" loading="lazy"></p>
<p>根域的 DNS 服务器信息保存在互联⽹中所有的 DNS 服务器中。这样⼀来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。 </p>
<p>因此，客户端只要能够找到任意⼀台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再⼀路顺藤摸⽠找到位于下层的某台⽬标 DNS 服务器。</p>
<blockquote>
<p>域名解析的工作流程</p>
</blockquote>
<p>浏览器⾸先看⼀下⾃⼰的缓存⾥有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析⽂件 hosts ，如果还是没有，就会 DNS 服务器进⾏查询，查询的过程如下：</p>
<ol>
<li><p>客户端⾸先会发出⼀个 DNS 请求，问 <a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。 </p>
</li>
<li><p>本地域名服务器收到客户端的请求后，如果缓存⾥的表格能找到 <a target="_blank" rel="noopener" href="http://www.server.com,则它直接返回/">www.server.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“⽼⼤， 能告诉我 <a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？” 根域名 服务器是最⾼层次的，它不直接⽤于域名解析，但能指明⼀条道路。 </p>
</li>
<li><p>根 DNS 收到来⾃本地 DNS 的请求后，发现后置是 .com，说：“<a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。” </p>
</li>
<li><p>本地 DNS 收到顶级域名服务器的地址后，发起请求问“⽼⼆， 你能告诉我 <a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？” </p>
</li>
<li><p>顶级域名服务器说：“我给你负责 <a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到”。 </p>
</li>
<li><p>本地 DNS 于是转向问权威 DNS 服务器：“⽼三，<a href="http://www.server.com对应的IP是啥呀？”">www.server.com对应的IP是啥呀？”</a> server.com 的权威DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主</p>
</li>
<li><p>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。 </p>
</li>
<li><p>本地 DNS 再将 IP 地址返回客户端，客户端和⽬标建⽴连接</p>
</li>
</ol>
<p>⾄此，我们完成了 DNS 的解析过程。现在总结⼀下，整个过程我画成了⼀个图。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651594479152.png" alt="1651594479152" loading="lazy"></p>
<p>DNS 域名解析的过程蛮有意思的，整个过程就和我们⽇常⽣活中找⼈问路的过程类似，<strong>只指路不带路</strong>。</p>
<h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>在传输一个IP数据报的时候，确定了源IP地址和目标IP地址后，就会通过主机路由表确定IP数据报下一跳。然而，网络层的下一层是数据链路层，所以还要直到下一跳的MAC地址。</p>
<p>由于主机路由表中可以找到下一跳的IP地址，所以可以通过ARP协议，求得下一跳的MAC地址。</p>
<blockquote>
<p>那么ARP又是如何知道对方MAC地址的？</p>
</blockquote>
<p>简单来说，ARP是借助<strong>ARP请求与ARP响应</strong>两种类型的包确定MAC地址的。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651594840136.png" alt="1651594840136" loading="lazy"></p>
<ul>
<li>主机会通过<strong>⼴播发送</strong> <strong>ARP</strong> <strong>请求</strong>，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。 </li>
<li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包⾥的内容，如果 ARP 请求包中的⽬标 IP地址与⾃⼰的 IP 地址⼀致，那么这个设备就将⾃⼰的 MAC 地址塞⼊ <strong>ARP</strong> <strong>响应包</strong>返回给主机。</li>
</ul>
<p>操作系统通常会把第一次通过ARP获取到的MAC地址缓存起来，以便下一次直接从缓存里找到对应IP地址的MAC地址。不过，MAC地址的缓存是有一定期限的，超过这个期限，缓存的内容就会被清除。</p>
<blockquote>
<p>RARP协议是什么知道吗？</p>
</blockquote>
<p>ARP协议是已知IP地址求MAC地址，而RARP协议正好相反，它是已知MAC地址求IP地址。例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用到。</p>
<p>通常这需要架设一台RARP服务器，在这个服务器上注册设备的MAC地址及其IP地址。然后再将这个设备接入网络，接着：</p>
<ul>
<li>该设备会发送一条我的MAC地址是xxx，请告诉我，我的IP地址应该是什么的请求。</li>
<li>RARP服务器接到这个消息后返回MAC地址为xxx的设备，IP地址是xxx的信息给这个设备</li>
</ul>
<p>最后，设备就根据从RARP服务器所收到的应答消息设置自己的IP地址。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651595587363.png" alt="1651595587363" loading="lazy"></p>
<h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>DHCP在生活中很常见，我们的电脑通过DHC动态获取IP地址，大大省去了配IP信息繁琐的过程。</p>
<p>电脑是如何通过4个步骤的过程，获取IP的：<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651712759081.png" alt="1651712759081" loading="lazy"></p>
<p>DHCP客户端进程监听的是68端口号，DHCP服务端进程监听的是67端口</p>
<p>4个步骤：</p>
<ul>
<li>客户端首先发起DHCP发现报文（DHCP DISCOVER）的IP数据报，由于客户端没有 IP 地址，也不知道DHCP 服务器的地址，所以使⽤的是 UDP <strong>⼴播</strong>通信，其使⽤的⼴播⽬的地址是 255.255.255.255（端⼝67） 并且使⽤ 0.0.0.0（端⼝ 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧⼴播到所有的⽹络中设备</li>
<li>DHCP服务器收到DHCP发现报文时，⽤ <strong>DHCP</strong> <strong>提供报⽂（<strong><strong>DHCP OFFER</strong></strong>）</strong> 向客户端做出响应。该报⽂仍然使⽤ IP ⼴播地址 255.255.255.255，该报⽂信息携带服务器提供可租约的 IP 地址、⼦⽹掩码、默认⽹关、 DNS 服务器以及 <strong>IP</strong> <strong>地址租⽤期</strong>。</li>
<li>客户端收到⼀个或多个服务器的 DHCP 提供报⽂后，从中选择⼀个服务器，并向选中的服务器发送 <strong>DHCP</strong> <strong>请求报⽂（****DHCP REQUEST</strong>进⾏响应，回显配置的参数。</li>
<li>最后，服务端⽤ <strong>DHCP ACK</strong> <strong>报⽂</strong>对 DHCP 请求报⽂进⾏响应，应答所要求的参数。</li>
</ul>
<p>⼀旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租⽤期内使⽤ DHCP 服务器分配的 IP 地址。</p>
<p>如果租约的 DHCP IP 地址过期后，客户端会向服务器发送 DHCP 请求报⽂： </p>
<ul>
<li>服务器如果同意继续租⽤，则⽤ DHCP ACK 报⽂进⾏应答，客户端就会延⻓租期。 </li>
<li>服务器如果不同意继续租⽤，则⽤ DHCP NACK 报⽂，客户端就要停⽌使⽤租约的 IP 地址。</li>
</ul>
<p>可以发现，DHCP 交互中，<strong>全程都是使⽤</strong> <strong>UDP</strong> <strong>⼴播通信</strong>。</p>
<blockquote>
<p>用的是广播，那如果DHCP服务器和客户端不在同一个局域网内，路由器又不会转发广播包，那岂不是每个网络都要配一个DHCP服务器？</p>
</blockquote>
<p>所以，为了解决问题，就出现了DHCP中继代理。对不同网段的IP地址分配也可以由同一个DHCP服务器统一进行管理。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651713424223.png" alt="1651713424223" loading="lazy"></p>
<p>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，⽽ DHCP 中继代理在收到这个⼴播包以后，再以<strong>单播</strong>的形式发给 DHCP 服务器。 </p>
<p>服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包⼴播给 DHCP 客户端 。</p>
<h3 id="ping的工作原理"><a href="#ping的工作原理" class="headerlink" title="ping的工作原理"></a>ping的工作原理</h3><p>在日常生活或工作中，我们在判断与对方网络是否畅通，使用的最多的莫过于ping命令了。</p>
<h4 id="IP协议的助手——ICMP协议"><a href="#IP协议的助手——ICMP协议" class="headerlink" title="IP协议的助手——ICMP协议"></a>IP协议的助手——ICMP协议</h4><p>ping是基于ICMP协议的，所以要先熟悉ICMP协议。</p>
<blockquote>
<p>ICMP是什么？</p>
</blockquote>
<p>ICMP全称Internet Control Message Protocol，也就是互联网控制报文协议。</p>
<p>里面有个关键词——<strong>控制</strong>，如何控制呢？</p>
<p>⽹络包在复杂的⽹络传输环境⾥，常常会遇到各种问题。当遇到问题的时候，总不能死的不明不⽩，没头没脑的作⻛不是计算机⽹络的⻛格。所以需要传出消息，报告遇到了什么问题，这样才可以调整传输策略，以此来控制整个局⾯。</p>
<blockquote>
<p>ICMP有什么功能？</p>
</blockquote>
<p>ICMP 主要的功能包括：<strong>确认</strong> <strong>IP</strong> <strong>包是否成功送达⽬标地址、报告发送过程中</strong> <strong>IP</strong> <strong>包被废弃的原因和改善⽹络设置等。</strong></p>
<p>在<strong>IP</strong>通信中如果某个Ip包因为某种原因未能达到目标地址，那么这个具体的原因将<strong>由ICMP负责通知</strong><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651975934075.png" alt="1651975934075" loading="lazy"></p>
<p>如上图例子，主机A向主机B发送数据包，由于某种原因，途中路由器2未能发现主机B的存在，这时路由器2就会向主机A发送了一个ICMP目标不可达数据包，说明发往主机B的包未能成功。</p>
<p>ICMP的这种通知消息会使用<strong>IP</strong>发送</p>
<p>因此，从路由器2返回的ICMP包会按照原路线返回先经过路由器1再回到主机A。收到该ICMP包的主机A则分解ICMP包的首部和数据域以后得知具体发生问题的原因。</p>
<blockquote>
<p>ICMP包头的格式</p>
</blockquote>
<p>ICMP 报⽂是封装在 IP 包⾥⾯，它⼯作在⽹络层，是 IP 协议的助⼿。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651976382010.png" alt="1651976382010" loading="lazy"></p>
<p>ICMP包头的类型字段，大致分两类：</p>
<ul>
<li>一类是用于诊断的查询消息，也就是<strong>查询报文类型</strong></li>
<li>另一类是通知出错原因的错误消息，也就是差错报文类型</li>
</ul>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651976741814.png" alt="1651976741814" loading="lazy"></p>
<h4 id="查询报文类型"><a href="#查询报文类型" class="headerlink" title="查询报文类型"></a>查询报文类型</h4><blockquote>
<p>回送消息——类型0和8</p>
</blockquote>
<p>回送消息用于进行通信的主机和路由器之间，判断所发送的数据包是否已经成功达到对端的一种消息，ping命令就是利用这个消息实现的。</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651976968065.png" alt="1651976968065" loading="lazy"></p>
<p>可以向对端主机发送<strong>回送请求</strong>的消息（ICMP Echo Request Message，类型8），也可以接收到对端主机发回来的回送应答消息（ICMP Echo Reply Message ，类型 0 ）</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651977218404.png" alt="1651977218404" loading="lazy"></p>
<p>相比于原生的ICMP，这里多了两个字段：</p>
<ul>
<li><strong>标识符</strong>：用于区分是哪个应用程序发ICMP包，比如进程PID作为标识符</li>
<li><strong>序号</strong>：序列号从0开始，每发送一次新的回送请求就会加1，可以用来确定网络包是否有丢失</li>
</ul>
<p>在<strong>选项数据</strong>中，<strong>ping</strong>还会存放发送请求的时间值，来计算往返时间，说明路径长短</p>
<h4 id="差错报文类型"><a href="#差错报文类型" class="headerlink" title="差错报文类型"></a>差错报文类型</h4><p>下面是常用的ICMP差错报文的例子：</p>
<ul>
<li>目标不可达消息——类型3</li>
<li>原点抑制消息——类型4</li>
<li>重定向消息——类型5</li>
<li>超时消息——类型11</li>
</ul>
<blockquote>
<p>目标不可达消息（Destination Unreachable Message） —— 类型为 3</p>
</blockquote>
<p>IP 路由器⽆法将 IP 数据包发送给⽬标地址时，会给发送端主机返回⼀个<strong>⽬标不可达</strong>的 ICMP 消息，并在这个消息中显示不可达的具体原因，原因记录在 ICMP 包头的<strong>代码</strong>字段。 </p>
<p>由此，根据 ICMP 不可达的具体消息，发送端主机也就可以了解此次发送<strong>不可达的具体原因</strong>。 </p>
<p>举例 6 种常⻅的⽬标不可达类型的<strong>代码</strong>：<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651979196562.png" alt="1651979196562" loading="lazy"></p>
<ul>
<li>⽹络不可达代码为 0 </li>
<li>主机不可达代码为 1 </li>
<li>协议不可达代码为 2 </li>
<li>端⼝不可达代码为 3 </li>
<li>需要进⾏分⽚但设置了不分⽚位代码为 4</li>
</ul>
<p>1.网络不可达代码为0</p>
<p>​    IP地址是分为网络号和主机号的，所以当路由器中的路由表匹配不到接收方IP的网络号，就通过ICMP协议以<strong>网络不可达</strong>（Network Unreachable ））的原因告知主机（⼩林第⼀次送外卖时，⼩区⾥只有 A 和 B 区两栋楼，但送餐地址写的是 C 区楼，⼩林表示头上很多问号，压根就没这个地⽅。）</p>
<p>2.主机不可达代码为1</p>
<p>​    当路由表中没有该主机的信息，或者该主机没有连接到网络，那么就会通过ICMP协议以<strong>主机不可达</strong>（Host Unreachable）的原因告知主机（⼩林第⼆次送外卖时，这次⼩区有 5 层楼⾼的 C 区楼了，找到地⽅了，但送餐地址写的是 C 区楼 601 号房 ，说明 找不到这个房间。）</p>
<p>3.协议不可达代码为2</p>
<p>​    当主机使用TCP协议访问对端主机时，能找到对端的主机了，可是对端主机的防火墙已经禁止TCP协议访问，那么会通过ICMP协议以<strong>协议不可达</strong>的原因告知主机。（⼩林第三次送外卖时，这次⼩区有 C 区楼，也有 601 号房，找到地⽅了，也找到房间了，但是⼀开⻔⼈家是外国⼈说的是英语，我说的是中⽂！语⾔不通，外卖送达失败~）</p>
<p>4.端口不可达代码为3</p>
<p>​    当主机访问对端主机8080端口时，这次能找到对端主机，防火墙也没有限制，可是发现对端主机没有进程监听8080端口，那么会通过ICMP协议以<strong>端口不可达</strong>的原因告知主机（⼩林第四次送外卖时，这次⼩区有 C 区楼，也有 601 号房，找到地⽅了，也找到房间了，房间⾥的⼈也是说中⽂的⼈了，但是⼈家说他要的不是外卖，⽽是快递。。。）</p>
<p>5.需要进行分片但设置了不分片代码为4</p>
<p>​    发送端主机发送IP数据报时，将IP首部的分片禁止标志位设置为1.根据这个标志位，途中的路由器遇到超过MTU大小的数据报时，不会进行分片，而是直接抛弃。随后，通过一个ICMP的不可达消息类型，代码为4的报文，告知发送端主机（⼩林第五次送外卖时，这次是个吃播博主点了 100 份外卖，但是吃播博主要求⼀次性要把全部外卖送达，⼩林的⼀台电动⻋装不下呀，这样就没办法送达了。）    </p>
<blockquote>
<p>原点抑制消息（ICMP Source Quench Message） —— 类型 4</p>
</blockquote>
<p>在使用低速广域路线的情况下，连接WAN的路由器可能会遇到网络拥塞的问题</p>
<p>ICMP原点抑制消息的目的就是为了<strong>缓和这种拥塞情况</strong></p>
<p>当路由器向低速线路发送数据时，其发送队列的缓存变为零⽽⽆法发送出去时，可以向 IP 包的源地址发送⼀个ICMP <strong>原点抑制消息</strong>。 </p>
<p>收到这个消息的主机借此了解在整个线路的某⼀处发⽣了拥堵的情况，从⽽增⼤ IP 包的传输间隔，减少⽹络拥堵的情况。 </p>
<p>然⽽，由于这种 ICMP 可能会引起不公平的⽹络通信，⼀般不被使⽤。</p>
<blockquote>
<p>重定向消息（ICMP Redirect Message） —— 类型 <strong>5</strong></p>
</blockquote>
<p>如果路由器发现发送端主机使⽤了「不是最优」的路径发送数据，那么它会返回⼀个 ICMP <strong>重定向消息</strong>给这个主机。 </p>
<p>在这个消息中包含了<strong>最合适的路由信息和源数据</strong>。这主要发⽣在路由器持有更好的路由信息的情况下。路由器会通过这样的 ICMP 消息告知发送端，让它下次发给另外⼀个路由器。 </p>
<p>好⽐，⼩林本可以过条⻢路就能到的地⽅，但⼩林不知道，所以绕了⼀圈才到，后⾯⼩林知道后，下次⼩林就不会那么<strong>傻</strong>再绕⼀圈了。</p>
<blockquote>
<p>超时消息（ICMP Time Exceeded Message） —— 类型 11</p>
</blockquote>
<p>IP包中有一个字段叫做<strong>TTL</strong>(Time To Live ，⽣存周期）<strong>它的值随着每经过一次路由器就会减1，直到减为0时该IP包会被丢弃。</strong></p>
<p>此时，路由器将会发送一个ICMP超时消息给发送端主机，并通知该包已被丢弃，</p>
<p>设置IP包生存周期的主要目的，是为了在路由控制遇到问题发生循环状况时，避免IP包无休止地在网络上被转发。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1651980925642.png" alt="1651980925642" loading="lazy"></p>
<p>此外，有时可以⽤ TTL 控制包的到达范围，例如设置⼀个<strong>较⼩的</strong> <strong>TTL</strong> <strong>值</strong>。</p>
<h4 id="ping——查询报文类型的使用"><a href="#ping——查询报文类型的使用" class="headerlink" title="ping——查询报文类型的使用"></a>ping——查询报文类型的使用</h4><p>ping的发送和接收过程</p>
<hr>
<blockquote>
<p>同个子网下的主机A和主机B，主机A执行ping主机B后，期间发生了什么</p>
</blockquote>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652062282109.png" alt="1652062282109" loading="lazy"></p>
<p>ping命令执行的时候，源主机首先会创建一个<strong>ICMP回送请求消息</strong>数据包</p>
<p>ICMP数据包内包含多个字段，最重要的是两个：</p>
<ul>
<li>第一个是类型，对于回送请求消息而言该字段是8</li>
<li>另一个是序号 ，主要用于区分连续ping的时候发出的多个数据包</li>
</ul>
<p>每发出⼀个请求数据包，序号会⾃动加 1 。为了能够计算往返时间 RTT ，它会在报⽂的数据部分插⼊发送时间。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652063276493.png" alt="1652063276493" loading="lazy"></p>
<p>然后，由ICMP协议将这个数据包连同地址192.168.1.2一起交给IP层。IP层将以192.168.1.2作为<strong>目的地址</strong>，本机IP地址作为<strong>源地址</strong>，协议字段设置为1表示是ICMP协议，再加上一些其他控制信息，构建一个IP数据包。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652063425512.png" alt="1652063425512" loading="lazy"></p>
<p>接下来，需要加⼊ MAC 头。如果在本地 ARP 映射表中查找出 IP 地址 192.168.1.2 所对应的 MAC 地址，则可以直接使⽤；如果没有，则需要发送 ARP 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建⼀个数据 帧，⽬的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上⼀些控制信息，依据以太⽹的介质访问规则，将它们传送出去。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652063510480.png" alt="1652063510480" loading="lazy"></p>
<p>主机B收到这个数据帧后，先检查它的的MAC地址，并与本机MAC地址对比，若符合，就接收，否则就丢弃。</p>
<p>接收后检查该数据帧，将IP数据包从帧中提取出来，交给本机的IP层。同样，IP检查后，将有用的信息提取后交给ICMP协议。</p>
<p>主机B会创建一个<strong>ICMP回送响应消息</strong>数据包，回送响应数据包的类型字段为0，序号为接收到的请求数据包中的序号，然后再发送出去给主机A。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652063744953.png" alt="1652063744953" loading="lazy"></p>
<p>在规定的时间内，源主机如果没有接到ICMP的应答包，则说明目标主机不可达；如果接收到了ICMP回送响应消息，则说明目标主机可达。</p>
<p>此时源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是ICMP数据包的时间延迟。</p>
<p>针对上面发生的事情，总结如下图：<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652063922604.png" alt="1652063922604" loading="lazy"></p>
<p>当然这是一个局域网中的情况。如果跨网段的话，还会涉及网关的转发、路由器的转发等。</p>
<p>但是对于 ICMP 的头来讲，是没什么影响的。会影响的是根据⽬标 IP 地址，选择路由的下⼀跳，还有每经过⼀个路由器到达⼀个新的局域⽹，需要换 MAC 头⾥⾯的 MAC 地址。</p>
<p>说了这么多，可以看出 ping 这个程序是<strong>使⽤了</strong> <strong>ICMP</strong> <strong>⾥⾯的</strong> <strong>ECHO REQUEST****（类型为</strong> <strong>8</strong> <strong>） 和</strong> <strong>ECHO REPLY（类型为</strong> <strong>0****）</strong>。</p>
<h4 id="traceroute——差错报文类型的使用"><a href="#traceroute——差错报文类型的使用" class="headerlink" title="traceroute——差错报文类型的使用"></a>traceroute——差错报文类型的使用</h4><p>有一款充分利用ICMP<strong>差错报文类型</strong>的应用叫做taceroute（在UNIX、MacOS中是这个命令，在windows中对等的命令是tracert）</p>
<p><strong>1.traceroute作用一</strong></p>
<p>traceroute的第一个作用就是<strong>故意设置特殊的TTL，来追踪去往目的地时沿途经过的路由器</strong></p>
<p>traceroute的参数指向某个<strong>目的IP地址</strong>：</p>
<p>traceroute 192.168.1.100</p>
<blockquote>
<p>这个作用是如何工作的呢？</p>
</blockquote>
<p>它的原理就是利⽤ IP 包的<strong>⽣存期限</strong> 从 1 开始按照顺序递增的同时发送 <strong>UDP</strong> <strong>包</strong>，强制接收 <strong>ICMP</strong> <strong>超时消息</strong>的⼀种⽅法。 </p>
<p>⽐如，将 TTL 设置 为 1 ，则遇到第⼀个路由器，就牺牲了，接着返回 ICMP 差错报⽂⽹络包，类型是<strong>时间超时</strong>。 </p>
<p>接下来将 TTL 设置为 2 ，第⼀个路由器过了，遇到第⼆个路由器也牺牲了，也同时返回了 ICMP 差错报⽂数据包，如此往复，直到到达⽬的主机。 </p>
<p>这样的过程，traceroute 就可以拿到了所有的路由器 IP。 </p>
<p>当然有的路由器根本就不会返回这个 ICMP，所以对于有的公⽹地址，是看不到中间经过的路由的。</p>
<blockquote>
<p>发送方如何直到发出的UDP包是否到达了目的主机？</p>
</blockquote>
<p>traceroute 在发送 UDP 包时，会填⼊⼀个<strong>不可能的端⼝号</strong>值作为 UDP ⽬标端⼝号（⼤于 3000 ）。当⽬的主机，收到 UDP 包后，会返回 ICMP 差错报⽂消息，但这个差错报⽂消息的类型是「<strong>端⼝不可达</strong>」。 </p>
<p>所以，<strong>当差错报⽂类型是端⼝不可达时，说明发送⽅发出的</strong> <strong>UDP</strong> <strong>包到达了⽬的主机。</strong></p>
<p><strong>2.traceroute作用二：</strong></p>
<p>traceroute还有一个作用是<strong>故意设置不分片，从而确定路径的MTU</strong></p>
<blockquote>
<p>这么做是为了什么？</p>
</blockquote>
<p><strong>目的是路径MTU发现。</strong></p>
<p>因为有时候我们并不知道路由器的MTU大小，以太网的数据链路上的MTU通常是1500字节，但是非以太网的MTU值就不一样了，所以我们要知道MTU的大小，从而控制发送包的大小。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652065055837.png" alt="1652065055837" loading="lazy"></p>
<p>工作原理如下：</p>
<p>首先在发送端主机发送IP数据报时，<strong>将IP包首部的分片禁止标志位设置为1</strong>.根据这个标志位，途中的路由器不会对大数据包进行分片，而是将包丢弃</p>
<p>随后，通过一个ICMP的不可达消息将数据链路上的MTU值一起发送给主机，不可达消息为<strong>需要进行分片但设置了不分片位</strong></p>
<p>发送主机端每次收到ICMP差错报文时就减少包的大小，一次来定位一个合适的MTU值，以便能到达目标主机</p>
<h2 id="网络综合篇"><a href="#网络综合篇" class="headerlink" title="网络综合篇"></a>网络综合篇</h2><h3 id="1-键入网址到网页显示，期间发生了什么？"><a href="#1-键入网址到网页显示，期间发生了什么？" class="headerlink" title="1.键入网址到网页显示，期间发生了什么？"></a>1.键入网址到网页显示，期间发生了什么？</h3><p>以下图网络拓扑模型作为例子，探究发生了什么？<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652066744372.png" alt="1652066744372" loading="lazy"></p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><blockquote>
<p>浏览器做的第一步工作是解析URL</p>
</blockquote>
<p>首先浏览器做的第一步工作就是要对URL进行解析，从而生成发送给WEB服务器的请求信息。</p>
<p>URL里的各个元素代表什么，如下图：<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652066880463.png" alt="1652066880463" loading="lazy"></p>
<p>所以图中的长长的URL实际上是请求服务器里的文件资源。</p>
<blockquote>
<p>要是上图中的蓝色部分URL元素都省略了，那应该请求哪个文件？</p>
</blockquote>
<p>当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是/index.html或者.default.html这些文件，这样就不会发生混乱了。</p>
<blockquote>
<p>生产HTTP请求消息</p>
</blockquote>
<p>对URL进行解析之后，浏览器确定了服务器和文件名，接下来就是根据这些信息来生成HTTP请求消息。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652150723649.png" alt="1652150723649" loading="lazy"></p>
<h4 id="真实地址查询——DNS"><a href="#真实地址查询——DNS" class="headerlink" title="真实地址查询——DNS"></a>真实地址查询——DNS</h4><p>通过浏览器解析URL并生成HTTP消息后，需要委托操作系统将消息发送给web服务器。</p>
<p>但在发送之前，还有一项工作需要完成，那就是查询服务器域名对应的IP地址，因为委托操作系统发送消息时，必须提供通信对象的IP地址。</p>
<p>比如我们打电话时，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号+姓名保存在通讯录。</p>
<p>所以有一种服务器就专门保存web服务器域名与IP地址的对应关系，他就是DNS服务器。</p>
<blockquote>
<p>域名的层级关系</p>
</blockquote>
<p>DNS中的域名都使用<strong>句点</strong>来分隔的，比如<a target="_blank" rel="noopener" href="http://www.server.com,这里的句点就代表了不同层次之间的**界限**./">www.server.com，这里的句点就代表了不同层次之间的**界限**。</a></p>
<p>在域名中，越靠右的位置表示其层级<strong>越高</strong>。</p>
<p>毕竟域名是外国⼈发明，所以思维和中国⼈相反，⽐如说⼀个城市地点的时候，外国喜欢从⼩到⼤的⽅式顺序说起 （如 XX 街道 XX 区 XX 市 XX 省），⽽中国则喜欢从⼤到⼩的顺序（如 XX 省 XX 市 XX 区 XX 街道）。</p>
<p>根域是在最顶层，它的下一层就是com顶级域，再下层是server.com</p>
<p>所以域名的层级关系类似于一个树状结构：</p>
<ul>
<li>根 DNS 服务器 </li>
<li>顶级域 DNS 服务器（com） </li>
<li>权威 DNS 服务器（server.com）</li>
</ul>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652151450462.png" alt="1652151450462" loading="lazy"></p>
<p>根域的DNS服务器信息保存在互联网中所有的DNS服务器中。</p>
<p>这样一来，任何DNS服务器就都可以找到并访问根域DNS服务器</p>
<p>因此，客户端只要能够找到任意一台DNS服务器，就可以通过它找到根域DNS服务器，然后再一路顺藤摸瓜找到位于下层的某台目标DNS服务器。</p>
<blockquote>
<p>域名解析的工作流程</p>
</blockquote>
<p>1.客户端首先会发出一个DNS请求，问<a target="_blank" rel="noopener" href="http://www.server.com的ip是啥,并发给本地dns服务器(也就是客户端的tcp/IP%E8%AE%BE%E7%BD%AE%E4%B8%AD%E5%A1%AB%E5%86%99%E7%9A%84DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80%EF%BC%89">www.server.com的IP是啥，并发给本地DNS服务器（也就是客户端的TCP/IP设置中填写的DNS服务器地址）</a></p>
<p>2.本地域名服务器收到客户端请求后，如果缓存里的表格能找到<a href="http://www.server.com，则它直接返回IP地址。如果没有，本地DNS会去问它的根域名服务器：“能告诉我www.server.com的IP地址吗”根域名服务器是最高层次的，他不直接用于域名解析，但能指名一条道路。">www.server.com，则它直接返回IP地址。如果没有，本地DNS会去问它的根域名服务器：“能告诉我www.server.com的IP地址吗”根域名服务器是最高层次的，他不直接用于域名解析，但能指名一条道路。</a></p>
<p>3.根DNS收到来自本地DNS的请求后，发现后置是.com，说“<a target="_blank" rel="noopener" href="http://www.server.com这个域名归.com区域管理”,我给你,com顶级域名服务器地址给你,你去问他/">www.server.com这个域名归.com区域管理”，我给你,com顶级域名服务器地址给你，你去问他</a></p>
<p>4.本地DNS收到顶级域名服务器的地址后，发起请求问：“你能告诉我<a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> 的IP地址吗”</p>
<p>5.顶级域名服务器说：“我给你负责<a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> 区域的权威DNS服务器的地址，去问问他”</p>
<p>6.本地DNS于是转向问权威DNS服务器：“<a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> 对应IP地址是什么”，server.com的权威DNS服务器，它是域名解析结果的原出处</p>
<p>7.权威DNS服务器查询后将对应的IP地址告诉本地DNS</p>
<p>8.本地DNS再将IP地址返回客户端，客户端和目标建立连接</p>
<p>至此，完成了DNS的解析过程，如下图：<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652153061307.png" alt="1652153061307" loading="lazy"></p>
<p>DNS域名解析的过程，只指路不带路。</p>
<h4 id="指南帮手——协议栈"><a href="#指南帮手——协议栈" class="headerlink" title="指南帮手——协议栈"></a>指南帮手——协议栈</h4><p>通过DNS获取到IP后，就可以把HTTP的传输工作交给操作系统中的<strong>协议栈。</strong></p>
<p>协议栈的内部分为几个部分，分别承担不同的工作。上下级关系是有一定规则的，上面的部分会下面的部分委托工作，下面的部分收到委托的工作并执行。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652153577363.png" alt="1652153577363" loading="lazy"></p>
<p>应用程序（浏览器）通过调用Socket库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的TCP和UDP协议，它们两会接收应用层的委托来执行收发数据的工作。</p>
<p>协议栈下面一半是用IP协议控制的网络包收发操作，在互联网上传数据时，数据会被分成一块块的网络包，而将网络包发送给对方的操作就是由IP负责的。</p>
<p>此外IP中还包括ICMP协议和ARP协议：</p>
<ul>
<li>ICMP用于告知网络包传送过程中产生的错误以及各种控制信息</li>
<li>ARP用于根据IP地址查询相应的以太网MAC地址</li>
</ul>
<p>IP下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p>
<h4 id="可靠传输——TCP"><a href="#可靠传输——TCP" class="headerlink" title="可靠传输——TCP"></a>可靠传输——TCP</h4><p>HTTP是基于TCP协议传输的，所以在这我们先了解一下TCP协议。</p>
<blockquote>
<p>TCP包头格式</p>
</blockquote>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652323407315.png" alt="1652323407315" loading="lazy"></p>
<p>首先，<strong>源端口号</strong>和<strong>目标端口号</strong>是不可缺少的，如果没有这两个，数据不知道发给哪个应用。</p>
<p>接下来有包的序<strong>号</strong>，这个是为了<strong>解决包乱序的问题</strong></p>
<p>还有应该有的<strong>确认号</strong>，目的是确认发出去对方是否有收到。如果没有收到就重新发送，直到送达，这个是为了<strong>解决不丢包问题</strong></p>
<p>接下来还有一些<strong>状态位</strong>，例如<strong>SYN</strong>是发起了一个连接，<strong>ACK</strong>是回复，<strong>RST</strong>是重新连接，<strong>FIN</strong>是结束连接等。TCP是面向连接的，因为双方要维护连接的状态，这些带状态位的包的发送，会引起双方状态的变更。</p>
<p>还有一个重要的就是<strong>窗口大小</strong>。TCP要做<strong>流量控制</strong>，通信双方各声明一个窗口(缓存大小)，标识自己当前能够的处理能力，别发送的太快，也别发送的太慢。</p>
<p>除了做流量控制外，TCP还会做<strong>拥塞控制</strong>，对于真正的通路堵车不堵车，无能为力，唯一能做的是控制自己，即控制发送的速度。</p>
<blockquote>
<p>TCP传输数据之前，要先三次握手建立连接</p>
</blockquote>
<p>在HTTP传输数据之前，首先需要TCP建立连接，TCP连接的建立，通常称为<strong>三次握手</strong>。</p>
<p>这个所谓<strong>连接</strong>，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652324231581.png" alt="1652324231581" loading="lazy"></p>
<ul>
<li>一开始，客户端和服务器都处于<strong>CLOSED</strong>状态。先是服务器主动监听某个端口，处于<strong>LISTEN</strong>状态。</li>
<li>然后客户端主动发起连接<strong>SYN</strong>，之后处于<strong>SYN-SENT</strong>状态。</li>
<li>服务端收到发起的连接，返回<strong>SYN</strong>，并且<strong>ACK客户端的SYN</strong>，之后处于<strong>SYN-RCVD</strong>状态</li>
<li>客户端收到服务端发送的<strong>SYN</strong>和<strong>ACK</strong>之后，发送<strong>ACK的ACK</strong>，之后处于<strong>ESTABLISHED</strong>状态，因为它一发一收成功了。</li>
<li>服务端收到<strong>ACK的ACK</strong>之后，处于<strong>ESTABLISHED</strong>状态，因为它一发一收了。</li>
</ul>
<blockquote>
<p>如何查看TCP的连接状态</p>
</blockquote>
<p>TCP的连接状态查看，在Linux可以通过<strong>nestat -napt</strong>命令查看。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652324852164.png" alt="1652324852164" loading="lazy"></p>
<blockquote>
<p>TCP分割数据</p>
</blockquote>
<p>如果HTTP请求消息过长，超过了<strong>MSS</strong>长度，这时TCP就需要把HTTP的数据拆解成一块块的数据发送，而不是一次性发送所有数据。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652325019010.png" alt="1652325019010" loading="lazy"></p>
<ul>
<li><strong>MTU</strong>：一个网络包的最大长度，以太网中一般为<strong>1500</strong>字节</li>
<li><strong>MSS</strong>：除去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度</li>
</ul>
<p>数据会被以<strong>MSS</strong>的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上TCP头信息，然后交给IP模块来发送数据。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652325265475.png" alt="1652325265475" loading="lazy"></p>
<blockquote>
<p>TCP报文生成</p>
</blockquote>
<p>TCP协议里面会有两个端口，一个是浏览器监听的端口(通常是随机生成的)，一个是Web服务器监听的端口(HTTP默认端口是80，HTPS默认端口是443).</p>
<p>在双方建立了连接后，TCP报文中的数据部分就是存放HTTP头部+数据，组装好TCP报文之后，就需交给下面的网络层处理。</p>
<p>至此，网络包的报文如下图。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652325496614.png" alt="1652325496614" loading="lazy"></p>
<h4 id="远程定位——IP"><a href="#远程定位——IP" class="headerlink" title="远程定位——IP"></a>远程定位——IP</h4><p>TCP模块在执行连接、收发、断开等各阶段操作时，都需要委托IP模块将数据封装成<strong>网络包</strong>发给通信对象</p>
<blockquote>
<p>IP包头格式</p>
</blockquote>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652325889640.png" alt="1652325889640" loading="lazy"></p>
<p>在IP协议里面需要有<strong>源地址IP和目标地址IP</strong>：</p>
<ul>
<li>源地址IP：是客户端输出的IP地址；</li>
<li>目标地址IP，通过DNS域名解析得到的Web服务器IP</li>
</ul>
<p>因为HTTP是经过TCP传输的，所以在IP包头的<strong>协议号</strong>，要填写为06（十六进制），表示协议为TCP。</p>
<blockquote>
<p>假设客户端有多个网卡，就会有多个IP头部的源地址应该选择哪个Ip？</p>
</blockquote>
<p>当存在多个网卡时，在填写源地址IP时，就需要判断到底应该写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。</p>
<p>这个时候就需要根据<strong>路由表</strong>规则，来判断哪一个网卡作为源地址IP。</p>
<p>在Linux操作系统，我们可以使用<strong>route -n</strong>命令查看当前系统的路由表。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652340958174.png" alt="1652340958174" loading="lazy"></p>
<p>举个例子，根据上面的路由表，我们假设Web服务器的目标地址是<strong>192.168.10.200</strong></p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652341178543.png" alt="1652341178543" loading="lazy"></p>
<ol>
<li><p>⾸先先和第⼀条⽬的⼦⽹掩码（ Genmask ）进⾏ <strong>与运算</strong>，得到结果为 192.168.10.0 ，但是第⼀个条⽬的 Destination 是 192.168.3.0 ，两者不⼀致所以匹配失败。 </p>
</li>
<li><p>再与第⼆条⽬的⼦⽹掩码进⾏ <strong>与运算</strong>，得到的结果为 192.168.10.0 ，与第⼆条⽬的 Destination 192.168.10.0 匹配成功，所以将使⽤ eth1 ⽹卡的 IP 地址作为 IP 包头的源地址。</p>
</li>
</ol>
<p>那么假设Web服务器的底目标地址是<strong>10.100.20.100</strong>，那么依然依照上面的路由表规则判断，判断的后果是和第三条目匹配</p>
<p>第三条目比较特殊，它目标地址和子网掩码都是<strong>0.0.0.0</strong>，这表示<strong>默认网关</strong>，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，<strong>Gateway</strong>即是路由器IP地址。</p>
<blockquote>
<p>IP报文生成</p>
</blockquote>
<p>至此，网络包的报文如下。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652341725943.png" alt="1652341725943" loading="lazy"></p>
<h4 id="两点传输——MAC"><a href="#两点传输——MAC" class="headerlink" title="两点传输——MAC"></a>两点传输——MAC</h4><p>生成了IP头部之后，接下来网络包还需要在IP头部的前面加上<strong>MAC头部</strong></p>
<blockquote>
<p>MAC包头格式</p>
</blockquote>
<p>MAC头部是以太网使用的头部，包含了接收方和发送方的MAC地址等信息</p>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652407074661.png" alt="1652407074661" loading="lazy"></p>
<p>在MAC包头里需要<strong>发送方MAC地址和接收方目标MAC地址</strong>，用于<strong>两点之间的传输</strong></p>
<p>一般在TCP/IP通信里，MAC包头的协议类型只使用：</p>
<ul>
<li><strong>0800</strong>：IP协议</li>
<li><strong>0806</strong>：ARP协议</li>
</ul>
<blockquote>
<p>MAC发送方和接收方如何确认？</p>
</blockquote>
<p><strong>发送方</strong>的MAC地址获取就比较简单，MAC地址是在网卡生产时写入到ROM里的，只要将这个值读出来写入MAC头部即可</p>
<p><strong>接收方</strong>的MAC地址，只要告诉以太网对方的MAC地址，以太网就会帮我们把包发送过去，那么这里填写对方MAC地址</p>
<p>所以先得搞清楚应该把包发给谁，这个只要查⼀下<strong>路由表</strong>就知道了。在路由表中找到相匹配的条⽬，然后把包发给Gateway 列中的 IP 地址就可以了。</p>
<blockquote>
<p>既然知道要发给谁，如何获取对方的MAC地址？</p>
</blockquote>
<p>此时需要<strong>ARP协议</strong>帮我们找到路由器的MAC地址<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652407519584.png" alt="1652407519584" loading="lazy"></p>
<p>ARP协议会在以太网中以<strong>广播</strong>的形式，对以太网所有设备    询问：“这个IP地址是谁的，把你的MAC地址给我”</p>
<p>然后就会有设备回答：“这个IP是我的，MAC地址是xxx”</p>
<p>如果对方和自己在同一个子网，通过上述方式可以获得。然后，就将MAC地址写入MAC头部，MAC头部就完成了</p>
<blockquote>
<p>每次都要广播获取，会很麻烦？</p>
</blockquote>
<p>在后续操作系统会把本次查询结果放到一块叫做<strong>ARP缓存</strong>的内存空间，不过缓存时间很短。</p>
<p>也就是说，在发包时：</p>
<ul>
<li>先查询ARP缓存，如果已经存在了对方的MAC地址，就不需要发送ARP查询，直接使用缓存中的地址</li>
<li>当缓存中没有时，则发送ARP广播查询</li>
</ul>
<blockquote>
<p>查看ARP缓存内容</p>
</blockquote>
<p>在Linux系统，我们可以使用<strong>arp -a</strong>来查看缓存内容<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652407891295.png" alt="1652407891295" loading="lazy"></p>
<blockquote>
<p>MAC报文生成</p>
</blockquote>
<p>至此，网络包的报文如下图<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652407934345.png" alt="1652407934345" loading="lazy"></p>
<h4 id="出口——网卡"><a href="#出口——网卡" class="headerlink" title="出口——网卡"></a>出口——网卡</h4><p>网络包只是存放在内存中的一串二进制数字信息，没有办法直接发给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p>
<p>负责执行这一操作的是<strong>网卡</strong>，要控制网卡还需要<strong>网卡驱动程序</strong>。</p>
<p>网卡驱动从IP模块获取包后，会将其复制到网卡内的缓存里，接着会在<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。<img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652408341312.png" alt="1652408341312" loading="lazy"></p>
<ul>
<li>起始帧分节符是一个用来表示包起始位置的标记</li>
<li>末尾的<strong>FCS</strong>（帧校验序列）用来检查包传输过程是否有损坏</li>
</ul>
<p>最后网卡会转换为电信号，通过网线发出去</p>
<h4 id="送别者——交换机"><a href="#送别者——交换机" class="headerlink" title="送别者——交换机"></a>送别者——交换机</h4><p>下面是包如何通过交换机的。交换机的设计是将网络包原样转发到目的地。交换机工作在MAC层，也称为二层网络设备。</p>
<blockquote>
<p>交换机的包接收操作</p>
</blockquote>
<p>首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。</p>
<p>然后通过包末尾的<strong>FCS</strong>校验错误，如果没问题放到缓冲区。这部分的操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p>
<p>计算机的⽹卡本身具有 MAC 地址，并通过核对收到的包的接收⽅ MAC 地址判断是不是发给⾃⼰的，如果不是发给⾃⼰的则丢弃；相对地，交换机的端⼝不核对接收⽅ MAC 地址，⽽是直接接收所有的包并存放到缓冲区中。因此，和⽹卡不同，<strong>交换机的端⼝不具有</strong> <strong>MAC</strong> <strong>地址</strong>。</p>
<p>将包存入缓冲区后，接下来需要查询一下这个包的接收方MAC地址是否已经在MAC地址表中有记录了。</p>
<p>交换机的MAC地址表主要包含两个信息：</p>
<ul>
<li>一个是设备的MAC地址</li>
<li>另一个是该设备连接在交换机的哪个端口</li>
</ul>
<p><img src="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1652409149192.png" alt="1652409149192" loading="lazy"></p>
<p>举个例子，如果收到的包的接收方MAC地址为00-02-B3-1C-9C-F9，则与图中表中的第3行匹配，根据端口列的信息，可知这个地址位于3号端口上，然后就可以通过交换电路将包发送到相应的端口了。</p>
<p><strong>所以，交换机根据MAC地址表查找MAC地址，然后将信号发送到相应的端口。</strong></p>
<blockquote>
<p>当MAC地址表找不到指定的MAC地址会怎样？</p>
</blockquote>
<p>地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备⼀段时间没有⼯作导致地址被从地址表中删除了。</p>
<p>这种情况下，交换机⽆法判断应该把包转发到哪个端⼝，只能将包转发到除了源端⼝之外的所有端⼝上，⽆论该设备连接在哪个端⼝上都能收到这个包。</p>
<p>这样做不会产⽣什么问题，因为以太⽹的设计本来就是将包发送到整个⽹络的，然后<strong>只有相应的接收者才接收包，⽽其他设备则会忽略这个包</strong>。</p>
<p>有⼈会说：“这样做会发送多余的包，会不会造成⽹络拥塞呢？”</p>
<p>其实完全不⽤过于担⼼，因为发送了包之后⽬标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写⼊ MAC 地址表，下次也就不需要把包发到所有端⼝了。 </p>
<p>局域⽹中每秒可以传输上千个包，多出⼀两个包并⽆⼤碍。 </p>
<p>此外，如果接收⽅ MAC 地址是⼀个<strong>⼴播地址</strong>，那么交换机会将包发送到除源端⼝之外的所有端⼝。</p>
<p>一下两个属于广播地址：</p>
<ul>
<li>MAC地址中的：FF:FF:FF:FF:FF:FF</li>
<li>IP地址中的：255.255.255.255</li>
</ul>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/images/alipay.jpg"><img loading="lazy" src="/images/alipay.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/wechatpay.png"><img loading="lazy" src="/images/wechatpay.png" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>翔仔</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">http://example.com/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022/04/14/java%E5%AE%B9%E5%99%A8/" rel="prev" title="java容器"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">java容器</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2022/04/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="next" title="多线程"><span class="post-nav-text">多线程</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2022 </span><span class="with-love" id="animate" title="云游君的赞助者们"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 翔仔</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.2</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.8.11</span></div><div class="live-time"><span>本博客已运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2022-04-10T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} 天 ${passHour} 小时 ${passMinute} 分 ${passSecond} 秒`;
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>