<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="翔仔"><meta name="copyright" content="翔仔"><meta name="generator" content="Hexo 5.4.2"><meta name="theme" content="hexo-theme-yun"><title>MySQL | 翔仔的博客</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.2.4/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/@unocss/runtime/mini.global.js"></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"example.com","root":"/","title":"翔仔的小站","version":"1.8.11","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]},"vendors":{"darken":"https://cdn.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="MySQLMySQL基础 关系型数据库介绍  MySQL–关系型数据库，即一种建立在关系模型的基础上的数据库， 数据被存放在数据表中，表中每一行数据存放一条记录    常见的关系型数据库   MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ……。  逻辑架构 查看MySQL提供的所有存储引擎  1mysql&amp;gt">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL">
<meta property="og:url" content="http://example.com/2022/04/22/MySQL/index.html">
<meta property="og:site_name" content="翔仔的博客">
<meta property="og:description" content="MySQLMySQL基础 关系型数据库介绍  MySQL–关系型数据库，即一种建立在关系模型的基础上的数据库， 数据被存放在数据表中，表中每一行数据存放一条记录    常见的关系型数据库   MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ……。  逻辑架构 查看MySQL提供的所有存储引擎  1mysql&amp;gt">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/mysql-engines.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%9F%A5%E7%9C%8B%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1650617400745.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652518964447.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1646898016786.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652519977029.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1646898307983.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652535888245.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652537418134.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652537586450.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652537735170.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652537967648.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652538635126.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652538678438.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652538722505.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652538795661.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652538956398.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652538998937.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652539048751.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652539426761.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652539642752.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652539903395.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652540277507.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652544675225.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652545083419.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652545182764.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652545241033.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652545268118.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652545631906.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652545439062.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652545506354.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652545518977.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652545974710.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652546085128.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652546094715.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652546136658.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652546669589.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652547231676.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652547658710.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652547780982.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652547840923.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652548090555.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652548155147.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652548376384.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652580291130.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652580474560.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652581226906.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652581401199.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652581514453.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652582611080.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1646899331303.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652583833418.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652584043939.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652601775640.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652601959138.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652602035735.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652602831329.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652602890257.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652602954239.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652602987860.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652603092286.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652623845882.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652623892480.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652624631062.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652625722770.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652626601115.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652626823498.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652630395998.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652634143064.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652634751504.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652666059987.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652666132342.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652666508855.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652666747479.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652667131942.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652667421274.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652668413960.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652670533312.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652670685945.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652670738442.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652671186210.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652671531627.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652671628560.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652671861644.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652684705791.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652685135597.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652685189189.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652685275523.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652686027723.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652686141568.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652690582106.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652690678410.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652690811034.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652713242250.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652713829189.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652713862370.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652714131616.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652714405177.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652714434090.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652714567371.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652714712614.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652715009226.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652715210828.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652715257722.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652715332857.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652715357719.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652715501264.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652720607329.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652720629046.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652720704825.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652720880325.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652720942195.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652755737778.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652756053065.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652756211837.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652756235603.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652756264542.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652756283342.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652756304291.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652756667403.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652756765892.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652756802677.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652756880490.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652756899448.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652756906743.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652757900281.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652774108868.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652775351558.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652775498796.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652776009979.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652776358602.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652800805940.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652800859612.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652800937751.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652800975163.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652801077419.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652801501352.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652801658998.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652801777563.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652801800349.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652801837932.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652801918870.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652802126122.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652802431996.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652802493533.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652802512011.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652802543296.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652802659696.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652802988135.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652803226505.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652803421497.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652804981666.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652805311416.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652805357832.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652805409873.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652805437849.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652805709800.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1653095427721.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1653095561908.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1653095842869.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1653096704579.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1653096838285.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1653096886918.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1653096956683.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1653096975431.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1653097396890.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1653097545054.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1653098304861.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1653099167641.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1653098552304.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1653099157786.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1653099265336.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1653099413713.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1653099546460.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652691435656.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652691326064.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652691645599.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652692705943.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652692754560.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323233373932352e706e67.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/640-20201207160554677.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373231303433373032332e706e67.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651305961834.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651306388108.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313734343234342e706e67.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313932303336382e706e67.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323130323031302e706e67.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323133343330362e706e67.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-31-1%E8%84%8F%E8%AF%BB(%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4)%E5%AE%9E%E4%BE%8B.jpg">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-31-2%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%E5%AE%9E%E4%BE%8B.jpg">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-32-1%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%AE%9E%E4%BE%8B.jpg">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-33-2%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.jpg">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/phantom_read.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1650873846555.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1650875129562.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1650875207176.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1650897393027.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1650898012282.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1650900198762.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1650900288062.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1650900546538.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1650957070916.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1650957504388.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1650957883071.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1650959125776.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1650959522543.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1650960042591.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1650960214857.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651153649950.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651153842808.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651153977055.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651154063137.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651154092511.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651154127091.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651155157883.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651157169184.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651157557490.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651157569892.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651157708035.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651217991131.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651218067477.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651157886841.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651157909096.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651157929374.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651157994414.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651158015821.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651158032322.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651158117353.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652081406202.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652081470079.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652082843720.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652086149005.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652086201026.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652086806953.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652086850681.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652087407447.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652169004023.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652169192227.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652170474789.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652170745354.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652173036069.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652173276644.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652173558534.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652173592799.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652173669364.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652173708240.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652173731122.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652173783442.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652173794633.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652173831831.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652173949806.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652174650001.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652174882766.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652174991719.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652342298513.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652342452791.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652342593186.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652344319600.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652344953665.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652345215447.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652345400446.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652345657788.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652345739133.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652345887656.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652346900849.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652346954347.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373231333532333737372e706e67.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373231343434323638372e706e67.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232303434303435312e706e67.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232303833313834332e706e67.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313331333831392e706e67.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651307939016.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651307988699.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651307996814.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651308003294.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651320185635.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651393998025.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651395019178.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651415857990.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651481620005.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651481862505.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651481874818.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651482155999.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651741342257.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651741901928.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651483798762.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651497441083.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651758403654.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651758478245.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651497979915.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651498396421.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651499248866.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651558597258.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651558603939.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651558638351.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651558648806.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651559606567.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651560453447.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651561526629.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651561876661.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651562209398.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651562471166.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651562707743.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651562819770.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651562846169.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651562944756.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651563249209.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651827877071.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651828065888.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651828226607.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651886095147.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651886137530.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651886935823.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651888551880.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651888559444.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651890657023.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651908943761.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651909261231.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651911811794.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651911900429.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651912021363.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651912164535.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651912356028.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651912394286.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651912445005.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651912521199.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651912610232.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651912651986.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651912669153.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651912961466.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651912972253.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651912982025.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651912991132.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651913001481.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651913014989.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651913025657.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651913181475.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651913282692.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651913320851.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651913686382.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1651913783543.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652348444218.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652429016082.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652430305898.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652431025956.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652431463999.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652462253464.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652443319986.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652443344519.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652450290525.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652495493057.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652495571131.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652495968713.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652496020652.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652496079386.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652496104951.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652496322341.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652496673385.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652497523655.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652498741807.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652515436179.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652516168388.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652516682376.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652516907424.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652516948614.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652516956893.png">
<meta property="og:image" content="http://example.com/2022/04/22/MySQL/1652516971520.png">
<meta property="article:published_time" content="2022-04-22T08:38:55.000Z">
<meta property="article:modified_time" content="2022-07-23T13:29:06.215Z">
<meta property="article:author" content="翔仔">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/04/22/MySQL/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="翔仔"><img width="96" loading="lazy" src="/images/tx.jpg" alt="翔仔"><span class="site-author-status" title="不想上学">😭</span></a><div class="site-author-name"><a href="/about/">翔仔</a></div><span class="site-name">翔仔的博客</span><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="我的主页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">28</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">10</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">21</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&amp;uin=910426929&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/YunYouJun" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="985391895@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL"><span class="toc-number">1.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">MySQL基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">逻辑架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM%E4%B8%8EInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.1.</span> <span class="toc-text">MyISAM与InnoDB的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%8EInnoDB%E9%94%81%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">锁机制与InnoDB锁算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">mysql逻辑架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%89%96%E6%9E%90"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1.逻辑架构剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">1.1服务器处理客户端请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2Connectors"><span class="toc-number">1.2.3.1.2.</span> <span class="toc-text">1.2Connectors</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3%E7%AC%AC%E4%B8%80%E5%B1%82%EF%BC%9A%E8%BF%9E%E6%8E%A5%E5%B1%82"><span class="toc-number">1.2.3.1.3.</span> <span class="toc-text">1.3第一层：连接层</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4%E7%AC%AC%E4%BA%8C%E5%B1%82%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%B1%82"><span class="toc-number">1.2.3.1.4.</span> <span class="toc-text">1.4第二层：服务层</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-5%E7%AC%AC%E4%B8%89%E5%B1%82%EF%BC%9A%E5%BC%95%E6%93%8E%E5%B1%82"><span class="toc-number">1.2.3.1.5.</span> <span class="toc-text">1.5第三层：引擎层</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-6%E7%AC%AC%E5%9B%9B%E5%B1%82%EF%BC%9A%E5%AD%98%E5%82%A8%E5%B1%82"><span class="toc-number">1.2.3.1.6.</span> <span class="toc-text">1.6第四层：存储层</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-7%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.3.1.7.</span> <span class="toc-text">1.7小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.SQL执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1MySQl%E4%B8%AD%E7%9A%84SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">2.1MySQl中的SQL执行流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2MySQL8%E4%B8%ADSQL%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.3.2.2.</span> <span class="toc-text">2.2MySQL8中SQL执行原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E7%A1%AE%E8%AE%A4profiling%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF"><span class="toc-number">1.2.3.2.2.1.</span> <span class="toc-text">1.确认profiling是否开启</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%A4%9A%E6%AC%A1%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%90%8CSQL%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.2.3.2.2.2.</span> <span class="toc-text">2.多次执行相同SQL查询</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E6%9F%A5%E7%9C%8Bprofiles"><span class="toc-number">1.2.3.2.2.3.</span> <span class="toc-text">3.查看profiles</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3MySQL5-7%E4%B8%ADSQL%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.3.2.3.</span> <span class="toc-text">2.3MySQL5.7中SQL执行原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E5%BC%80%E5%90%AF%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">1.2.3.2.3.1.</span> <span class="toc-text">1.配置文件中开启查询缓存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E9%87%8D%E5%90%AFmysql%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.3.2.3.2.</span> <span class="toc-text">2.重启mysql服务</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E5%BC%80%E5%90%AF%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">1.2.3.2.3.3.</span> <span class="toc-text">3.开启查询执行计划</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E6%89%A7%E8%A1%8C%E8%AF%AD%E5%8F%A5%E4%B8%A4%E6%AC%A1"><span class="toc-number">1.2.3.2.3.4.</span> <span class="toc-text">4.执行语句两次</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-%E6%9F%A5%E7%9C%8Bprofiles"><span class="toc-number">1.2.3.2.3.5.</span> <span class="toc-text">5.查看profiles</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-%E6%9F%A5%E7%9C%8Bprofile"><span class="toc-number">1.2.3.2.3.6.</span> <span class="toc-text">6.查看profile</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4SQL%E8%AF%AD%E6%B3%95%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.2.3.2.4.</span> <span class="toc-text">2.4SQL语法顺序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%86%B2%E6%B1%A0-buffer-pool"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3.数据库缓冲池(buffer pool)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1%E7%BC%93%E5%86%B2%E6%B1%A0-VS-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">1.2.3.3.1.</span> <span class="toc-text">3.1缓冲池 VS 查询缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2%E7%BC%93%E5%86%B2%E6%B1%A0%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.3.3.2.</span> <span class="toc-text">3.2缓冲池如何读取数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3%E6%9F%A5%E7%9C%8B-%E8%AE%BE%E7%BD%AE%E7%BC%93%E5%86%B2%E6%B1%A0%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.2.3.3.3.</span> <span class="toc-text">3.3查看&#x2F;设置缓冲池的大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4%E5%A4%9A%E4%B8%AABuffer-Pool%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.2.3.3.4.</span> <span class="toc-text">3.4多个Buffer Pool实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5%E5%BC%95%E7%94%B3%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.3.3.5.</span> <span class="toc-text">3.5引申问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.3.</span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9F%A5%E7%9C%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.查看存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.设置系统默认的存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%BE%E7%BD%AE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.设置表的存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%97%B6%E6%8C%87%E5%AE%9A%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.1创建表时指定存储引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">3.2修改表的存储引擎</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.4.</span> <span class="toc-text">4.引擎介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1InnoDB%E5%BC%95%E6%93%8E%EF%BC%9A%E5%85%B7%E5%A4%87%E5%A4%96%E9%94%AE%E6%94%AF%E6%8C%81%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">4.1InnoDB引擎：具备外键支持功能的事务存储引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2MyIASM%E5%BC%95%E6%93%8E%EF%BC%9A%E4%B8%BB%E8%A6%81%E7%9A%84%E9%9D%9E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">4.2MyIASM引擎：主要的非事务处理存储引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">4.3引擎对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-MyIASM%E5%92%8CInnoDB"><span class="toc-number">1.3.5.</span> <span class="toc-text">5.MyIASM和InnoDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%98%BF%E9%87%8C%E3%80%81%E6%B7%98%E5%AE%9D%E7%94%A8%E5%93%AA%E4%B8%AA"><span class="toc-number">1.3.6.</span> <span class="toc-text">6.阿里、淘宝用哪个</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%A1%A5%E5%85%85"><span class="toc-number">1.3.7.</span> <span class="toc-text">7.补充</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-InnoDB%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">1.InnoDB表的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-InnoDb%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">2.InnoDb架构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8D%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.3.8.</span> <span class="toc-text">sql性能下降的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E7%A7%8Djoin%E7%90%86%E8%AE%BA"><span class="toc-number">1.3.9.</span> <span class="toc-text">七种join理论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">索引的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">为什么使用索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">索引及其优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%A8%E6%BC%94"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">InnoDB中索引的推演</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B9%8B%E5%89%8D%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">1.4.1.3.1.</span> <span class="toc-text">索引之前的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%A1%B5%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">1.4.1.3.1.1.</span> <span class="toc-text">在一个页中的查找</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8%E5%BE%88%E5%A4%9A%E9%A1%B5%E4%B8%AD%E6%9F%A5%E6%89%BE"><span class="toc-number">1.4.1.3.1.2.</span> <span class="toc-text">在很多页中查找</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.1.3.2.</span> <span class="toc-text">设计索引</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-number">1.4.1.3.2.1.</span> <span class="toc-text">简单的索引设计方案</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#InnoDB%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="toc-number">1.4.1.3.2.2.</span> <span class="toc-text">InnoDB中的索引方案</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.3.3.</span> <span class="toc-text">常见的索引概念</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.1.3.3.1.</span> <span class="toc-text">聚簇索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%EF%BC%88%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E3%80%81%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="toc-number">1.4.1.3.3.2.</span> <span class="toc-text">二级索引（辅助索引、非聚簇索引）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.1.3.4.</span> <span class="toc-text">联合索引</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#InnoDB%E7%9A%84B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.4.1.3.4.1.</span> <span class="toc-text">InnoDB的B+树索引的注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyISAM%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">MyISAM中的索引方案</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#MyISAM%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.1.4.0.1.</span> <span class="toc-text">MyISAM索引的原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#MyISAM%E4%B8%8EInnoDb%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.1.4.0.2.</span> <span class="toc-text">MyISAM与InnoDb对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">索引的代价</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E6%8B%A9%E7%9A%84%E5%90%88%E7%90%86%E6%80%A7"><span class="toc-number">1.4.1.6.</span> <span class="toc-text">MySQL数据结构选择的合理性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E8%A1%A8%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.1.6.1.</span> <span class="toc-text">全表遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Hash%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.1.6.2.</span> <span class="toc-text">Hash索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.4.1.6.3.</span> <span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AVL%E6%A0%91"><span class="toc-number">1.4.1.6.4.</span> <span class="toc-text">AVL树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-Tree"><span class="toc-number">1.4.1.6.5.</span> <span class="toc-text">B-Tree</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-Tree-1"><span class="toc-number">1.4.1.6.6.</span> <span class="toc-text">B+Tree</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#R%E6%A0%91"><span class="toc-number">1.4.1.6.7.</span> <span class="toc-text">R树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.4.1.6.8.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.4.2.</span> <span class="toc-text">索引的创建与设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">1.索引的声明与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.2.1.1.</span> <span class="toc-text">1.1索引的分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.1.2.</span> <span class="toc-text">1.2创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.1.2.1.</span> <span class="toc-text">1.创建表的时候创建索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%9C%A8%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E8%A1%A8%E4%B8%8A%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.1.2.2.</span> <span class="toc-text">2.在已经存在的表上创建索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-MySQL8-0%E7%B4%A2%E5%BC%95%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">2.MySQL8.0索引新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1%E6%94%AF%E6%8C%81%E9%99%8D%E5%BA%8F%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.2.1.</span> <span class="toc-text">2.1支持降序索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2%E9%9A%90%E8%97%8F%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.2.2.</span> <span class="toc-text">2.2隐藏索引</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">3.索引的设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.3.1.</span> <span class="toc-text">3.1哪些情况适合创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%AD%97%E6%AE%B5%E7%9A%84%E6%95%B0%E5%80%BC%E6%9C%89%E5%94%AF%E4%B8%80%E6%80%A7%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">1.4.2.3.1.1.</span> <span class="toc-text">1.字段的数值有唯一性的限制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E9%A2%91%E7%B9%81%E4%BD%9C%E4%B8%BAwhere%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-number">1.4.2.3.1.2.</span> <span class="toc-text">2.频繁作为where查询条件的字段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E7%BB%8F%E5%B8%B8-GROUP-BY-%E5%92%8C-ORDER-BY-%E7%9A%84%E5%88%97"><span class="toc-number">1.4.2.3.1.3.</span> <span class="toc-text">3. 经常 GROUP BY 和 ORDER BY 的列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-UPDATE%E3%80%81DELETE%E7%9A%84-WHERE-%E6%9D%A1%E4%BB%B6%E5%88%97"><span class="toc-number">1.4.2.3.1.4.</span> <span class="toc-text">4. UPDATE、DELETE的 WHERE 条件列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-DISTINCT%E5%AD%97%E6%AE%B5%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.3.1.5.</span> <span class="toc-text">5.DISTINCT字段需要创建索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-%E5%A4%9A%E8%A1%A8JOIN%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C%E6%97%B6%EF%BC%8C%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.4.2.3.1.6.</span> <span class="toc-text">6.多表JOIN连接操作时，创建索引注意事项</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7-%E4%BD%BF%E7%94%A8%E5%88%97%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%B0%8F%E7%9A%84%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.3.1.7.</span> <span class="toc-text">7.使用列的类型小的创建索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#8-%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E7%BC%80%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.3.1.8.</span> <span class="toc-text">8.使用字符串前缀创建索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#9-%E5%8C%BA%E5%88%86%E5%BA%A6%E9%AB%98-%E6%95%A3%E5%88%97%E6%80%A7%E9%AB%98-%E7%9A%84%E5%88%97%E9%80%82%E5%90%88%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.3.1.9.</span> <span class="toc-text">9.区分度高(散列性高)的列适合作为索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#10-%E4%BD%BF%E7%94%A8%E6%9C%80%E9%A2%91%E7%B9%81%E7%9A%84%E5%88%97%E6%94%BE%E5%88%B0%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A6%E4%BE%A7"><span class="toc-number">1.4.2.3.1.10.</span> <span class="toc-text">10.使用最频繁的列放到联合索引的左侧</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#11-%E5%9C%A8%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E9%83%BD%E8%A6%81%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%BC%98%E4%BA%8E%E5%8D%95%E5%80%BC%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.3.1.11.</span> <span class="toc-text">11.在多个字段都要建立索引的情况下，联合索引优于单值索引</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2%E9%99%90%E5%88%B6%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">1.4.2.3.2.</span> <span class="toc-text">3.2限制索引的数目</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.3.3.</span> <span class="toc-text">3.3哪些情况不适合创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%9C%A8where%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%88%B0%E7%9A%84%E5%AD%97%E6%AE%B5%EF%BC%8C%E4%B8%8D%E8%A6%81%E8%AE%BE%E7%BD%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.3.3.1.</span> <span class="toc-text">1.在where中使用不到的字段，不要设置索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E9%87%8F%E5%B0%8F%E7%9A%84%E8%A1%A8%E6%9C%80%E5%A5%BD%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.3.3.2.</span> <span class="toc-text">2.数据量小的表最好不要使用索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E6%9C%89%E5%A4%A7%E9%87%8F%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%97%E4%B8%8A%E4%B8%8D%E8%A6%81%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.3.3.3.</span> <span class="toc-text">3.有大量重复数据的列上不要建立索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E9%81%BF%E5%85%8D%E5%AF%B9%E7%BB%8F%E5%B8%B8%E6%9B%B4%E6%96%B0%E7%9A%84%E8%A1%A8%E5%88%9B%E5%BB%BA%E8%BF%87%E5%A4%9A%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.3.3.4.</span> <span class="toc-text">4.避免对经常更新的表创建过多的索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%94%A8%E6%97%A0%E5%BA%8F%E7%9A%84%E5%80%BC%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.3.3.5.</span> <span class="toc-text">5.不建议用无序的值作为索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-%E5%88%A0%E9%99%A4%E4%B8%8D%E5%86%8D%E4%BD%BF%E7%94%A8%E6%88%96%E5%BE%88%E5%B0%91%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.3.3.6.</span> <span class="toc-text">6.删除不再使用或很少使用的索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7-%E4%B8%8D%E8%A6%81%E5%AE%9A%E4%B9%89%E5%86%97%E4%BD%99%E6%88%96%E9%87%8D%E5%A4%8D%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.3.3.7.</span> <span class="toc-text">7.不要定义冗余或重复的索引</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4%E5%B0%8F%E7%BB%93"><span class="toc-number">1.4.2.3.4.</span> <span class="toc-text">3.4小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">性能分析工具的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">1.数据库服务器的优化步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">2.查看系统性能参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BB%9F%E8%AE%A1SQL%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%88%90%E6%9C%AC%EF%BC%9Alast-query-cost"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">3.统计SQL的查询成本：last_query_cost</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AE%9A%E4%BD%8D%E6%89%A7%E8%A1%8C%E6%85%A2%E7%9A%84SQL%EF%BC%9A%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">4.定位执行慢的SQL：慢查询日志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1%E5%BC%80%E5%90%AF%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">1.4.3.4.1.</span> <span class="toc-text">4.1开启慢查询日志</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%BC%80%E5%90%AFslow-query-log"><span class="toc-number">1.4.3.4.1.1.</span> <span class="toc-text">1.开启slow_query_log</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E4%BF%AE%E6%94%B9long-query-time%E9%98%88%E5%80%BC"><span class="toc-number">1.4.3.4.1.2.</span> <span class="toc-text">2.修改long_query_time阈值</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2%E6%9F%A5%E7%9C%8B%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%95%B0%E7%9B%AE"><span class="toc-number">1.4.3.4.2.</span> <span class="toc-text">4.2查看慢查询数目</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">1.4.3.4.3.</span> <span class="toc-text">4.3案例演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4%E6%B5%8B%E8%AF%95%E5%8F%8A%E5%88%86%E6%9E%90"><span class="toc-number">1.4.3.4.4.</span> <span class="toc-text">4.4测试及分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%9Amysqldumpslow"><span class="toc-number">1.4.3.4.5.</span> <span class="toc-text">4.5慢查询日志分析工具：mysqldumpslow</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6%E5%85%B3%E9%97%AD%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">1.4.3.4.6.</span> <span class="toc-text">4.6关闭慢查询日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-7%E5%88%A0%E9%99%A4%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">1.4.3.4.7.</span> <span class="toc-text">4.7删除慢查询日志</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9F%A5%E7%9C%8BSQL%E6%89%A7%E8%A1%8C%E6%88%90%E6%9C%AC%EF%BC%9ASHOW-PROFILE"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">5.查看SQL执行成本：SHOW PROFILE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%88%86%E6%9E%90%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%EF%BC%9AEXPLAIN"><span class="toc-number">1.4.3.6.</span> <span class="toc-text">6.分析查询语句：EXPLAIN</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.3.6.1.</span> <span class="toc-text">6.1概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.3.6.2.</span> <span class="toc-text">6.2基本语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87"><span class="toc-number">1.4.3.6.3.</span> <span class="toc-text">6.3数据准备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4EXPLAIN%E5%90%84%E5%88%97%E4%BD%9C%E7%94%A8"><span class="toc-number">1.4.3.6.4.</span> <span class="toc-text">6.4EXPLAIN各列作用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-table"><span class="toc-number">1.4.3.6.4.1.</span> <span class="toc-text">1.table</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-id"><span class="toc-number">1.4.3.6.4.2.</span> <span class="toc-text">2.id</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-select-type"><span class="toc-number">1.4.3.6.4.3.</span> <span class="toc-text">3.select_type</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-partitions"><span class="toc-number">1.4.3.6.4.4.</span> <span class="toc-text">4.partitions</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-type%E2%98%86"><span class="toc-number">1.4.3.6.4.5.</span> <span class="toc-text">5.type☆</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-possible-keys%E5%92%8Ckey"><span class="toc-number">1.4.3.6.4.6.</span> <span class="toc-text">6.possible_keys和key</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7-key-len%E2%98%86"><span class="toc-number">1.4.3.6.4.7.</span> <span class="toc-text">7.key_len☆</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#8-ref"><span class="toc-number">1.4.3.6.4.8.</span> <span class="toc-text">8.ref</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#9-rows%E2%98%86"><span class="toc-number">1.4.3.6.4.9.</span> <span class="toc-text">9.rows☆</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#10-filtered"><span class="toc-number">1.4.3.6.4.10.</span> <span class="toc-text">10.filtered</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#11-Extra%E2%98%86"><span class="toc-number">1.4.3.6.4.11.</span> <span class="toc-text">11.Extra☆</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.</span> <span class="toc-text">InnoDB数据存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A%E9%A1%B5"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.数据库的存储结构：页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E7%A3%81%E7%9B%98%E4%B8%8E%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">1.1磁盘与内存交互基本单位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E9%A1%B5%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">1.2页结构概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E9%A1%B5%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">1.3页的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4%E9%A1%B5%E7%9A%84%E4%B8%8A%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">1.4页的上层结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%A1%B5%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.页的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9AFile-Header-%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8-%E5%92%8CFile-Trailer-%E6%96%87%E4%BB%B6%E5%B0%BE%E9%83%A8"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">第一部分：File Header(文件头部)和File Trailer(文件尾部)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.6.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0"><span class="toc-number">1.6.1.</span> <span class="toc-text">基本概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">什么是事务？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E7%89%A9"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">数据库事物</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84ACID"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">数据库的ACID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">事物实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.6.1.5.</span> <span class="toc-text">事务的状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.6.2.</span> <span class="toc-text">使用事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%98%BE%E7%A4%BA%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">1.显示事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9A%90%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">2.隐式事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9A%90%E5%BC%8F%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">3.隐式提交数据的情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E7%89%A9%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.6.3.</span> <span class="toc-text">事物的隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">并发一致性问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">MySQL默认隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.6.3.4.</span> <span class="toc-text">设置隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E6%83%85%E5%86%B5%E6%BC%94%E7%A4%BA"><span class="toc-number">1.6.3.5.</span> <span class="toc-text">实际情况演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E5%88%86%E7%B1%BB"><span class="toc-number">1.6.4.</span> <span class="toc-text">事务的常见分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.5.</span> <span class="toc-text">MySQL事务日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-redo%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">1.redo日志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81redo-log"><span class="toc-number">1.6.5.1.1.</span> <span class="toc-text">1.1为什么需要redo log</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2redo-log%E7%9A%84%E5%A5%BD%E5%A4%84%E3%80%81%E7%89%B9%E7%82%B9"><span class="toc-number">1.6.5.1.2.</span> <span class="toc-text">1.2redo log的好处、特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3redo%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.6.5.1.3.</span> <span class="toc-text">1.3redo的组成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4redo%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.5.1.4.</span> <span class="toc-text">1.4redo的整体流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-5redo-log%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5-redo-log-buffer-gt-redo-log-file"><span class="toc-number">1.6.5.1.5.</span> <span class="toc-text">1.5redo log刷盘策略(redo log buffer -&gt; redo log file)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-6%E4%B8%8D%E5%90%8C%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5%E6%BC%94%E7%A4%BA"><span class="toc-number">1.6.5.1.6.</span> <span class="toc-text">1.6不同刷盘策略演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-7%E5%86%99%E5%85%A5redo-log-buffer%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.5.1.7.</span> <span class="toc-text">1.7写入redo log buffer过程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E8%A1%A5%E5%85%85%E6%A6%82%E5%BF%B5%EF%BC%9AMini-Transaction"><span class="toc-number">1.6.5.1.7.1.</span> <span class="toc-text">1.补充概念：Mini-Transaction</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-redo%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5log-buffer"><span class="toc-number">1.6.5.1.7.2.</span> <span class="toc-text">2.redo日志写入log buffer</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-redo-log-block%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">1.6.5.1.7.3.</span> <span class="toc-text">3.redo log block的结构图</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8redo-log-file"><span class="toc-number">1.6.5.1.8.</span> <span class="toc-text">1.8redo log file</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-9redo-log%E5%B0%8F%E7%BB%93"><span class="toc-number">1.6.5.1.9.</span> <span class="toc-text">1.9redo log小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Undo%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">Undo日志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3Undo%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.5.2.1.</span> <span class="toc-text">1.如何理解Undo日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Undo%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.6.5.2.2.</span> <span class="toc-text">2.Undo日志的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-undo%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.5.2.3.</span> <span class="toc-text">3.undo的存储结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4undo%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.5.2.4.</span> <span class="toc-text">4undo的类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-undo-log%E7%9A%84%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F"><span class="toc-number">1.6.5.2.5.</span> <span class="toc-text">5.undo log的声明周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E5%B0%8F%E7%BB%93"><span class="toc-number">1.6.5.2.6.</span> <span class="toc-text">6小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.6.</span> <span class="toc-text">其他数据库日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-MySQL%E6%94%AF%E6%8C%81%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">1.MySQL支持的日志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1%E6%97%A5%E5%BF%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.6.1.1.</span> <span class="toc-text">1.1日志类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2%E6%97%A5%E5%BF%97%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">1.6.6.1.2.</span> <span class="toc-text">1.2日志的弊端</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%9A%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97-general-query-log"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">2.通用查询日志(general query log)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF"><span class="toc-number">1.6.6.2.1.</span> <span class="toc-text">2.1问题场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%8A%B6%E6%80%81"><span class="toc-number">1.6.6.2.2.</span> <span class="toc-text">2.2查看当前状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3%E5%90%AF%E5%8A%A8%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.6.2.3.</span> <span class="toc-text">2.3启动日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.6.2.4.</span> <span class="toc-text">2.4查看日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5%E5%81%9C%E6%AD%A2%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.6.2.5.</span> <span class="toc-text">2.5停止日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6%E5%88%A0%E9%99%A4-%E5%88%B7%E6%96%B0%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.6.2.6.</span> <span class="toc-text">2.6删除&#x2F;刷新日志</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%EF%BC%88error-log%EF%BC%89"><span class="toc-number">1.6.6.3.</span> <span class="toc-text">3.错误日志（error log）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1%E5%90%AF%E5%8A%A8%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.6.3.1.</span> <span class="toc-text">3.1启动日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.6.3.2.</span> <span class="toc-text">3.2查看日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3%E5%88%A0%E9%99%A4-%E5%88%B7%E6%96%B0%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.6.3.3.</span> <span class="toc-text">3.3删除&#x2F;刷新日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4MySQL8-0%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.6.6.3.4.</span> <span class="toc-text">3.4MySQL8.0新特性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%EF%BC%88bin-log%EF%BC%89"><span class="toc-number">1.6.6.4.</span> <span class="toc-text">4.二进制日志（bin log）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5"><span class="toc-number">1.6.6.4.1.</span> <span class="toc-text">4.1查看默认情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2%E6%97%A5%E5%BF%97%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.6.6.4.2.</span> <span class="toc-text">4.2日志参数设置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.6.4.3.</span> <span class="toc-text">4.3查看日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="toc-number">1.6.6.4.4.</span> <span class="toc-text">4.4使用日志恢复数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5%E5%88%A0%E9%99%A4%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.6.4.5.</span> <span class="toc-text">4.5删除二进制日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF"><span class="toc-number">1.6.6.4.6.</span> <span class="toc-text">4.6其他场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89%E5%86%8D%E8%B0%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97-binlog"><span class="toc-number">1.6.6.5.</span> <span class="toc-text">5.（重点）再谈二进制日志(binlog)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.6.5.1.</span> <span class="toc-text">5.1写入机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2binlog%E4%B8%8Eredolog%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.6.5.2.</span> <span class="toc-text">5.2binlog与redolog对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">1.6.6.5.3.</span> <span class="toc-text">5.3两阶段提交</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.6.6.</span> <span class="toc-text">6.中继日志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.6.6.6.1.</span> <span class="toc-text">6.1介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2%E6%9F%A5%E7%9C%8B%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.6.6.2.</span> <span class="toc-text">6.2查看中继日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3%E6%81%A2%E5%A4%8D%E7%9A%84%E5%85%B8%E5%9E%8B%E9%94%99%E8%AF%AF"><span class="toc-number">1.6.6.6.3.</span> <span class="toc-text">6.3恢复的典型错误</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E9%94%81"><span class="toc-number">1.7.</span> <span class="toc-text">封锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.1.</span> <span class="toc-text">锁类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.7.2.</span> <span class="toc-text">封锁协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E9%9A%90%E5%BC%8F%E4%B8%8E%E6%98%BE%E7%A4%BA%E9%94%81%E5%AE%9A"><span class="toc-number">1.7.3.</span> <span class="toc-text">MySQL隐式与显示锁定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.7.4.</span> <span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-MySQL%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E8%AE%BF%E9%97%AE%E7%9B%B8%E5%90%8C%E8%AE%B0%E5%BD%95"><span class="toc-number">1.7.5.</span> <span class="toc-text">2.MySQL并发事务访问相同记录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E8%AF%BB-%E8%AF%BB%E6%83%85%E5%86%B5"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">2.1读-读情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E5%86%99-%E5%86%99%E6%83%85%E5%86%B5"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">2.2写-写情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E8%AF%BB-%E5%86%99%E6%88%96%E5%86%99-%E8%AF%BB%E6%83%85%E5%86%B5"><span class="toc-number">1.7.5.3.</span> <span class="toc-text">2.3读-写或写-读情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.7.5.4.</span> <span class="toc-text">2.4并发问题的解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%94%81%E7%9A%84%E4%B8%8D%E5%90%8C%E8%A7%92%E5%BA%A6%E5%88%86%E7%B1%BB"><span class="toc-number">1.7.6.</span> <span class="toc-text">3.锁的不同角度分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%92%E5%88%86-%E8%AF%BB%E9%94%81%E3%80%81%E5%86%99%E9%94%81"><span class="toc-number">1.7.6.1.</span> <span class="toc-text">3.1从数据操作的类型划分:读锁、写锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B2%92%E5%BA%A6%E4%B8%8A%E5%88%92%E5%88%86%EF%BC%9A%E8%A1%A8%E7%BA%A7%E9%94%81%E3%80%81%E8%A1%8C%E7%BA%A7%E9%94%81%E3%80%81%E9%A1%B5%E7%BA%A7%E9%94%81"><span class="toc-number">1.7.6.2.</span> <span class="toc-text">3.2从数据操作的粒度上划分：表级锁、行级锁、页级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%A1%A8%E9%94%81%EF%BC%88Table-Lock%EF%BC%89"><span class="toc-number">1.7.6.2.1.</span> <span class="toc-text">1.表锁（Table Lock）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-InnoDB%E8%A1%8C%E9%94%81"><span class="toc-number">1.7.6.2.2.</span> <span class="toc-text">2.InnoDB行锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%A1%B5%E9%94%81"><span class="toc-number">1.7.6.2.3.</span> <span class="toc-text">3.页锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3%E4%BB%8E%E5%AF%B9%E9%94%81%E7%9A%84%E6%80%81%E5%BA%A6%E5%88%92%E5%88%86%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.7.6.3.</span> <span class="toc-text">3.3从对锁的态度划分：乐观锁、悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.7.6.3.1.</span> <span class="toc-text">1.悲观锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">1.7.6.3.2.</span> <span class="toc-text">2.乐观锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B8%A4%E7%A7%8D%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.7.6.3.3.</span> <span class="toc-text">3.两种锁的使用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4%E6%8C%89%E5%8A%A0%E9%94%81%E6%96%B9%E5%BC%8F%E5%88%92%E5%88%86%EF%BC%9A%E6%98%BE%E7%A4%BA%E9%94%81%E3%80%81%E9%9A%90%E5%BC%8F%E9%94%81"><span class="toc-number">1.7.6.4.</span> <span class="toc-text">3.4按加锁方式划分：显示锁、隐式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%9A%90%E5%BC%8F%E9%94%81"><span class="toc-number">1.7.6.4.1.</span> <span class="toc-text">1.隐式锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%98%BE%E7%A4%BA%E9%94%81"><span class="toc-number">1.7.6.4.2.</span> <span class="toc-text">2.显示锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5%E5%85%B6%E4%BB%96%E9%94%81%E4%B9%8B%EF%BC%9A%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">1.7.6.5.</span> <span class="toc-text">3.5其他锁之：全局锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6%E5%85%B6%E4%BB%96%E9%94%81%E4%B9%8B%EF%BC%9A%E6%AD%BB%E9%94%81"><span class="toc-number">1.7.6.6.</span> <span class="toc-text">3.6其他锁之：死锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%94%81%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.7.</span> <span class="toc-text">4.锁的内存结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E3%80%81%E9%94%81%E7%9B%91%E6%8E%A7"><span class="toc-number">1.7.8.</span> <span class="toc-text">5.、锁监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%97%B4%E6%AD%87%E9%94%81%E5%8A%A0%E9%94%81%E8%A7%84%E5%88%99%EF%BC%8811%E6%A1%88%E4%BE%8B%EF%BC%89"><span class="toc-number">1.7.9.</span> <span class="toc-text">6.间歇锁加锁规则（11案例）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E9%97%B4%E6%AD%87%E9%94%81"><span class="toc-number">1.7.9.1.</span> <span class="toc-text">案例一：唯一索引等值查询间歇锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E9%94%81"><span class="toc-number">1.7.9.2.</span> <span class="toc-text">案例二：非唯一索引等值查询锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%89%EF%BC%9A%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E9%94%81"><span class="toc-number">1.7.9.3.</span> <span class="toc-text">案例三：主键索引范围查询锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%9B%9B%EF%BC%9A%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E9%94%81"><span class="toc-number">1.7.9.4.</span> <span class="toc-text">案例四：非唯一索引范围查询锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%BA%94%EF%BC%9A%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2-bug"><span class="toc-number">1.7.9.5.</span> <span class="toc-text">案例五：唯一索引范围查询 bug</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%85%AD%EF%BC%9A%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E4%B8%8A%E5%AD%98%E5%9C%A8%E2%80%9C%E7%AD%89%E5%80%BC%E2%80%9D%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.7.9.6.</span> <span class="toc-text">案例六：非唯一索引上存在“等值”的例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%83%EF%BC%9Alimit%E8%AF%AD%E5%8F%A5%E5%8A%A0%E9%94%81"><span class="toc-number">1.7.9.7.</span> <span class="toc-text">案例七：limit语句加锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%85%AB%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.7.9.8.</span> <span class="toc-text">案例八：一个死锁的例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%B9%9D%EF%BC%9Aorder-by%E7%B4%A2%E5%BC%95%E6%8E%92%E5%BA%8F%E7%9A%84%E9%97%B4%E6%AD%87%E9%94%811"><span class="toc-number">1.7.9.9.</span> <span class="toc-text">案例九：order by索引排序的间歇锁1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%8D%81%EF%BC%9Aorder-by%E7%B4%A2%E5%BC%95%E6%8E%92%E5%BA%8F%E7%9A%84%E9%97%B4%E9%9A%99%E9%94%812"><span class="toc-number">1.7.9.10.</span> <span class="toc-text">案例十：order by索引排序的间隙锁2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%8D%81%E4%B8%80%EF%BC%9Aupdate%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BE%8B%E5%AD%90-%E5%85%88%E6%8F%92%E5%85%A5%E5%90%8E%E5%88%A0%E9%99%A4"><span class="toc-number">1.7.9.11.</span> <span class="toc-text">案例十一：update修改数据的例子-先插入后删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">1.8.</span> <span class="toc-text">多版本并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%89%8D%E6%8F%90%E6%A6%82%E8%A6%81"><span class="toc-number">1.8.1.</span> <span class="toc-text">1.前提概要</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFMVCC%EF%BC%9F"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">1.什么是MVCC？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">2.当前读和快照读</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="toc-number">1.8.1.2.1.</span> <span class="toc-text">2.1快照读</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">1.8.1.2.2.</span> <span class="toc-text">2.2当前读</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BD%93%E5%89%8D%E8%AF%BB%E3%80%81%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8CMVCCC%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">3.当前读、快照读和MVCCC的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-MVCC%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">1.8.2.</span> <span class="toc-text">2.MVCC能解决什么问题？好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.8.3.</span> <span class="toc-text">3.MVCC实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E5%89%8D%E6%8F%90%E7%9F%A5%E8%AF%86"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">3.1前提知识</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%86%8D%E8%B0%88%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.8.3.1.1.</span> <span class="toc-text">1.再谈隔离级别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5%E3%80%81undo-log%E7%89%88%E6%9C%AC%E9%93%BE"><span class="toc-number">1.8.3.1.2.</span> <span class="toc-text">2.隐藏字段、undo log版本链</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8BReadView"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">3.2实现原理之ReadView</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFReadView"><span class="toc-number">1.8.3.2.1.</span> <span class="toc-text">什么是ReadView</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">1.8.3.2.2.</span> <span class="toc-text">设计思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ReadView%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.8.3.2.3.</span> <span class="toc-text">ReadView的规则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">3.3整体流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">1.8.4.</span> <span class="toc-text">4.举例说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1READ-COMITED%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">4.1READ COMITED隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2REPEATABLE-READ%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">4.2REPEATABLE READ隔离级别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB"><span class="toc-number">1.8.5.</span> <span class="toc-text">5.如何解决幻读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-MVCC%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.6.</span> <span class="toc-text">6.MVCC相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RR%E5%A6%82%E4%BD%95%E5%9C%A8RC%E5%9F%BA%E7%A1%80%E4%B8%8A%E8%A7%A3%E5%86%B3%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%9F"><span class="toc-number">1.8.6.1.</span> <span class="toc-text">RR如何在RC基础上解决不可重复读？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RC%E3%80%81RR%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84InnoDB%E5%BF%AB%E7%85%A7%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">1.8.6.2.</span> <span class="toc-text">RC、RR级别下的InnoDB快照读有什么不同？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.7.</span> <span class="toc-text">7.总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">1.9.</span> <span class="toc-text">主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-1"><span class="toc-number">1.9.1.</span> <span class="toc-text">1.概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E8%83%BD%E5%8A%9B"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">1.1如何提升数据库并发能力</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">1.2主从复制的作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.9.2.</span> <span class="toc-text">2.主从复制的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">2.1原理剖析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">2.2复制的基本原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%80%E4%B8%BB%E4%B8%80%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%90%AD%E5%BB%BA"><span class="toc-number">1.9.3.</span> <span class="toc-text">3.一主一从架构搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">3.1准备工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">3.2主机配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E4%BB%8E%E6%9C%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.9.3.3.</span> <span class="toc-text">3.3.从机配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4%E4%B8%BB%E6%9C%BA%EF%BC%9A%E5%BB%BA%E7%AB%8B%E8%B4%A6%E6%88%B7%E5%B9%B6%E6%8E%88%E6%9D%83"><span class="toc-number">1.9.3.4.</span> <span class="toc-text">3.4主机：建立账户并授权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5%E4%BB%8E%E6%9C%BA%EF%BC%9A%E9%85%8D%E7%BD%AE%E9%9C%80%E8%A6%81%E5%A4%8D%E5%88%B6%E7%9A%84%E4%B8%BB%E6%9C%BA"><span class="toc-number">1.9.3.5.</span> <span class="toc-text">3.5从机：配置需要复制的主机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6%E6%B5%8B%E8%AF%95"><span class="toc-number">1.9.3.6.</span> <span class="toc-text">3.6测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7%E5%81%9C%E6%AD%A2%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">1.9.3.7.</span> <span class="toc-text">3.7停止主从同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8%E5%90%8E%E7%BB%AD"><span class="toc-number">1.9.3.8.</span> <span class="toc-text">3.8后续</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.4.</span> <span class="toc-text">4.同步数据一致性的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1%E7%90%86%E8%A7%A3%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">4.1理解主从延迟问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">4.2主从延迟问题原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F"><span class="toc-number">1.9.4.3.</span> <span class="toc-text">4.3如何减少主从延迟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.4.4.</span> <span class="toc-text">4.4如何解决一致性问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%9F%A5%E8%AF%86%E5%BB%B6%E4%BC%B8"><span class="toc-number">1.9.5.</span> <span class="toc-text">5.知识延伸</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="toc-number">1.10.</span> <span class="toc-text">数据库备份与恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%89%A9%E7%90%86%E5%A4%87%E4%BB%BD%E4%B8%8E%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD"><span class="toc-number">1.10.1.</span> <span class="toc-text">1.物理备份与逻辑备份</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-mysqldump%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD"><span class="toc-number">1.10.2.</span> <span class="toc-text">2.mysqldump实现逻辑备份</span></a></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://example.com/2022/04/22/MySQL/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="翔仔"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="翔仔的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">MySQL</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2022-04-22 16:38:55" itemprop="dateCreated datePublished" datetime="2022-04-22T16:38:55+08:00">2022-04-22</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2022-07-23 21:29:06" itemprop="dateModified" datetime="2022-07-23T21:29:06+08:00">2022-07-23</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">数据库</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/MySQL/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">MySQL</span></a></span></div><div class="post-author"><span class="author-name">翔仔</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h2><blockquote>
<p>关系型数据库介绍</p>
</blockquote>
<p>MySQL–关系型数据库，即一种建立在关系模型的基础上的数据库，</p>
<p>数据被存放在数据表中，表中每一行数据存放一条记录 <img src="/2022/04/22/MySQL/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png" alt="img" loading="lazy"> </p>
<blockquote>
<p>常见的关系型数据库</p>
</blockquote>
<p> MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ……。 </p>
<h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h2><blockquote>
<p>查看MySQL提供的所有存储引擎</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure>

<p> <img src="/2022/04/22/MySQL/mysql-engines.png" alt="查看MySQL提供的所有存储引擎" loading="lazy"> </p>
<p> 从上图我们可以查看出 MySQL 当<strong>前默认的存储引擎是 InnoDB</strong>，并且在 5.7 版本所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 <strong>InnoDB 支持事务。</strong> </p>
<blockquote>
<p>查看MySQL当前默认的存储引擎</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">like</span> &quot;table_name&quot;;</span><br></pre></td></tr></table></figure>

<p> <img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%9F%A5%E7%9C%8B%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png" alt="查看表的存储引擎" loading="lazy"> </p>
<h3 id="MyISAM与InnoDB的区别"><a href="#MyISAM与InnoDB的区别" class="headerlink" title="MyISAM与InnoDB的区别"></a>MyISAM与InnoDB的区别</h3><p><img src="/2022/04/22/MySQL/1650617400745.png" alt="1650617400745" loading="lazy"></p>
<p>1.是否支持行级锁</p>
<p>MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁</p>
<p>2.是否支持事物</p>
<p>MyISAM不支持事物</p>
<p>InnoDB提供事物支持，具有提交(commit)和回滚(rollback)事物的能力</p>
<p>3.是否支持外键</p>
<p>MyISAM不支持，InnoDB支持</p>
<p><strong>补充：</strong>一般不建议使用外键，应用层面可以解决</p>
<p>4.是否支持数据库异常崩溃后的安全恢复</p>
<p>MyISAM不支持，InnoDB支持</p>
<p>使用InnoDB的数据库再异常崩溃后，数据库重新启动会保证数据恢复到崩溃前的状态，依赖于redo log</p>
<p><strong>补充：</strong></p>
<ul>
<li>InnoDB使用redo log（重做日志）保证事物的持久性，使用undo log（回滚日志）保证事物的原子性</li>
<li>InnoDB通过锁机制、MVCC等手段来保证事物的隔离性(默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> 可重复读)</li>
<li>保证了事物的持久性、原子性、隔离性后，一致性才能得到保证</li>
</ul>
<p>5.是否支持MVCC</p>
<p>MyISAM不支持，InnoDB支持</p>
<h3 id="锁机制与InnoDB锁算法"><a href="#锁机制与InnoDB锁算法" class="headerlink" title="锁机制与InnoDB锁算法"></a>锁机制与InnoDB锁算法</h3><blockquote>
<p>MyISAM和InnoDB存储引擎使用的锁</p>
</blockquote>
<ul>
<li>MyISAM采用表级锁</li>
<li>InnoDB采用行级锁和表级锁，默认行级锁</li>
</ul>
<blockquote>
<p>表级锁与行级锁对比</p>
</blockquote>
<ul>
<li>表级锁：锁粒度最大，实现简单，资源消耗少，加锁块，不会出现死锁，锁冲突概率高，并发度低</li>
<li>行级锁：锁粒度最小，实现复杂。资源消耗大，会出现死锁，加锁慢，锁冲突概率低，并发度高</li>
</ul>
<blockquote>
<p>InnoDB存储的引擎的锁的算法</p>
</blockquote>
<ul>
<li>Record lock：记录锁，当个行记录上的锁</li>
<li>Gap lock：间歇锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap临键锁，锁定一个范围，包括记录本身</li>
</ul>
<h3 id="mysql逻辑架构"><a href="#mysql逻辑架构" class="headerlink" title="mysql逻辑架构"></a>mysql逻辑架构</h3><h4 id="1-逻辑架构剖析"><a href="#1-逻辑架构剖析" class="headerlink" title="1.逻辑架构剖析"></a>1.逻辑架构剖析</h4><h5 id="1-1服务器处理客户端请求"><a href="#1-1服务器处理客户端请求" class="headerlink" title="1.1服务器处理客户端请求"></a>1.1服务器处理客户端请求</h5><p>首先MySQL是典型的C/S架构，即Client/Server架构，服务器端程序使用的<strong>mysqld</strong>。</p>
<p>不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：**客户端进程向服务器进程发送一段文本(sql语句)，服务器进程处理后再向客户端进程发送一段文本(处理结果)**。</p>
<p>那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示：<img src="/2022/04/22/MySQL/1652518964447.png" alt="1652518964447" loading="lazy"></p>
<p>下面具体展开一下：</p>
<p><img src="/2022/04/22/MySQL/1646898016786.png" alt="1646898016786" loading="lazy"></p>
<p><img src="/2022/04/22/MySQL/1652519977029.png" alt="1652519977029" loading="lazy"></p>
<p>mysql在存储引擎的架构上采用 <strong>插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离</strong> 。这种架构可以根据业务的需求和实际需求选择核实的存储引擎</p>
<p><strong>逻辑架构分层</strong></p>
<p><img src="/2022/04/22/MySQL/1646898307983.png" alt="1646898307983" loading="lazy"></p>
<h5 id="1-2Connectors"><a href="#1-2Connectors" class="headerlink" title="1.2Connectors"></a>1.2Connectors</h5><p>Connectors，指的是不同语言中与SQL的交互。MySQL首先是一个网络程序，在TCP之上定义了自己的应用层协议。所以要使用MySQL，我们可以编写代码，跟MySQL Server’建立TCP连接’,之后按照其定义好的协议进行交互。或者比较方便的办法是调用SDK，比如Native c API、JDBC、PHP等各种语言MySQL Connector，或者通过ODBC。但通过SDK来访问MySQL，本质上还是在TCP连接上<strong>通过MySQL协议跟MySQL进行交互。</strong></p>
<h5 id="1-3第一层：连接层"><a href="#1-3第一层：连接层" class="headerlink" title="1.3第一层：连接层"></a>1.3第一层：连接层</h5><p>最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcplip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
<p>系统（客户端）访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。 </p>
<p>经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。 </p>
<ul>
<li><p><strong>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</strong> </p>
</li>
<li><p><strong>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</strong> </p>
</li>
</ul>
<p><strong>TCP</strong> 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。 </p>
<p><strong>思考：</strong>一个系统只会和MySQL服务器建立一个连接吗只能有一个系统和MySQL服务器建立连接吗？</p>
<p>当然不是，多个系统都可以和MySQL服务器建立连接，每个系统建立的连接肯定不止一个。所以，为了解决TCP无限创建与TCP频繁创建销毁带来的资源耗尽、性能下降问题。MySQL服务器里有专门的<strong>TCP连接池</strong>限制连接数，采用<strong>长连接模式</strong>复用TCP连接，来解决上述问题。<img src="/2022/04/22/MySQL/1652535888245.png" alt="1652535888245" loading="lazy"></p>
<p>TCP连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p>
<p>这些内容都归纳到MySQL的连接管理组件中。</p>
<p>所以<strong>连接管理</strong>的职责是负责认证、管理连接、获取权限信息。</p>
<h5 id="1-4第二层：服务层"><a href="#1-4第二层：服务层" class="headerlink" title="1.4第二层：服务层"></a>1.4第二层：服务层</h5><p>第二层架构主要完成大多少的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>
<p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p>
<p>在该层，服务器会解析查询并创建内部的解析树，并对其完成相应的优化：如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。</p>
<p>如果是SELECT语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>
<ul>
<li><p><strong>SQL Interface: SQL接口</strong></p>
<ul>
<li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface </li>
<li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口 </li>
</ul>
</li>
<li><p><strong>Parser:</strong> <strong>解析器</strong> </p>
<ul>
<li>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。 </li>
<li>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建 <strong>语法树</strong> ，并根据数据字典丰富查询语法树，会 <strong>验证该客户端是否具有执行该查询的权限</strong> 。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。 </li>
</ul>
</li>
<li><p><strong>Optimizer：查询优化器</strong></p>
<ul>
<li><p>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个<strong>执行计划</strong> 。 </p>
</li>
<li><p>这个执行计划表明应该 <strong>使用哪些索引</strong> 进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</p>
</li>
<li><p>它使用“ <strong>选取-投影-连接</strong> ”策略进行查询。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id，name FROM student WHERE gender = &#x27;女&#x27;</span><br></pre></td></tr></table></figure>

<p>这个SELECT查询先根据WHERE语句进行 选取 ，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性 投影 ，而不是将属性全部取出以后再进行过滤，将这两个查询条件 连接 起来生成最终查询结果。</p>
</li>
</ul>
</li>
<li><p><strong>Caches &amp; Buffers****： 查询缓存组件</strong> </p>
<ul>
<li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。 </li>
<li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</li>
<li>这个查询缓存可以在 <strong>不同客户端之间共享</strong> 。</li>
<li>从MySQL5.7.20开始，不推荐使用查询缓存，并在MySQL8.0中删除</li>
</ul>
</li>
</ul>
<h5 id="1-5第三层：引擎层"><a href="#1-5第三层：引擎层" class="headerlink" title="1.5第三层：引擎层"></a>1.5第三层：引擎层</h5><p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。</p>
<hr>
<p>和其它数据库相比，MysQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用，主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构</strong>将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。同时开源的MySQL还允许<strong>开发人员设置自己的存储引擎</strong>。</p>
<p>这种高效的模块化架构为那些希望专门针对特定应用程序需求（例如数据仓库、事务处理或高可用性情况)的人提供了巨大的好处，同时享受使用一组独立于任何接口和服务的优势存储引擎。</p>
<p>插件式存储引擎层（ </p>
<p>Storage Engines），<strong>真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</strong>，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p>
<p>MySQL8.0.25默认支持的存储引擎如下：<img src="/2022/04/22/MySQL/1652537418134.png" alt="1652537418134" loading="lazy"></p>
<h5 id="1-6第四层：存储层"><a href="#1-6第四层：存储层" class="headerlink" title="1.6第四层：存储层"></a>1.6第四层：存储层</h5><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在<strong>文件系统</strong>上，以<strong>文件</strong>的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用DAS、NAS、SAN等各种存储系统</p>
<h5 id="1-7小结"><a href="#1-7小结" class="headerlink" title="1.7小结"></a>1.7小结</h5><p>MySQL架构图，为了熟悉SQL执行流程方便，简化如下：<img src="/2022/04/22/MySQL/1652537586450.png" alt="1652537586450" loading="lazy"></p>
<p>简化为三层结构： </p>
<ol>
<li><p>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端； </p>
</li>
<li><p>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关； </p>
</li>
<li><p>存储引擎层：与数据库文件打交道，负责数据的存储和读取。 </p>
</li>
</ol>
<h4 id="2-SQL执行流程"><a href="#2-SQL执行流程" class="headerlink" title="2.SQL执行流程"></a>2.SQL执行流程</h4><h5 id="2-1MySQl中的SQL执行流程"><a href="#2-1MySQl中的SQL执行流程" class="headerlink" title="2.1MySQl中的SQL执行流程"></a>2.1MySQl中的SQL执行流程<img src="/2022/04/22/MySQL/1652537735170.png" alt="1652537735170" loading="lazy"></h5><p><strong>MySQL的查询流程：</strong></p>
<p><strong>1.查询缓存：</strong>Server如果在查询缓存中发现了这条SQL语句，就会直接将结果返回客户端；如果没有，就进入解析器阶段，需要说明的是，因为查询缓存的效率不高，所以在MySQL8.0之后就抛弃了缓存<img src="/2022/04/22/MySQL/1652537967648.png" alt="1652537967648" loading="lazy"></p>
<p>MysQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。<strong>之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中</strong>。key 是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。如果语句不在查询缓存中，就会继续后面的执行阶段。<strong>执行完成后，执行结果会被存入查询缓存中</strong>。所以，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个<strong>效率会很高。</strong></p>
<p><strong>大多数情况下查询缓存就是鸡肋，为什么？</strong></p>
<p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的鲁棒性大大降低，只有<strong>相同的查询操作才会命中查询缓存</strong>。两个查询请求在任何字符上的不同（例如:空格、注释、大小写)，都会导致缓存不会命中。因此MySQL的<strong>查询缓存命中率不高</strong>。</p>
<p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如mysql 、information_schema、performance_schema数据库中的表，那这个请求就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数NOW，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的!</p>
<p>此外，既然是缓存，那就有它<strong>缓存失效的时候</strong>。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了<strong>INSERT、UPDATE、DELETE、TRUNCATE TABLE、ALTER TABLE、DROP TABLE或 DROP DATABASE语句</strong>，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除!对于<strong>更新压力大的数据库</strong>来说，查询缓存的命中率会非常低。</p>
<p><strong>总之，因为查询缓存往往弊大于利，查询缓存的失效非常频繁</strong></p>
<p>一般建议大家在静态表里使用查询缓存，什么叫<strong>静态表</strong>呢?就是一般我们极少更新的表。比如，一个系统配置表、字典表，这张表上的查询才适合使用查询缓存。好在MysQL也提供了这种°按需使用”的方式。你可以将my.cnf参数query_cache_type设置成DEMAND，代表当sql语句中有sQL_CACHE关键词时才缓存。比如:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#query_cache_type有3个值 0代表关闭查询缓存OFF、1代表开启ON、2(DEMAND)</span></span><br><span class="line"><span class="attr">query_cache_type</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure>

<p>这样对于默认的SQL语句都不使用查询缓存。而对于确定的需要使用查询缓存的语句，可以显示启动。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SQL_CACHE * from test where ID=5;</span><br></pre></td></tr></table></figure>

<p>查看当前mysql实例是否开启缓存机制<img src="/2022/04/22/MySQL/1652538635126.png" alt="1652538635126" loading="lazy"></p>
<p>监控查询缓存的命中率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like&#x27;%Qcache%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652538678438.png" alt="1652538678438" loading="lazy"></p>
<p>运行结果解析：<img src="/2022/04/22/MySQL/1652538722505.png" alt="1652538722505" loading="lazy"></p>
<p><strong>2.解析器：</strong>在解析器中对SQL语句进行语法分析、语义分析<img src="/2022/04/22/MySQL/1652538795661.png" alt="1652538795661" loading="lazy"></p>
<p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MysQL需要知道你要做什么，因此需要对sQL语句做解析。SQL语句的分析分为词法分析与语法分析。</p>
<p>分析器先做“<strong>词法分析</strong>”。你输入的是由多个字符串和空格组成的一条sQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。</p>
<p>MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p>
<p>接着，要做“<strong>语法分析</strong>”。根据词法分析的结果，语法分析器(比如: Bison）会根据语法规则，判断你输入的这个sQL语句是否<strong>满足MySQL语法。</strong></p>
<p>如果你的语句不对，就会收到”You have an error in your SQL syntax”的错误提醒，比如下面这个语句from写成了”rom”。<img src="/2022/04/22/MySQL/1652538956398.png" alt="1652538956398" loading="lazy"></p>
<p>如果SQL语句正确，会生成一个语法树：<img src="/2022/04/22/MySQL/1652538998937.png" alt="1652538998937" loading="lazy"></p>
<p>下图是SQL词法分析的过程步骤：<img src="/2022/04/22/MySQL/1652539048751.png" alt="1652539048751" loading="lazy"></p>
<p>至此，我们解析器的工作任务基本完成。接下来进入优化器。</p>
<p><strong>3.优化器：</strong>在优化器中会确定SQL语句的执行路径，比如是根据<strong>全表检索</strong>，还是根据<strong>索引检索</strong>等。</p>
<p>经过了优化器，MySQL就知道你要做什么了，在开始执行之前，还要经过优化器的处理。一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。<img src="/2022/04/22/MySQL/1652539426761.png" alt="1652539426761" loading="lazy"></p>
<p>比如：优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有很多表关联(join)的时候，决定各个表的连接顺序，还有表达式简化、子查询转为连接、外连接转为内连接等。</p>
<p>举例：如下语句是执行连个表的join：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test1 join test2 using(ID) where test1.name=&#x27;zhangwei&#x27; and test2.name=&#x27;mysql高级课程&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652539642752.png" alt="1652539642752" loading="lazy"></p>
<p>在查询优化器中，可以分为<strong>逻辑查询优化和物理查询优化</strong>阶段</p>
<p>逻辑查询优化就是通过改变sQL语句的内容来使得sQL查询更高效，同时为物理查询优化提供更多的候选执行计划。通常采用的方式是对sQL语句进行<strong>等价变换</strong>，对查询进行<strong>重写</strong>，而查询重写的数学基础就是关系代数。对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等。</p>
<p>物理查询优化是基于关系代数进行的查询重写，而关系代数的每一步都对应着物理计算，这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划。在这个阶段里对于单表和多表连接的操作，需要高效地使用索引，提升查询效率。</p>
<p><strong>4.执行器：</strong></p>
<p>截止到现在，还没有去读写真实的表，仅仅只是产出了一个执行计划，就进入了<strong>执行器阶段</strong><img src="/2022/04/22/MySQL/1652539903395.png" alt="1652539903395" loading="lazy"></p>
<p>在执行之前需要判断该用户是否<strong>具有权限</strong>。如果没有，会返回权限错误，如果有，就执行SQL查询并返回结果。在MySQL8.0以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test where id=1;</span><br></pre></td></tr></table></figure>

<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，调用存储引擎API对表进行的读写。存储引擎API只是抽象接口，下面还有个<strong>存储引擎层</strong>，具体实现还是要看表选择的存储引擎。</p>
<p>比如表test中，ID字段没有索引，那么执行器的执行流程是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是1，如果不是则跳过，如果是则将这行存在结果集中； 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 </span><br><span class="line"></span><br><span class="line">执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</span><br></pre></td></tr></table></figure>

<p>至此，这个语句执行完成。对于有索引的表，逻辑也差不多。</p>
<p>SQL语句在MySQL中的流程是：<img src="/2022/04/22/MySQL/1652540277507.png" alt="1652540277507" loading="lazy"></p>
<h5 id="2-2MySQL8中SQL执行原理"><a href="#2-2MySQL8中SQL执行原理" class="headerlink" title="2.2MySQL8中SQL执行原理"></a>2.2MySQL8中SQL执行原理</h5><p>前面的结构图很复杂，我们需要抓取最核心的部分:sQL的执行原理。不同的DBMS的SQL的执行原理是相通的，只是在不同的软件中，各有各的实现路径。</p>
<p>既然一条SQL语句会经历不同的模块，那我们就来看下，在不同的模块中，SQL执行所使用的资源(时间）是怎样的。如何在MySQL中对一条sQL语句的执行时间进行分析。</p>
<h6 id="1-确认profiling是否开启"><a href="#1-确认profiling是否开启" class="headerlink" title="1.确认profiling是否开启"></a>1.确认profiling是否开启</h6><p>了解查询语句底层执行的过程：<strong>select @@profiling;或者show variables like ’%profiling%‘</strong>查看是否开启计划。开其他可以让MySQL收集在SQL执行时所使用的资源情况，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@profiling;</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#x27;profiling&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652544675225.png" alt="1652544675225" loading="lazy"></p>
<p>profiling=0代表关闭，需要把profiling打开，即设置为1；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set profiling=1;</span><br></pre></td></tr></table></figure>

<p>profiling功能由MySQL会话变量：profiling控制，默认是OFF（关闭状态）。</p>
<h6 id="2-多次执行相同SQL查询"><a href="#2-多次执行相同SQL查询" class="headerlink" title="2.多次执行相同SQL查询"></a>2.多次执行相同SQL查询</h6><p>执行一个SQL查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from employees;</span><br></pre></td></tr></table></figure>

<h6 id="3-查看profiles"><a href="#3-查看profiles" class="headerlink" title="3.查看profiles"></a>3.查看profiles</h6><p>查看当前会话所产生的所有profiles：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profiles; # 显示最近的几次查询</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652545083419.png" alt="1652545083419" loading="lazy"></p>
<p>4.查看profile</p>
<p>显示执行计划，查看程序的执行步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652545182764.png" alt="1652545182764" loading="lazy"></p>
<p>当然你也可以查询指定的 Query ID，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile for query 7;</span><br></pre></td></tr></table></figure>

<p>查询 SQL 的执行时间结果和上面是一样的。 </p>
<p>此外，还可以查询更丰富的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile cpu,block io for query 6;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652545241033.png" alt="1652545241033" loading="lazy"></p>
<p>继续：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile cpu,block io for query 7;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652545268118.png" alt="1652545268118" loading="lazy"></p>
<p>1.除了查看CPU、io阻塞等参数情况，还可以查看下列参数的利用情况。<img src="/2022/04/22/MySQL/1652545631906.png" alt="1652545631906" loading="lazy"></p>
<p>2.发现两次查询当前情况都一致，说明没有缓存一说。</p>
<p><strong>在8.0版本之后，MySQL不再支持缓存的查询</strong>。一旦有数据表更新，缓存都将清空，因此只有数据表是静态时，或者数据表很少发生变化时，使用缓存查询才有价值，否则如果数据表经常更新，反而增加了查询时间</p>
<h5 id="2-3MySQL5-7中SQL执行原理"><a href="#2-3MySQL5-7中SQL执行原理" class="headerlink" title="2.3MySQL5.7中SQL执行原理"></a>2.3MySQL5.7中SQL执行原理</h5><p>上述操作在MySQL5.7中测试，发现前后两次相同的sql语句，执行的查询过程仍然是相同的。不是会使用 缓存吗？这里我们需要 <strong>显式开启查询缓存模式</strong> 。在MySQL5.7中如下设置：</p>
<h6 id="1-配置文件中开启查询缓存"><a href="#1-配置文件中开启查询缓存" class="headerlink" title="1.配置文件中开启查询缓存"></a>1.配置文件中开启查询缓存</h6><p>在etc/my/cnf中新增一行：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">query_cache_type</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure>

<h6 id="2-重启mysql服务"><a href="#2-重启mysql服务" class="headerlink" title="2.重启mysql服务"></a>2.重启mysql服务</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<h6 id="3-开启查询执行计划"><a href="#3-开启查询执行计划" class="headerlink" title="3.开启查询执行计划"></a>3.开启查询执行计划</h6><p>由于重启过服务，需要重新执行如下指令，开启profiling</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set profiling=1;</span><br></pre></td></tr></table></figure>

<h6 id="4-执行语句两次"><a href="#4-执行语句两次" class="headerlink" title="4.执行语句两次"></a>4.执行语句两次</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from locations; </span><br><span class="line">mysql&gt; select * from locations;</span><br></pre></td></tr></table></figure>

<h6 id="5-查看profiles"><a href="#5-查看profiles" class="headerlink" title="5.查看profiles"></a>5.查看profiles</h6><p><img src="/2022/04/22/MySQL/1652545439062.png" alt="1652545439062" loading="lazy"></p>
<h6 id="6-查看profile"><a href="#6-查看profile" class="headerlink" title="6.查看profile"></a>6.查看profile</h6><p>显示执行计划，查看程序的执行步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile for query 1;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652545506354.png" alt="1652545506354" loading="lazy"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile for query 2;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652545518977.png" alt="1652545518977" loading="lazy"></p>
<p>结论不言而喻。执行编号2时，比执行编号1时少了很多信息，从截图中可以看出查询语句直接从缓存中获取数据。 </p>
<ul>
<li><p>注意1：SQL必须是一致的，否则，不能命中缓存。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#虽然查询结果一致，但并没有命中缓存</span><br><span class="line">select * from mydb.mytbl where id=2;</span><br><span class="line">select * from mydb,mydbl where id&gt;1 and id&lt;3;</span><br></pre></td></tr></table></figure></li>
<li><p>注意2：</p>
<p>同样的开启缓存的配置信息如果在MySQL8.0中添加。重启服务会报错<img src="/2022/04/22/MySQL/1652545974710.png" alt="1652545974710" loading="lazy"></p>
</li>
</ul>
<p>分别在MySQL5.7和 MySQL8.0执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%query_cache%&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>5.7:</p>
<p><img src="/2022/04/22/MySQL/1652546085128.png" alt="1652546085128" loading="lazy"></p>
</li>
<li><p>8.0:</p>
<p><img src="/2022/04/22/MySQL/1652546094715.png" alt="1652546094715" loading="lazy"></p>
</li>
</ul>
<h5 id="2-4SQL语法顺序"><a href="#2-4SQL语法顺序" class="headerlink" title="2.4SQL语法顺序"></a>2.4SQL语法顺序</h5><p>随着Mysql版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而动态调整执行顺序。 </p>
<p>需求：查询每个部门年龄高于20岁的人数且高于20岁人数不能少于2人，显示人数最多的第一名部门信息 </p>
<p>下面是经常出现的查询顺序： <img src="/2022/04/22/MySQL/1652546136658.png" alt="1652546136658" loading="lazy"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#7   select</span><br><span class="line">#1   from</span><br><span class="line">#3   join</span><br><span class="line">#2   on</span><br><span class="line">#4   where</span><br><span class="line">#5   group by</span><br><span class="line">#6   having</span><br><span class="line">#8   distinct</span><br><span class="line">#9   order by</span><br><span class="line">#10  limit</span><br></pre></td></tr></table></figure>

<h4 id="3-数据库缓冲池-buffer-pool"><a href="#3-数据库缓冲池-buffer-pool" class="headerlink" title="3.数据库缓冲池(buffer pool)"></a>3.数据库缓冲池(buffer pool)</h4><p><strong>InnoDB</strong> 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请 <strong>占用内存来作为数据缓冲池</strong> ，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 <strong>Buffer Pool</strong> 之后才可以访 问。 </p>
<p>这样做的好处是可以让磁盘活动最小化，从而 <strong>减少与磁盘直接进行 I/O 的时间</strong> 。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p>
<h5 id="3-1缓冲池-VS-查询缓存"><a href="#3-1缓冲池-VS-查询缓存" class="headerlink" title="3.1缓冲池 VS 查询缓存"></a>3.1缓冲池 VS 查询缓存</h5><p><strong>缓冲池和查询缓存是一个东西吗？不是。</strong> </p>
<p><strong>1.</strong> <strong>缓冲池（Buffer Pool）</strong> </p>
<p>首先我们需要了解在 InnoDB 存储引擎中，缓冲池都包括了哪些。 </p>
<p>在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存，如下图所示： <img src="/2022/04/22/MySQL/1652546669589.png" alt="1652546669589" loading="lazy"></p>
<p>从图中，你能看到 InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。 </p>
<p><strong>缓冲池的重要性：</strong></p>
<p>对于<strong>使用InnoDB</strong>作为存储引擎的表来说，不管是用于存储用户数据的索引（包括聚簇索引和二级索引)，还是各种系统数据，都是以<strong>页</strong>的形式存放在<strong>表空间</strong>中的，而所谓的表空间只不过是InnoDB对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。但是各位也都知道，磁盘的速度慢的跟乌龟一样，怎么能配得上“快如风，疾如电”的CPU呢?这里，缓冲池可以帮助我们消除cPU和磁盘之间的鸿沟。所以InnoDB存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会<strong>把完整的页的数据全部加载到内存中</strong>，也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以<strong>省去磁盘IO</strong>的开销了。</p>
<p><strong>缓存原则：</strong></p>
<p>“ <strong>位置 * 频次</strong> ”这个原则，可以帮我们对 I/O 访问效率进行优化。 </p>
<p>首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。 </p>
<p>其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会 <strong>优先对使用频次高的热数据进行加载 。</strong></p>
<p><strong>缓冲池的预读特性：</strong></p>
<p>了解了缓冲池的作用之后，我们还需要了解缓冲池的另一个特性:<strong>预读。</strong><br>缓冲池的作用就是提升I/O效率，而我们进行读取数据的时候存在一个“局部性原理”，也就是说我们使用了一些数据，<strong>大概率还会使用它周围的一些数据</strong>，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘Ⅳ/O操作。</p>
<p><strong>2.查询缓存</strong></p>
<p>那么什么是查询缓存呢?</p>
<p>查询缓存是提前把<strong>查询结果缓存</strong>起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</p>
<p>缓冲池服务于数据库整体的I/o操作，它们的共同点都是通过缓存的机制来提升效率。</p>
<h5 id="3-2缓冲池如何读取数据"><a href="#3-2缓冲池如何读取数据" class="headerlink" title="3.2缓冲池如何读取数据"></a>3.2缓冲池如何读取数据</h5><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在乐冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p>
<p>缓存在数据库中的结构和作用如下图所示:<img src="/2022/04/22/MySQL/1652547231676.png" alt="1652547231676" loading="lazy"></p>
<p><strong>如果我们执行SQL语句的时候更新了缓冲池中的数据，那么这些数据会马上 同步到磁盘上吗</strong></p>
<p>实际上，当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会<strong>以一定的频率刷新</strong>到磁盘上。注意并不是每次发生更新操作，都会立刻进行磁盘回写。缓冲池会采用一种叫做<strong>checkpoint的机制</strong>将数据回写到磁盘上，I这样做的好处就是提升了数据库的整体性能。</p>
<p>比如，当<strong>缓冲池不够用</strong>时，需要释放掉一些不常用的页，此时就可以强行采用checkpoint 的方式，将不常用的脏页回写到磁盘上，然后再从缓冲池中将这些页释放掉。这里脏页(dirty page)指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。</p>
<h5 id="3-3查看-设置缓冲池的大小"><a href="#3-3查看-设置缓冲池的大小" class="headerlink" title="3.3查看/设置缓冲池的大小"></a>3.3查看/设置缓冲池的大小</h5><p>如果使用的是MySQL MyISAM存储引擎，它缓存索引，不缓存数据，对应的键缓存参数为<strong>key_buffer_size</strong>，可以用它进行查看。</p>
<p>如果使用的是MySQL InnoDB存储引擎，可以通过查看<strong>innodb_buffer)pool_size</strong>变量来查看缓冲池大小。命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_buffer_poll_size&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652547658710.png" alt="1652547658710" loading="lazy"></p>
<p>能看到此时InnoDB的缓冲池大小只有134217728/1024=128MB。可以修改缓冲池大小，比如改为256MB，方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global innodb_buffer_pool_size =  268435456;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652547780982.png" alt="1652547780982" loading="lazy"></p>
<p>或者：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[server]</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_size</span> = <span class="string">268435456</span></span><br></pre></td></tr></table></figure>

<p>然后再看下修改后的缓冲池大小，此时已成功修改<img src="/2022/04/22/MySQL/1652547840923.png" alt="1652547840923" loading="lazy"></p>
<h5 id="3-4多个Buffer-Pool实例"><a href="#3-4多个Buffer-Pool实例" class="headerlink" title="3.4多个Buffer Pool实例"></a>3.4多个Buffer Pool实例</h5><p>Buffer Pool本质是InnoDB向操作系统申请的一块<strong>连续的内存空间</strong>，在多线程环境下，访问Buffer Pool中的数据都需要<strong>加锁</strong>处理。在Buffer Pool特别大而且多线程并发访问特别高的情况下，单一的Buffer Pool可能会影响请求的处理速度。所以在Buffer Pool特别大的时候，我们可以把它们<strong>拆分成若干个小的Buffer Pool</strong>，每个Buffer Pool都称为一个<strong>实例</strong>，它们都是独立的，独立的去申请内存空间，独立的管理各种链表。所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。</p>
<p>我们可以在服务器启动的时候通过设置<strong>innodb_buffer_pool_instances</strong>的值来修改Buffer Pool实例的个数，比方说这样:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[server]</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_instances</span> = <span class="string">2</span></span><br></pre></td></tr></table></figure>

<p>这样就表明要创建两个<strong>Buffer Pool</strong>实例</p>
<p>查看缓冲池的个数，命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_buffer_pool_instacnces&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652548090555.png" alt="1652548090555" loading="lazy"></p>
<p>那每个<strong>Buffer Pool</strong>实例实际占多少内存空间？使用这个公式算出来：<img src="/2022/04/22/MySQL/1652548155147.png" alt="1652548155147" loading="lazy"></p>
<p>也就是总共的大小除以实例的个数，结果就是每个<strong>Buffer Pool</strong>实例占用的大小。</p>
<p>不过也不是说Buffer Pool实例创建的越多越好，分别<strong>管理各个Buffer Pool也是需要性能开销的</strong>,InnoDB规定:当innodb_buffer_pool_size的值小于1G的时候设置多个实例是无效的，InnoDB会默认把innodb_buffer_pool_instances的值修改为1。而我们鼓励在Buffer Pool大于或等于1G的时候设置多个Buffer Pool实例。</p>
<h5 id="3-5引申问题"><a href="#3-5引申问题" class="headerlink" title="3.5引申问题"></a>3.5引申问题</h5><p>Buffer Pool是MySQL内存结构中的核心的一个组成，可以想象成一个黑盒子。</p>
<p><strong>黑盒子下的更新数据流程</strong></p>
<p>当我们查询数据的时候，会先去Buffer Pool中查询。如果Buffer Pool中不存在，存储引擎会先将数据从磁盘加载到Buffer Pool中，然后将数据返回给客户端;同理，当我们更新某个数据的时候，如果这个数据不存在于BufferPool，同样会先数据加载进来，然后修改修改内存的数据。被修改过的数据会在之后统一刷入磁盘。<img src="/2022/04/22/MySQL/1652548376384.png" alt="1652548376384" loading="lazy"></p>
<p>这个过程看似没啥问题，实则是有问题的。假设我们修改Buffer Pool中的数据成功，但是还没来得及将数据刷入磁盘MySQL就挂了怎么办?按照上图的逻辑，此时更新之后的数据只存在于Buffer Pool中，如果此时MysQL宕机了，这部分数据将会永久地丢失;<br>再者，我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办?连数据持久化的保证、事务回滚都做不到还谈什么崩溃恢复?（redo log &amp; undo log）</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>为了管理方便，人们把<strong>连接管理、查询缓存、语法解析、查询优化</strong>这些并不涉及真实数据存储的功能划分为<strong>MySQL server</strong>的功能，把真实存取数据的功能划分为<strong>存储引擎</strong>的功能。所以在<strong>MySQL server</strong>完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。</p>
<p>MysQL中提到了存储引擎的概念。简而言之，<strong>存储引擎就是指表的类型</strong>。其实存储引擎以前叫做<strong>表处理器</strong>，后来改名为存储引擎，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。</p>
<h3 id="1-查看存储引擎"><a href="#1-查看存储引擎" class="headerlink" title="1.查看存储引擎"></a>1.查看存储引擎</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines  #查询mysql支持的存储引擎</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652580291130.png" alt="1652580291130" loading="lazy"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines \G;</span><br></pre></td></tr></table></figure>

<p>显示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*************************** 1. row *************************** Engine: InnoDB Support: DEFAULT Comment: Supports transactions, row-level locking, and foreign keys Transactions: YES XA: YES Savepoints: YES *************************** 2. row *************************** Engine: MRG_MYISAM Support: YES Comment: Collection of identical MyISAM tables Transactions: NO XA: NO Savepoints: NO *************************** 3. row *************************** Engine: MEMORY Support: YES Comment: Hash based, stored in memory, useful for temporary tables Transactions: NO XA: NO Savepoints: NO *************************** 4. row *************************** Engine: BLACKHOLE Support: YES Comment: /dev/null storage engine (anything you write to it disappears) Transactions: NO XA: NO</span><br><span class="line">2. 设置系统默认的存储引擎</span><br><span class="line">查看默认的存储引擎：</span><br><span class="line">Savepoints: NO *************************** 5. row *************************** Engine: MyISAM Support: YES Comment: MyISAM storage engine Transactions: NO XA: NO Savepoints: NO *************************** 6. row *************************** Engine: CSV Support: YES Comment: CSV storage engine Transactions: NO XA: NO Savepoints: NO *************************** 7. row *************************** Engine: ARCHIVE Support: YES Comment: Archive storage engine Transactions: NO XA: NO Savepoints: NO *************************** 8. row *************************** Engine: PERFORMANCE_SCHEMA Support: YES Comment: Performance Schema Transactions: NO XA: NO Savepoints: NO *************************** 9. row *************************** Engine: FEDERATED Support: NO Comment: Federated MySQL storage engine Transactions: NULL XA: NULL Savepoints: NULL</span><br></pre></td></tr></table></figure>

<h3 id="2-设置系统默认的存储引擎"><a href="#2-设置系统默认的存储引擎" class="headerlink" title="2.设置系统默认的存储引擎"></a>2.设置系统默认的存储引擎</h3><ul>
<li><p>查看默认的存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%storage_engine%&#x27;; </span><br><span class="line">#或</span><br><span class="line">SELECT @@default_storage_engine;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652580474560.png" alt="1652580474560" loading="lazy"></p>
</li>
<li><p>修改默认的存储引擎</p>
</li>
</ul>
<p>如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用 InnoDB 作为表的存储引擎。 </p>
<p>如果我们想改变表的默认存储引擎的话，可以这样写启动服务器的命令行： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET DEFAULT_STORAGE_ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>

<p>或者修改my.cnf文件：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">default-storage-engine</span>=<span class="string">MyISAM</span></span><br><span class="line"><span class="comment"># 重启服务 </span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">restart mysqld.service</span></span><br></pre></td></tr></table></figure>

<h3 id="3-设置表的存储引擎"><a href="#3-设置表的存储引擎" class="headerlink" title="3.设置表的存储引擎"></a>3.设置表的存储引擎</h3><p>存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为 <strong>不同的表设置不同的存储引擎</strong> ，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。</p>
<h4 id="3-1创建表时指定存储引擎"><a href="#3-1创建表时指定存储引擎" class="headerlink" title="3.1创建表时指定存储引擎"></a>3.1创建表时指定存储引擎</h4><p>我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎 InnoDB 。如果我们想显式的指定一下表的存储引擎，那可以这么写： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名( </span><br><span class="line">    建表语句; </span><br><span class="line">) ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure>

<h4 id="3-2修改表的存储引擎"><a href="#3-2修改表的存储引擎" class="headerlink" title="3.2修改表的存储引擎"></a>3.2修改表的存储引擎</h4><p>如果表已经建好了，我们也可以使用下边这个语句来修改表的存储引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure>

<p>比如我们修改一下 <strong>engine_demo_table</strong> 表的存储引擎： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE engine_demo_table ENGINE = InnoDB;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec) </span><br><span class="line">Records: 0 Duplicates: 0 Warnings: 0</span><br></pre></td></tr></table></figure>

<p>这时我们再查看一下 engine_demo_table 的表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE TABLE engine_demo_table\G *************************** 1. row *************************** </span><br><span class="line">Table: engine_demo_table </span><br><span class="line">Create Table: CREATE TABLE `engine_demo_table` ( `i` int(11) DEFAULT NULL </span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<h3 id="4-引擎介绍"><a href="#4-引擎介绍" class="headerlink" title="4.引擎介绍"></a>4.引擎介绍</h3><h4 id="4-1InnoDB引擎：具备外键支持功能的事务存储引擎"><a href="#4-1InnoDB引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="4.1InnoDB引擎：具备外键支持功能的事务存储引擎"></a>4.1InnoDB引擎：具备外键支持功能的事务存储引擎</h4><ul>
<li><p>MySQL从3.23.34a开始就包含InnoDB存储引擎。 大于等于5.5之后，默认采用InnoDB引擎 。 </p>
</li>
<li><p>InnoDB是MySQL的 默认事务型引擎 ，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。 </p>
</li>
<li><p>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。 </p>
</li>
<li><p><strong>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑<strong><strong>InnoDB</strong></strong>引擎。</strong> </p>
</li>
<li><p>数据文件结构：（在《第02章_MySQL数据目录》章节已讲） </p>
<ul>
<li><p>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中） </p>
</li>
<li><p>表名.ibd 存储数据和索引 </p>
</li>
</ul>
</li>
<li><p>InnoDB是 <strong>为处理巨大数据量的最大性能设计 。</strong> </p>
<ul>
<li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除 了。比如： .frm ， .par ， .trn ， .isl ， .db.opt 等都在MySQL8.0中不存在了。 </li>
</ul>
</li>
<li><p>对比MyISAM的存储引擎， InnoDB写的处理效率差一些 ，并且会占用更多的磁盘空间以保存数据和 索引。 </p>
</li>
<li><p>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据， <strong>对内存要求较高</strong> ，而且内存大小对性能有决定性的影响。 </p>
</li>
</ul>
<h4 id="4-2MyIASM引擎：主要的非事务处理存储引擎"><a href="#4-2MyIASM引擎：主要的非事务处理存储引擎" class="headerlink" title="4.2MyIASM引擎：主要的非事务处理存储引擎"></a>4.2MyIASM引擎：主要的非事务处理存储引擎</h4><ul>
<li><p>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM <strong>不支持事务、行级锁、外键</strong> ，有一个毫无疑问的缺陷就是 <strong>崩溃后无法安全恢复</strong> 。 </p>
</li>
<li><p><strong>5.5之前默认的存储引擎</strong> </p>
</li>
<li><p>优势是访问的 速度快 ，对事务完整性没有要求或者以SELECT、INSERT为主的应用 </p>
</li>
<li><p>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高 </p>
</li>
<li><p>数据文件结构：（在《第02章_MySQL数据目录》章节已讲） </p>
<ul>
<li>表名.frm 存储表结构 </li>
<li>表名.MYD 存储数据 (MYData) </li>
<li>表名.MYI 存储索引 (MYIndex) </li>
</ul>
</li>
<li><p>应用场景：只读应用或者以读为主的业务 </p>
</li>
</ul>
<h4 id="4-3引擎对比"><a href="#4-3引擎对比" class="headerlink" title="4.3引擎对比"></a>4.3引擎对比</h4><p><img src="/2022/04/22/MySQL/1652581226906.png" alt="1652581226906" loading="lazy"></p>
<p><img src="/2022/04/22/MySQL/1652581401199.png" alt="1652581401199" loading="lazy"></p>
<h3 id="5-MyIASM和InnoDB"><a href="#5-MyIASM和InnoDB" class="headerlink" title="5.MyIASM和InnoDB"></a>5.MyIASM和InnoDB</h3><p>MySQL5.5之前默认是MyIAM，之后是InnoDB</p>
<p>首先对于InnoDB存储引擎，提供了良好的事务管理、崩溃恢复和并发控制。因为InnoDb存储引擎<strong>支持事务</strong>，所以对于要求事务完整性的场合需要选择InnoDB，比如数据操作除了插入和查询外还包含很多更新、删除操作，像财务系统等对数据准确性要求较高的系统。缺点是<strong>读写效率差，占用内存空间相对比较大</strong>。</p>
<p>其次对于MyISAM存储引擎，如果是<strong>小型应用</strong>，系统以<strong>读操作和插入操作为主</strong>，只有很少的更新、删除操作，并且对事务的要求没有那么高，则可以选择这个存储引擎。MyISAM存储引擎的优势在于<strong>占用空间小，处理速度快</strong>;缺点是<strong>不支持事务的完整性和并发性。</strong></p>
<p><strong>innobd和myisam对比</strong><img src="/2022/04/22/MySQL/1652581514453.png" alt="1652581514453" loading="lazy"></p>
<h3 id="6-阿里、淘宝用哪个"><a href="#6-阿里、淘宝用哪个" class="headerlink" title="6.阿里、淘宝用哪个"></a>6.阿里、淘宝用哪个</h3><p><img src="/2022/04/22/MySQL/1652582611080.png" alt="1652582611080" loading="lazy"></p>
<ul>
<li><strong>Percona</strong> 为 MySQL 数据库服务器进行了改进，在功能和性能上较 MySQL 有很显著的提升。 </li>
<li>该版本提升了在高负载情况下的 InnoDB 的性能、为 DBA 提供一些非常有用的性能诊断工具；另外有更多的参数和命令来控制服务器行为。 </li>
<li>该公司新建了一款存储引擎叫 Xtradb 完全可以替代 Innodb ，并且在性能和并发上做得更好 </li>
<li>阿里巴巴大部分mysql数据库其实使用的percona的原型加以修改。</li>
</ul>
<h3 id="7-补充"><a href="#7-补充" class="headerlink" title="7.补充"></a>7.补充</h3><h4 id="1-InnoDB表的优势"><a href="#1-InnoDB表的优势" class="headerlink" title="1.InnoDB表的优势"></a>1.InnoDB表的优势</h4><p>InnoDB存储引擎在实际应用中拥有诸多优势，比如操作便利、提高了数据库的性能、维护成本低等。如果由于硬件或软件的原因导致服务器崩溃，那么在重启服务器之后不需要进行额外的操作。InnoDB崩溃恢复功能自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行。 InnoDB存储引擎在主内存中维护缓冲池，高频率使用的数据将在内存中直接被处理。这种缓存方式应用于多种信息，加速了处理进程。</p>
<p>在专用服务器上，物理内存中高达80%的部分被应用于缓冲池。如果需要将数据插入不同的表中，可以设置外键加强数据的完整性。更新或者删除数据，关联数据将会被自动更新或删除。如果试图将数据插入从表，但在主表中没有对应的数据，插入的数据将被自动移除。如果磁盘或内存中的数据出现崩溃，在使用脏数据之前，校验和机制会发出警告。当每个表的主键都设置合理时，与这些列有关的操作会被自动优化。插入、更新和删除操作通过做改变缓冲自动机制进行优化。 <strong>InnoDB不仅支持当前读写，也会 缓冲改变的数据到数据流磁盘 。</strong> </p>
<p>InnoDB的性能优势不只存在于长时运行查询的大型表。在同一列多次被查询时，自适应哈希索引会提高查询的速度。使用InnoDB可以压缩表和相关的索引，可以 <strong>在不影响性能和可用性的情况下创建或删除索引</strong> 。对于大型文本和BLOB数据，使用动态行形式，这种存储布局更高效。通过查询INFORMATION_SCHEMA库中的表可以监控存储引擎的内部工作。在同一个语句中，InnoDB表可以与其他存储引擎表混用。即使有些操作系统限制文件大小为2GB，InnoDB仍然可以处理。 <strong>当处理大数据量时，InnoDB兼顾CPU，以达到最大性能 。</strong></p>
<h4 id="2-InnoDb架构"><a href="#2-InnoDb架构" class="headerlink" title="2.InnoDb架构"></a>2.InnoDb架构</h4><p><strong>1.缓冲池</strong>缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。缓冲池使得经常被使用的数据能够直接在内存中获得，从而提高速度。</p>
<p><strong>2.更改缓存</strong>更改缓存是一个特殊的数据结构，当受影响的索引页不在缓存中时，更改缓存会缓存辅助索引页的更改。索引页被其他读取操作时会加载到缓存池，缓存的更改内容就会被合并。不同于集群索 引，辅助索引并非独一无二的。当系统大部分闲置时，清除操作会定期运行，将更新的索引页刷入磁 盘。更新缓存合并期间，可能会大大降低查询的性能。在内存中，更新缓存占用一部分InnoDB缓冲池。在磁盘中，更新缓存是系统表空间的一部分。更新缓存的数据类型由innodb_change_buffering配置项管理。</p>
<p><strong>3.自适应哈希索引</strong>  </p>
<p>自适应哈希索引将负载和足够的内存结合起来，使得InnoDB像内存数据库一样运行，不需要降低事务上的性能或可靠性。这个特性通过innodb_adaptive_hash_index选项配置，或者通过–skip-innodb_adaptive_hash_index命令行在服务启动时关闭。</p>
<p><strong>4.重做日志缓存</strong>重做日志缓存存放要放入重做日志的数据。重做日志缓存大小通过innodb_log_buffer_size配置项配置。重做日志缓存会定期地将日志文件刷入磁盘。大型的重做日志缓存 使得大型事务能够正常运行而不需要写入磁盘。 </p>
<p><strong>5.系统表空间</strong>系统表空间包括InnoDB数据字典、双写缓存、更新缓存和撤销日志，同时也包括表和索引数据。多表共享，系统表空间被视为共享表空间。 </p>
<p><strong>6.双写缓存</strong>双写缓存位于系统表空间中，用于写入从缓存池刷新的数据页。只有在刷新并写入双写缓存后，InnoDB才会将数据页写入合适的位置。</p>
<p><strong>7.撤销日志</strong>撤销日志是一系列与事务相关的撤销记录的集合，包含如何撤销事务最近的更改。如果其他事务要查询原始数据，可以从撤销日志记录中追溯未更改的数据。撤销日志存在于撤销日志片段中，这些片段包含于回滚片段中。</p>
<p><strong>8.每个表一个文件的表空间</strong>每个表一个文件的表空间是指每个单独的表空间创建在自身的数据文件中， </p>
<p>而不是系统表空间中。这个功能通过innodb_file_per_table配置项开启。每个表空间由一个单独的.ibd数据文件代表，该文件默认被创建在数据库目录中。 </p>
<p><strong>9.通用表空间</strong>使用CREATE TABLESPACE语法创建共享的InnoDB表空间。通用表空间可以创建在MySQL数据目录之外能够管理多个表并支持所有行格式的表。</p>
<p><strong>10.撤销表空间</strong>撤销表空间由一个或多个包含撤销日志的文件组成。撤销表空间的数量由 innodb_undo_tablespaces配置项配置。</p>
<p><strong>11.临时表空间</strong> 用户创建的临时表空间和基于磁盘的内部临时表都创建于临时表空间。innodb_temp_data_file_path配置项定义了相关的路径、名称、大小和属性。如果该值为空，默认会在innodb_data_home_dir变量指定的目录下创建一个自动扩展的数据文件。 </p>
<p><strong>12.重做日志</strong>重做日志是基于磁盘的数据结构，在崩溃恢复期间使用，用来纠正数据。正常操作期间，重做日志会将请求数据进行编码，这些请求会改变InnoDB表数据。遇到意外崩溃后，未完成的更改会自动在初始化期间重新进行。</p>
<h3 id="sql性能下降的原因"><a href="#sql性能下降的原因" class="headerlink" title="sql性能下降的原因"></a>sql性能下降的原因</h3><ul>
<li>查询语句写的差</li>
<li>索引失效：索引建了，但没用上</li>
<li>关联查询太多join（设计缺陷或不得已需求）</li>
<li>服务器调优以及各个参数的设置（缓冲、线程数）</li>
</ul>
<h3 id="七种join理论"><a href="#七种join理论" class="headerlink" title="七种join理论"></a>七种join理论</h3><p><img src="/2022/04/22/MySQL/1646899331303.png" alt="1646899331303" loading="lazy">上图中第6个的实现 可以通过如下：</p>
<p>由于有些mysql不能使用full join，不过可以换种方法表示<br><code>A 的独有 + AB 共有 + B的独有</code><br>union本身就可以去重<br>所以可以这样使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl_emp a <span class="keyword">left</span> <span class="keyword">join</span> tbl_dept b <span class="keyword">on</span> a.deptId <span class="operator">=</span> b.id</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl_emp a <span class="keyword">right</span> <span class="keyword">join</span> tbl_dept b <span class="keyword">on</span> a.deptId <span class="operator">=</span> b.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 上图中第7个的实现可以通过如下：<br>也就是A的独有+ B的独有<br>之后通过union进行合并 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl_emp a <span class="keyword">left</span> <span class="keyword">join</span> tbl_dept b <span class="keyword">on</span> a.deptId <span class="operator">=</span> b.id <span class="keyword">where</span> b.id <span class="keyword">is</span> <span class="keyword">null</span> </span><br><span class="line"><span class="keyword">union</span> </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl_emp a <span class="keyword">right</span> <span class="keyword">join</span> tbl_dept b <span class="keyword">on</span> a.deptId <span class="operator">=</span> b.id <span class="keyword">where</span> a.deptId <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><h4 id="为什么使用索引"><a href="#为什么使用索引" class="headerlink" title="为什么使用索引"></a>为什么使用索引</h4><p>索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教课书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。<img src="/2022/04/22/MySQL/1652583833418.png" alt="1652583833418" loading="lazy"></p>
<p>如上图所示，数据库没有索引的情况下，数据<strong>分布在硬盘不同的位置上面</strong>，读取数据时，摆臂需要前后摆动查找数据，这样操作非常消耗时间。如果<strong>数据顺序摆放</strong>，那么也需要从1到6行按顺序读取，这样就相当于进行了6次Io操作，<strong>依旧非常耗时</strong>。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找Col 2= 89这条记录，就要逐行去查找、去比较。从Col2=34开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有<strong>上千万条数据</strong>，就意味着要做很多很<strong>多次磁盘I/0</strong>才能找到。现在要查找col2=89这条记录。CPU必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间的就是磁盘l/o(涉及到磁盘的旋转时间（(速度较快）、磁头的寻道时间(速度慢、费时))</p>
<p>假如给树使用二叉树这样的数据结构进行存储，如图<img src="/2022/04/22/MySQL/1652584043939.png" alt="1652584043939" loading="lazy"></p>
<p>对字段Col2添加了索引，就相当于在硬盘上为col 2维护了一个索引的数据结构，即这个<strong>二叉搜索树</strong>。二叉搜索树的每个结点存储的是<strong>〈K，V)结构</strong>，key是Col 2， valde是该key 所在行的文件指针(地址)。比如:该二叉搜索树的根节点就是:（34,0x07)。现在对Col 2添加了索引，这时再去查找Col2=89这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找)。读34到内存，89&gt;34;继续右侧数据，读89到内存，89.=- 89;找到数据返回。找到之后就根据当前结点的value快速定位到要查找的记录对应的地址。我们可以发现，只需要<strong>查找两次</strong>就可以定位到记录的地址，查询速度就提高了。</p>
<p>这就是建立索引的目的：<strong>减少磁盘IO的次数，加快查询速率</strong></p>
<h4 id="索引及其优缺点"><a href="#索引及其优缺点" class="headerlink" title="索引及其优缺点"></a>索引及其优缺点</h4><blockquote>
<p>什么是索引</p>
</blockquote>
<p>索引是<strong>排好序的快速查找的数据结构</strong>，是数据库维护的一个满足特定查找算法的数据结构，以某种方式指向数据，这种数据结构就是索引</p>
<p><strong>重点</strong>：索引会影响到<strong>mysql查找</strong>（WHERE的查询条件）、<strong>排序</strong>（ORDER BY）两大功能</p>
<p>索引本身也很大，不可能全部存储在内存中，因此往往存储在以索引文件的形式存储在磁盘上</p>
<p>平时所说的索引，如果没有特别说明，都使指B树（多路搜索树，并不一定是二叉），结构组织的索引，其中聚集索引、次要索引、覆盖索引、复合索引、前缀索引、唯一索引默认使用B+树索引，统称索引，除了<strong>B+树</strong>这种数据结构的索引外，还有<strong>哈希索引</strong></p>
<p><strong>索引是在存储引擎中实现的，</strong>因此每种存储引擎的索引不一定完全相同。型。同时，存储引擎可以定义每个表的最大索引数和最大索引长度。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。</p>
<blockquote>
<p>索引的优势和劣势</p>
</blockquote>
<p>优势：</p>
<ul>
<li>​    <strong>查找</strong>：类似于大学图书馆，提高数据检索效率，<strong>降低数据库io成本</strong></li>
<li>​    <strong>排序</strong>：通过索引对数据排序，降低数据排序的成本，降低cpu消耗</li>
<li>通过创建唯一索引，可以保证数据库表中每一行<strong>数据唯一性</strong></li>
<li>在实现树的参考完整性方面，可以加速表和表之间的连接。换句话说，对于依赖关系的子表和父表联合查询时，可以提高查询速度</li>
<li>在使用分组和排序子句进行数据查询时，可以<strong>显著减少查询时分组和排序的时间</strong>，降低了CPU消耗</li>
</ul>
<p>劣势：</p>
<ul>
<li>索引实际上也是一张表，该表保存了主键与索引字段，并指向实体表的记录，索引索引也是要占用空间的</li>
<li>虽然索引会提高查询速度，但会降低表的更新速度，因为更新表时，不仅要保存数据，还要维护索引表的信息变化</li>
<li>索引知识提高效率的一个因素，如果有大数据量的表，就要花时间研究建立最优秀的索引</li>
<li>创建索引和维护索引要<strong>耗费时间</strong>且随着数据量增大，时间增加</li>
<li>索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</li>
</ul>
<blockquote>
<p>提示：</p>
<p>索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后再插入数据，然后再创建索引 </p>
</blockquote>
<h4 id="InnoDB中索引的推演"><a href="#InnoDB中索引的推演" class="headerlink" title="InnoDB中索引的推演"></a>InnoDB中索引的推演</h4><h5 id="索引之前的查找"><a href="#索引之前的查找" class="headerlink" title="索引之前的查找"></a>索引之前的查找</h5><p>先来看一个精确匹配的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT [列名列表] FROM 表明 WHERE 列名 = xxx;</span><br></pre></td></tr></table></figure>

<h6 id="在一个页中的查找"><a href="#在一个页中的查找" class="headerlink" title="在一个页中的查找"></a>在一个页中的查找</h6><p>假设目前表中的记录比较少，所有的记录可以被存到一个页中，在查找记录时可以根据搜索条件的不同分为两种情况：</p>
<ul>
<li><p>以主键为搜索条件</p>
<p>可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录可快速找到指定的记录</p>
</li>
<li><p>以其他列为搜索条件</p>
<p>因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。<br>这种情况下只能从<strong>最小记录</strong>开始<strong>依次遍历</strong>单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然,这种查找的效率是非常低的。</p>
</li>
</ul>
<h6 id="在很多页中查找"><a href="#在很多页中查找" class="headerlink" title="在很多页中查找"></a>在很多页中查找</h6><p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：</p>
<p>1.定位到记录所在的页</p>
<p>2.从所在的页内中查找相应的记录</p>
<p>在没有索引情况下，不论是根据主键列或其他列的值进行查找，由于并不能快速定位到记录所在的页，所以只能从<strong>第一个页</strong>沿着<strong>双向链表</strong>一直往下找，在每一个页中根据我们上面的查找方式去查找记录。因为要遍历所有的数据页，所以这种方式显示<strong>超级耗时</strong>的，因此诞生了索引。</p>
<h5 id="设计索引"><a href="#设计索引" class="headerlink" title="设计索引"></a>设计索引</h5><p>建一个表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE index_demo(</span><br><span class="line">	-&gt; c1 INT,</span><br><span class="line">    -&gt; c2 INT,</span><br><span class="line">    -&gt; c3 CHAR(1),</span><br><span class="line">    -&gt; PRIMARY KEY(c1)</span><br><span class="line">	-&gt; ) ROW_FORMAT = Compact;</span><br></pre></td></tr></table></figure>

<p>这个新建的index_demo表中有2个INT类型的。1个CHAR(1)类型的列，而且规定了c1列是主键，这个表使用Compact行格式来实际存储记录的。这里简化了index_demo表的行格式示意图：<img src="/2022/04/22/MySQL/1652601775640.png" alt="1652601775640" loading="lazy"></p>
<p>我们只在示意图里展示记录的这几个部分：</p>
<ul>
<li>record_type ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 暂时还没用过，下面讲。 </li>
<li>next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。 </li>
<li>各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。 </li>
<li>其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li>
</ul>
<p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果：<img src="/2022/04/22/MySQL/1652601959138.png" alt="1652601959138" loading="lazy"></p>
<p>把一些记录放到页里的示意图：<img src="/2022/04/22/MySQL/1652602035735.png" alt="1652602035735" loading="lazy"></p>
<h6 id="简单的索引设计方案"><a href="#简单的索引设计方案" class="headerlink" title="简单的索引设计方案"></a>简单的索引设计方案</h6><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们 <strong>想快速的定位到需要查找的记录在哪些数据页</strong> 中该咋办？我们可以为快速定位记录所在的数据页而 <strong>建立一个目录</strong> ，建这个目录必须完成下边这些事：</p>
<ul>
<li><p>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</p>
<p>假设:每个数据页最多能存放3条记录(实际上一个数据页非常大，可以存放下好多记录)。有了这个假设之后我们向index_demo表插入3条记录:<img src="/2022/04/22/MySQL/1652602831329.png" alt="1652602831329" loading="lazy"></p>
<p>那么这些记录已经按照逐渐知道大小串联成一个单项链表，如图：<img src="/2022/04/22/MySQL/1652602890257.png" alt="1652602890257" loading="lazy"></p>
<p>从图中可以看出，index_demo表中的3条件记录都被插入到编号为10的数据项中，此时再插入一条记录：<img src="/2022/04/22/MySQL/1652602954239.png" alt="1652602954239" loading="lazy"></p>
<p>因为页10最多只能放3条记录，所以不得不再分一个新页：<img src="/2022/04/22/MySQL/1652602987860.png" alt="1652602987860" loading="lazy"></p>
<p>注意，新分配的<strong>数据页编号</strong>可能并不是连续的。它们只是通过维护着上一个页和下一个页的编号而建立了<strong>链表</strong>关系。另外，页10中用户记录最大的主键值是5，而页28中有一条记录的主键值是4，因为<strong>5&gt;4</strong>，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次<strong>记录移动</strong>，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下:<img src="/2022/04/22/MySQL/1652603092286.png" alt="1652603092286" loading="lazy"></p>
<p>这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如<strong>记录移动</strong>的操作来始终保证这个状态一直成立:下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们称为<strong>页分裂</strong>。</p>
</li>
<li><p>给所有页建立一个目录项。</p>
<p>由于<strong>数据页的编号可能不是连续</strong>的，所以在向index_demo表中插入许多记录后，是这样的：<img src="/2022/04/22/MySQL/1652623845882.png" alt="1652623845882" loading="lazy"></p>
<p>因为这些16KB的页在物理存储上是<strong>不连续</strong>的，所以如果想从这么多页中根据主键值<strong>快速定位某些记录所在的页</strong>，我们需要给他们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分：</p>
<ul>
<li>页的用户记录中最小的主键值，我们用key来表示。</li>
<li>页号，我们用page_no表示</li>
</ul>
<p>所以我们为上边几个页做好的目录就像这样：<img src="/2022/04/22/MySQL/1652623892480.png" alt="1652623892480" loading="lazy"></p>
<p>以<strong>页28</strong>为例，它对应<strong>目录项2</strong>，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能。比如：查找主键值为20的记录，具体查找过程分两步：</p>
<ol>
<li>先从目录项中根据二分法快速确定出主键值为20的记录在目录项3中，它对应的页是页9</li>
<li>再根据前边说的在页中查找记录的方法去页9中定位记录</li>
</ol>
</li>
</ul>
<p>至此，针对数据页做的简易目录就完成，这个目录也就是<strong>索引</strong>。</p>
<h6 id="InnoDB中的索引方案"><a href="#InnoDB中的索引方案" class="headerlink" title="InnoDB中的索引方案"></a>InnoDB中的索引方案</h6><p><strong>1.迭代一次：目录项记录的页</strong></p>
<p>上边称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用<strong>二分法</strong>快速定位具体的目录项而<strong>假设</strong>所有目录项都可以在物理存储器上<strong>连续存储</strong>，但是这样做有几个问题:</p>
<ul>
<li>InnoDB是使用页来作为管理存储空间的基本单位，最多能保证16KB的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</li>
<li>我们时常会对记录进行增删，假设我们把页28中的记录删除了，那意味着目录项2也就没有存在的必要了，这就需要把目录项2后的目录项都向前移动一下，这样操作的效率很差。</li>
</ul>
<p>所以，我们需要一种可以<strong>灵活管理所有目录项</strong>的方式。我们发现目录项其实长得跟我们的用户记录差不多，只不过目录项中的两个列是<strong>主键和页号</strong>而已，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为<strong>目录项记录</strong>。那InnoDB怎么区分一条记录是普通的田尸记录还是目录项己录呢?使用记录头信息里的<br><strong>rcord_type</strong>属性，它的各个取值代表的意思如下:</p>
<ul>
<li>0：普通用户记录</li>
<li>1：目录项记录</li>
<li>2：最小记录</li>
<li>3：最大记录</li>
</ul>
<p>把前边使用到的目录项放到数据页中的样子就是这样：<img src="/2022/04/22/MySQL/1652624631062.png" alt="1652624631062" loading="lazy"></p>
<p>从图中可以看出来。我们新分配一个编号为30的页来专门存储目录项记录。这里再次强调<strong>目录项记录</strong>和普通的<strong>用户记录</strong>的不同点：</p>
<ul>
<li><strong>目录项记录</strong>的<strong>record_type</strong>值是1，而<strong>普通用户记录</strong>的<strong>record_type</strong>值是0</li>
<li>目录项记录只有<strong>主键和页号</strong>两个列，而普通用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列</li>
<li>了解：记录头信息里还有一个叫min_rec_mask的属性，只有在<strong>存储目录项记录</strong>的页中的主键值最小的目录项记录的min_rec_mask值为1，其它的记录min_rec_mask的值为0</li>
</ul>
<p>相同点：两者用的是一样的数据页，都会为主键值生成<strong>Page Directory</strong>（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。</p>
<p>现在以查找主键为20的记录为例，根据某个主键值去查找记录的步骤就可以大致分为下边两步：</p>
<ol>
<li>先到存储<strong>目录项记录</strong>的页，也就是页30中通过二分法快速定位到对应目录项，因为12&lt;20&lt;209，所以定位到对应的记录所在的页就是页9</li>
<li>再到存储用户记录的页9中根据二分法快速定位到主键值为20的用户记录。</li>
</ol>
<p><strong>2.迭代2次：多个目录项记录的页</strong></p>
<p>虽然说<strong>目录项记录</strong>中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有<strong>16KB</strong>大小，能存放的<strong>目录项记录</strong>也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的<strong>目录项记录</strong>，如何处理呢?</p>
<p>这里我们假设一个存储目录项记录的页<strong>最多只能存放4条目录项记录</strong>，所以如果此时我们再向上图中插入一条主键值为320的用户记录的话，那就需要分配一个<strong>新的存储目录项记录</strong>的页:<img src="/2022/04/22/MySQL/1652625722770.png" alt="1652625722770" loading="lazy"></p>
<p>从图中可以看出，我们插入了一条主键为320的用户记录之后需要两个新的数据页：</p>
<ul>
<li>为存储该用户记录而新生成了页31</li>
<li>因为原先存储目录项记录的页30容量已满（假设只能存储4条记录），所以不得不需要一个新的页32来存放页31对应的目录项</li>
</ul>
<p>现在因为存储目录项记录的页不止一个，所以如果我们想要根据主键值查找一条用户记录大致需要三个步骤：</p>
<ol>
<li><p>确定<strong>目录项记录页</strong></p>
<p>我们现在的存储目录项记录的页有两个，即页30和页32，又因为页30表示的目录项的主键值的范围是[1,320)，页32表示的目录项的主键值不小于320，所以主键值为20的记录对应的目录项记录在页30中。</p>
</li>
<li><p>通过目录项记录页确定用户记录真实所在的页</p>
<p>在一个存储目录项记录的页中通过主键值定位一条目录项记录的方式</p>
</li>
<li><p>在真实存储用户记录的页中定位到具体记录</p>
</li>
</ol>
<p><strong>3.迭代3次：目录项记录页的目录页</strong></p>
<p>问题来了，在这个查询步骤的第1步中我们需要定位存储目录项记录的页，但是<strong>这些页是不连续的</strong>，如果我们表中的数据非常多则会<strong>产生很多存储目录项记录的页</strong>，那我们怎么根据主键值快速定位一个存储目录项记录的页呢?那就为这些存储目录项记录的页再生成一个<strong>更高级的目录</strong>，就像是一个多级目录一样，<strong>大目录里嵌套小目录</strong>，小目录里才是实际的数据，所以现在各个页的示意图就是这样子:<img src="/2022/04/22/MySQL/1652626601115.png" alt="1652626601115" loading="lazy"></p>
<p>如图，我们生成了一个存储更高级目录项的<strong>页33</strong>，这个页中的两条记录分别代表页3o和页32，如果用户记录的主键值在**[1，320)<strong>之间，则到页30中查找更详细的目录项记录，如果主键值</strong>不小于320**的话，就到页32中查找更详细的目录项记录。</p>
<p>随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述它:<img src="/2022/04/22/MySQL/1652626823498.png" alt="1652626823498" loading="lazy"></p>
<p>这个数据结构，它的名称是B+树</p>
<p><strong>B+Tree</strong></p>
<p>不论是存放<strong>用户记录</strong>的数据页，还是存放<strong>目录项记录</strong>的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为<strong>节点</strong>。从图中可以看出，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为<strong>叶子节点</strong>，其余用来存放目录项的节点称为<strong>非叶子节点或者内节点</strong>，其中B+树最上边的那个节点也称为根节点。</p>
<p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们<strong>用户记录的那层为第0层</strong>，之后依次往上加。之前我们做了一个非常极端的假设:存放用户记录的页<strong>最多存放3条记录</strong>，存放目录项记录的页<strong>最多存放4条记录</strong>。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以<strong>存放100条用户记录</strong>，所有存放目录项记录的内节点代表的数据页可以<strong>存放1000条目录项记录</strong>，那么:</p>
<ul>
<li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。</li>
<li>如果B+树有2层，最多能存放1000×100=10,0000 条记录。 </li>
<li>如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 条记录。 </li>
<li>如果B+树有4层，最多能存放1000×1000×1000×100=1000,0000,0000 条记录。相当多的记 录！！！ </li>
</ul>
<p>你的表里能存放 <strong>100000000000</strong> 条记录吗？所以一般情况下，我们 用到的B+树<strong>都不会超过4层</strong> ，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的 <strong>Page Directory</strong> （页目录），所以在页面内也可以通过 <strong>二分法</strong> 实现快速定位记录。 </p>
<h5 id="常见的索引概念"><a href="#常见的索引概念" class="headerlink" title="常见的索引概念"></a>常见的索引概念</h5><p>索引按照物理实现方式，索引可以分为2种：聚簇索引（聚集）和非聚簇（非聚集）索引。我们把非聚集索引称为二级索引或者辅助索引。</p>
<h6 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h6><p><strong>聚簇索引</strong>并不是一种单独的索引类型，而是一种数据存储方式（所有的用户记录存储在叶子节点），也就是所谓的<strong>索引即数据，数据即索引</strong></p>
<blockquote>
<p>术语“聚簇”表示数据行和相邻的键值聚簇的存储在一起</p>
</blockquote>
<p><strong>特点：</strong></p>
<ol>
<li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： </p>
<ul>
<li>页内 的记录是按照主键的大小顺序排成一个 单向链表 。 </li>
<li>各个存放 用户记录的页 也是根据页中用户记录的主键大小顺序排成一个 双向链表 。 </li>
<li>存放 目录项记录的页 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 双向链表 。 </li>
</ul>
</li>
<li><p>B+树的 <strong>叶子节点</strong> 存储的是完整的用户记录。</p>
<p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p>
</li>
</ol>
<p>我们把具有这两种特性的B+树称为<strong>聚簇索引</strong>，所有完整的用户记录都存放在这个<strong>聚簇索引</strong>的叶子节点。这种聚簇索引并不需要我们在MySQL语句种显式的使用<strong>INDEX</strong>语句去创建，InnoDB存储引擎会<strong>自动</strong>为我们创建聚簇索引。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>数据访问更快</strong> ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快 </li>
<li>聚簇索引对于主键的 <strong>排序查找</strong> 和 <strong>范围查找</strong> 速度非常快 </li>
<li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以 <strong>节省了大量的io操作</strong> 。 </li>
</ul>
<p><strong>缺点：</strong></p>
<p>插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增的ID列为主键</strong> </p>
<p><strong>更新主键的代价很高</strong> ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong> </p>
<p><strong>限制：</strong></p>
<ul>
<li>对于MySQL数据库目前只有InnoDB数据引擎支持聚簇索引，而MyIASM并不支持聚簇索引。</li>
<li>由于数据物理存储排序方式只能有一种，所以MySQL的表<strong>只有一个聚簇索引</strong>。一般是该表的主键</li>
<li>如果没有定义主键，InnoDB会选择<strong>非空的唯一索引</strong>代替。如果没有这样的索引，InnoDB会隐式的定义一个主键来作为聚簇索引</li>
<li>为了充分利用聚簇索引的特性，所以InnoDB表的主键列尽量<strong>选用有序的顺序id</strong>，而不建议用无序的id，比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长</li>
</ul>
<h6 id="二级索引（辅助索引、非聚簇索引）"><a href="#二级索引（辅助索引、非聚簇索引）" class="headerlink" title="二级索引（辅助索引、非聚簇索引）"></a>二级索引（辅助索引、非聚簇索引）</h6><p>上边介绍的<strong>聚簇索引</strong>只能在搜索条件是<strong>主键</strong>时才发挥作用，因为B+树中的数据都是按照主键进行排序的。那么如果想以别的列作为搜索条件该怎么办？肯定不能从头到尾沿着链表依次遍历一遍</p>
<p>答案：我们可以<strong>多建几颗B+树</strong>，不同的B+树中的数据采用不同的排序规则。比方说我们用c2列的大小作为数据页、页中记录的排序规则，再建一颗B+树，效果图如下：<img src="/2022/04/22/MySQL/1652630395998.png" alt="1652630395998" loading="lazy"></p>
<p>这个B+树与上边介绍的聚簇索引有几处不同：</p>
<ul>
<li><p>使用记录c2列的大小进行记录和页的排序，包括三个方面的含义：</p>
<ul>
<li>业内的记录是按照c2列的大小顺序排序成一个<strong>单向链表</strong></li>
<li>各个存放用户记录的页也是根据页中记录的c2列大小顺序排成一个<strong>双向链表</strong></li>
<li>存放<strong>目录项记录的页</strong>分为不同的层次，再同一层次中的页也是根据页中目录项记录的c2列大小排序排成一个<strong>双向链表</strong></li>
</ul>
</li>
<li><p>B+树的叶子节点存储的并不是完整的用户记录，而只是<strong>c2列+主键</strong>这两个列的值</p>
</li>
<li><p>目录项记录中不再是<strong>主键+页号</strong>的搭配，而变成了<strong>c2列+页号</strong>的搭配</p>
</li>
</ul>
<p>所以如果我们现在想通过c2列的值查找某些记录的话就可以使用刚刚键好的B+树。以查找c2列的值为4的记录为例，查找过程如下：</p>
<ol>
<li><p>确定<strong>目录项记录页</strong></p>
<p>根据<strong>根页面</strong>，也就是页44，可以快速定位到目录项所在的页为页42（2&lt;4&lt;9）。</p>
</li>
<li><p>通过<strong>目录项记录页</strong>确定用户记录真实所在的页</p>
<p>在页42中可以快速定位到实际存储用户记录的页，但是由于c2列并没有唯一性约束，所以c2列值为4的记录可能分布在多个数据页中，又因为<strong>2&lt; 4≤4</strong>，所以确定实际存储用户记录的页在页34和页35中。</p>
</li>
<li><p>在真实存储用户记录的页中定位到具体的记录。</p>
<p>到页34和页35中定位到具体的记录。</p>
</li>
<li><p>但是这个B+树的叶子节点中的记录只存储了c2和c1（也就是主键）两个列，所以必须再次根据主键值去聚簇索引在查找一遍完整的用户记录</p>
</li>
</ol>
<p><strong>概念：回表</strong></p>
<p>我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到<strong>聚簇索引</strong>中再查一遍，这个过程称为<strong>回表</strong>。也就是根据c2列的值查询一条完整的用户记录需要使用到<strong>2</strong>棵B+树!</p>
<p><strong>问题：</strong>为什么我们还需要一次回表操作？直接把完整记录放进叶子节点不行吗？</p>
<p><strong>回答：</strong></p>
<p>如果把完整的用户记录放到叶子节点是可以不用回表。但是太占地方了，相当于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍，这就有点<strong>太浪费存储空间</strong>了。</p>
<p>因为这种按照<strong>非主键列</strong>建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为<strong>二级索引</strong>(英文名secondary index )，或者<strong>辅助索引</strong>。由于我们使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树是为c2列建立的索引。</p>
<p>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。<img src="/2022/04/22/MySQL/1652634143064.png" alt="1652634143064" loading="lazy"></p>
<p>小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：</p>
<ul>
<li>聚簇索引的<strong>叶子节点存储的就是我们的数据记录</strong>，非聚簇索引的<strong>叶子节点存储的是数据位置</strong>。非聚簇索引不会影响数据表的物理存储顺序。</li>
<li>一个表只能有一个聚簇索引，因为只能有一种排序存储的方式，但可以有多个非聚簇索引，也就是多个索引目录提供数据检索</li>
<li>使用聚簇索引的时候，数据的<strong>查询效率高</strong>，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低</li>
</ul>
<h5 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h5><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照<strong>c2和c3</strong>列的大小进行排序，这个包含两层含义:</p>
<ul>
<li>先把各个记录和页按照c2列进行排序</li>
<li>在记录的c2列相同情况下，采用c3列进行排序</li>
</ul>
<p>为c2和c3列建立的索引的示意图如下：<img src="/2022/04/22/MySQL/1652634751504.png" alt="1652634751504" loading="lazy"></p>
<p>如图所示，我们需要注意几点：</p>
<ul>
<li>每条目录项记录都由c2、c3、页号这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序</li>
<li>B+树叶子节点处的用户记录由c2、c3和主键c1列组成</li>
</ul>
<p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为<strong>联合索引</strong>，本质上也是一个二级索引。他的意思是与分别为c2和c3列分别建立索引的表述不同，不同点如下：</p>
<ul>
<li>建立联合索引只会建立如上图一样的B+树</li>
<li>为c2和c3列分别建立索引会分别以c2和c3列大小为排序规则建立2棵B+树</li>
</ul>
<h6 id="InnoDB的B-树索引的注意事项"><a href="#InnoDB的B-树索引的注意事项" class="headerlink" title="InnoDB的B+树索引的注意事项"></a>InnoDB的B+树索引的注意事项</h6><p><strong>根页面万年不动窝</strong></p>
<p>我们前边介绍B+树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B+树的形成过程是这样的:</p>
<ul>
<li>每当为某个表创建一个B+树索引(聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<strong>根节点页面</strong>。最开始表中没有数据的时候，每个B+树索引对应的<strong>根节点</strong>中既没有用户记录，也没有目录项记录。</li>
<li>随后向表中插入用户记录，先把用户记录存储到这个<strong>根节点</strong>中</li>
<li>当根节点中的<strong>可用空间用完</strong>时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页<br>比如页a中，然后对这个新页进行<strong>页分裂</strong>的操作，得到另一个新页，比如页b。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到页a或者b中，而<strong>根节点</strong>便升级为存储目录项记录的页。</li>
</ul>
<p>这个过程特别注意的是:一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是<strong>InnoDB</strong>存储引擎需要用到这个索引l的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。</p>
<p><strong>内节点中目录项记录的唯一性</strong></p>
<p>我们知道B+树索引的内节点中目录项记录的内容是<strong>索引列+页号</strong>的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿index_demo表为例<img src="/2022/04/22/MySQL/1652666059987.png" alt="1652666059987" loading="lazy"></p>
<p>如果二级索引中目录项记录的内容只是<strong>索引列+页号</strong>的搭配的话，那么为c2列建立索引后的B+树应该是：<img src="/2022/04/22/MySQL/1652666132342.png" alt="1652666132342" loading="lazy"></p>
<p>如果我们想新插入一行记录，其中<strong>c1、c2、c3</strong>的值分别是:9、1、 ‘c’，那么在修改这个为c2列建立的二级索引对应的B+树时便碰到了个大问题:由于页3中存储的目录项记录是由c2列＋页号的值构成的，页3中的两条目录项记录对应的c2列的值都是1，而我们新插入的这条记录的c2列的值也是1，那我们这条新插入的记录到底应该放到页4中，还是应该放到页5中啊?答案是:对不起，懵了。</p>
<p>为了让新插入记录能找到自己在哪个页里，我们需要<strong>保证在B+树的同一层内节点的目录项记录除了页号这个字段以外是唯一的</strong>。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p>
<ul>
<li>索引列的值</li>
<li>主键值</li>
<li>页号</li>
</ul>
<p>也就是我们把主键值也添加到二级索引内节点中的目录项记录，这样就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以为c2列建立索引后是：<img src="/2022/04/22/MySQL/1652666508855.png" alt="1652666508855" loading="lazy"></p>
<p>这样我们再插入记录**(9，1， ‘c’)<strong>时，由于页3中存储的目录项记录是由</strong>c2列＋主键＋页号<strong>的值构成的，可以先把新记录的c2列的值和页3中各目录项记录的c2列的值作比较，如果c2列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的</strong>c2列＋主键**的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到页5中。</p>
<p><strong>一个页面最少存储2条记录</strong></p>
<p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错! 这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢?那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录?所以<strong>InnoDB的一个数据页至少可以存放两条记录。</strong></p>
<h4 id="MyISAM中的索引方案"><a href="#MyISAM中的索引方案" class="headerlink" title="MyISAM中的索引方案"></a>MyISAM中的索引方案</h4><p><strong>B树索引适用存储引擎如表所示：</strong><img src="/2022/04/22/MySQL/1652666747479.png" alt="1652666747479" loading="lazy"></p>
<p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MylSAM默认的索引是Btree索引;而Memory默认的索引是Hash索引。</p>
<p>MylSAM引擎使用<strong>B+Tree</strong>作为索引结构，叶子节点的data域存放的是<strong>数据记录的地址。</strong></p>
<h6 id="MyISAM索引的原理"><a href="#MyISAM索引的原理" class="headerlink" title="MyISAM索引的原理"></a>MyISAM索引的原理</h6><p>下图是MyISAM索引的原理图</p>
<p>我们知道<strong>InnoDB中索引即数据</strong>，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了，而<strong>MyISAM</strong>的索引方案虽然也使用树形结构，但是却<strong>将索引和数据分开存储:</strong></p>
<ul>
<li>将表中的记录<strong>按照记录的插入顺序</strong>单独存储在一个文件中，称之为<strong>数据文件</strong>。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并<strong>没有刻意按照主键大小排序</strong>，所以我们并不能在这些数据上使用二分法进行查找。</li>
<li>使用<strong>MyISAM</strong>存储引擎的表会把索引信息另外存储到一个称为<strong>索引文件</strong>的另一个文件中。<strong>MyISAM</strong>会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是<strong>主键值＋数据记录地址</strong>的组合。</li>
</ul>
<p><img src="/2022/04/22/MySQL/1652667131942.png" alt="1652667131942" loading="lazy"></p>
<p>这里设表一共有三列，假设我们以col1为主键，上图是一个MyISAM表的主索引(Primary key)示意可以看出<strong>MylISAM的索引文件仅仅保存数据记录的地址</strong>。在MylSAM中，主键索引和二级索引(Secondary key)在结构上没有任何区别，只是主键索引要求key是唯一的，而二级索引的key可以重复。如果我们在col2上建立一个二级索引，则此索引的结构如下图所示:<img src="/2022/04/22/MySQL/1652667421274.png" alt="1652667421274" loading="lazy"></p>
<p>同样也是一棵B+Tree,data域保存数据记录的地址。因此，MyISAM中索引检索的算法为:首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<h6 id="MyISAM与InnoDb对比"><a href="#MyISAM与InnoDb对比" class="headerlink" title="MyISAM与InnoDb对比"></a>MyISAM与InnoDb对比</h6><p><strong>MyISAM的索引方式都是”非聚簇“的，与InnoDB包含一个聚簇索引不同，小结两种引擎中索引的区别：</strong></p>
<p>1.在InnoDB存储引擎中，我们只需要根据主键值对<strong>聚簇索引</strong>进行一次查找就能找到对应的记录，而在MyISAM:却需要根据叶子节点的数据地址去获取数据记录。</p>
<p> 2.InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是<strong>分离的</strong>，索引文件仅保存数据记录的地址。</p>
<p>3.InnoDB的非聚簇索引data域存储相应记录<strong>主键的值</strong>，而MyISAM索引记录的是<strong>地址</strong>。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</p>
<p>4.MyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p>
<p><strong>小结：</strong></p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助。比如:</p>
<p>举例1:知道了InnoDB的索引实现后，就很容易明白<strong>为什么不建议使用过长的字段作为主键</strong>，因为所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大。</p>
<p>举例2:用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一棵B+Tree，非单调的主键会造成在插入新记录时，数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。<img src="/2022/04/22/MySQL/1652668413960.png" alt="1652668413960" loading="lazy"></p>
<h4 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h4><p>索引是个好东西，但不能乱建，它在空间和时间上都会有消耗：</p>
<ul>
<li><p><strong>空间上的代价</strong></p>
<p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用16KB的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p>
</li>
<li><p>时间上的代价</p>
<p>每次对表中的数据进行<strong>增、删、改操作</strong>时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值<strong>从小到大的顺序</strong>排序而组成了<strong>双向链表</strong>。不论是叶子节点中的记录，还是内节点中的记录(也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些<strong>记录移位</strong><br><strong>页面分裂、页面回收</strong>等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p>
</li>
</ul>
<blockquote>
<p>一个表上索引键的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们得学会这些索引在哪些条件下起作用</p>
</blockquote>
<h4 id="MySQL数据结构选择的合理性"><a href="#MySQL数据结构选择的合理性" class="headerlink" title="MySQL数据结构选择的合理性"></a>MySQL数据结构选择的合理性</h4><p>从MySQL的角度讲，不得不考虑一个现实问题就是磁盘lo。如果我们能让索引的数据结构尽量减少硬盘的IO操作，所消耗的时间也就越小。可以说，<strong>磁盘的I/O操作次数</strong>对索引的使用效率至关重要。</p>
<p>查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更多，为了减少索引在内存的占用，<strong>数据库索引是存储在外部磁盘</strong>上的。当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载，那么<strong>MysQL衡量查询效率的标准就是磁盘lo次数。</strong></p>
<h5 id="全表遍历"><a href="#全表遍历" class="headerlink" title="全表遍历"></a>全表遍历</h5><p>显而易见，效率非常差</p>
<h5 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h5><p>Hash本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。</p>
<p>Hash算法是通过某种确定性的算法(比如MD5、SHA1、SHA2、SHA3）将输入转变为输出。<strong>相同的输入永远可以得到相同的输出，</strong>假设输入内容有微小偏差，在输出中通常会有不同的结果。</p>
<p>举例:如果你想要验证两个文件是否相同，那么你不需要把两份文件直接拿来比对，只需要让对方把Hash 函数计算得到的结果告诉你即可，然后在本地同样对文件进行Hash函数的运算，最后通过比较这两个Hash 函数的结果是否相同，就可以知道这两个文件是否相同。</p>
<p><strong>加速查找速度的数据结构，常见的有两类</strong>:</p>
<ul>
<li>树，例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是O(log2N)</li>
<li>哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是O(1)<img src="/2022/04/22/MySQL/1652670533312.png" alt="1652670533312" loading="lazy"></li>
</ul>
<p>采用Hash进行检索效率非常高，基本上一次检索就可以找到数据，而B+树需要自顶向下依次查找多次访问节点才能找到数据，中间需要多次Io操作，<strong>从效率来说 Hash比 B+树更快。</strong></p>
<p>在哈希的方式下，一个元素k处于h(k)中，即利用哈希函数h，根据关键字k计算出槽的位置。函数h将关键字域映射到哈希表T[o…m-1]的槽位上。<img src="/2022/04/22/MySQL/1652670685945.png" alt="1652670685945" loading="lazy"></p>
<p>上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做<strong>碰撞</strong>，在数据库中一般采用<strong>链接法</strong>来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示:<img src="/2022/04/22/MySQL/1652670738442.png" alt="1652670738442" loading="lazy"></p>
<p>实验：体会数组和hash表查找方面的效率区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法复杂度为 O(n) </span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123; </span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100000</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">        arr[i] = i + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;=<span class="number">100000</span>;j++)&#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> j;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123; </span><br><span class="line">            <span class="keyword">if</span>(temp == arr[i])&#123; </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis(); 			System.out.println(<span class="string">&quot;time： &quot;</span> + (end - start)); 	  <span class="comment">//time： 823 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法复杂度为 O(1) </span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="number">100000</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100000</span>;i++)&#123; </span><br><span class="line">        set.add(i + <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;=<span class="number">100000</span>;j++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> j; </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> set.contains(temp); 		&#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis(); 			System.out.println(<span class="string">&quot;time： &quot;</span> + (end - start)); 	  <span class="comment">//time： 5 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Hash结构效率高，为什么索引结构要设计成树型？</strong></p>
<p>原因1: Hash索引仅能满足(=)(◇)和IN查询。如果进行<strong>范围查询</strong>，哈希型的索引，时间复杂度会退化为o(n);而树型的“有序””特性，依然能够保持o(log2N)的高效率。</p>
<p>原因2: Hash索引还有一个缺陷，数据的存储<strong>是没有顺序的</strong>，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序。</p>
<p>原因3∶对于联合索引的情况，Hash值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。</p>
<p>原因4:对于等值查询来说，通常Hash索引的效率更高，不过也存在一种情况，就是<strong>索引列的重复值如果很多</strong>，<strong>效率就会降低</strong>。这是因为遇到Hash 冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以， Hash索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。</p>
<p><strong>Hash适用存储引擎如表所示：</strong><img src="/2022/04/22/MySQL/1652671186210.png" alt="1652671186210" loading="lazy"></p>
<p><strong>Hash索引的适用性：</strong></p>
<p>Hash索引存在着很多限制，相比之下在数据库中B+树索引的使用面会更广，不过也有一些场景采用Hash索引效率更高，比如在键值型（(Key-value）数据库中,<strong>Redis存储的核心就是Hash表。</strong></p>
<p>MysQL中的Memory存储引擎支持Hash存储，如果我们需要用到查询的临时表时，就可以选择Memory存储引擎，把某个字段设置为Hash索引，比如字符串类型的字段，进行Hash计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行<strong>等值查询</strong>的时候，采用Hash索引是个不错的选择。</p>
<p>另外，InnoDB本身不支持 Hash索引，但是<strong>提供自适应Hash索引</strong>(Adaptive Hash Index)。什么情况下才会使用自适应Hash索引呢?如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到Hash表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让B+树也具备了Hash 索引的优点。<img src="/2022/04/22/MySQL/1652671531627.png" alt="1652671531627" loading="lazy"></p>
<p>采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率。 </p>
<p>我们可以通过 <strong>innodb_adaptive_hash_index</strong> 变量来查看是否开启了自适应 Hash，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%adaptive_hash_index&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652671628560.png" alt="1652671628560" loading="lazy"></p>
<h5 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h5><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。 </p>
<p><strong>二叉搜索树的特点</strong></p>
<ul>
<li>一个节点只能有两个子节点，也就是一个节点的度不超过2</li>
<li>左子节点&lt;本节点；右子节点&gt;=本节点，比我大的向右，比我小的向左</li>
</ul>
<p><strong>查找规则</strong></p>
<p>我们先来看下最基础的二叉搜索树(Binary Search Tree)，搜索某个节点和插入节点的规则一样，我们假设搜索插入的数值为key:</p>
<ol>
<li>如果key大于根节点，则在右子树中进行查找;</li>
<li>如果key小于根节点，则在左子树中进行查找;</li>
<li>如果key等于根节点，也就是找到了这个节点，返回根节点即可。</li>
</ol>
<p>举个例子，我们对数列(34，22，89，5，23，77，91）创造出来的二分查找树如下图所示:<img src="/2022/04/22/MySQL/1652671861644.png" alt="1652671861644" loading="lazy"></p>
<p>但是存在特殊情况，就是有时候二叉树的深度非常大，比如我们给出的数据顺序是（5，22，23，34，77，89，91）创造出来的二分查找树如图所示：<img src="/2022/04/22/MySQL/1652684705791.png" alt="1652684705791" loading="lazy"></p>
<p>上面第二棵树也属于二分查找树，但是性能上已经退化成了一条链表，查找数据的时间复杂度变成**o(n)**。你能看出来第一个树的深度是3，也就是说最多只需3次比较，就可以找到节点，而第二个树的深度是7，最多需要7次比较才能找到节点。</p>
<p>为了提高查询效率，就需要<strong>减少磁盘IO数</strong>。为了减少磁盘lo的次数，就需要<strong>尽量降低树的高度</strong>，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。</p>
<h5 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h5><p>为了解决上面二叉树找树退化成链表的问题，人们提出了平衡二叉树（balanced Binary Tree），又称为AVL树（有别于AVL算法），它在二叉搜索树的基础上增加了约束，具有以下性质：</p>
<p><strong>它是一颗空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树</strong></p>
<p>这里说一下，常见的平衡二叉树有很多种，包括了<strong>平衡二叉搜索树、红黑树、数堆、伸展树</strong>。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。事实上，第一棵树就属于平衡二叉搜索树，搜索时间复杂度就是**0( log2n)**。</p>
<p>数据查询的时间主要依赖于磁盘I/o的次数，如果我们采用二叉树的形式，即使通过平衡二叉搜索树进行了改进，树的深度也是 o(log2n)，当n比较大时，深度也是比较高的，比如下图的情况:</p>
<p><img src="/2022/04/22/MySQL/1652685135597.png" alt="1652685135597" loading="lazy"></p>
<p><strong>每访问一次节点就需要进行一次磁盘工/0操作</strong>，对于上面的树来说，我们需要进行5次I/O操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘I/o操作次数多，会影响整体数据查询的效率。</p>
<p>针对同样的数据，如果我们把二叉树改成M叉树―(M&gt;2）呢?当M=3时，同样的31个节点可以由下面的三叉树来进行存储:<img src="/2022/04/22/MySQL/1652685189189.png" alt="1652685189189" loading="lazy"></p>
<p>你能看到此时树的高度降低了，当数据量N大的时候，以及树的分叉数M大的时候，M叉树的高度会远小于二叉树的高度(M &gt;2)。所以，我们需要把<strong>树从“瘦高”变“矮胖”</strong>。</p>
<h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h5><p>B树的英文是Balance Tree，也就是<strong>多路平衡查找树</strong>。简写为B-Tree (注意横杠表示这两个单词连起来的意思，不是减号)。它的高度远小于平衡二叉树的高度。</p>
<p>B树的结构如下图所示:<img src="/2022/04/22/MySQL/1652685275523.png" alt="1652685275523" loading="lazy"></p>
<p>B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点，<strong>M称为B树的阶</strong>。每个磁盘块中包括了<strong>关键字和子节点的指针</strong>。如果一个磁盘块中包括了×个关键字，那么指针数就是x+1。对于一个100阶的B树来说，如果有3层的话最多可以存储约100万的索引数据。对于大量的索引数据来说，采用B树的结构是非常适合的，因为树的高度要远小于二叉树的高度。</p>
<p>一个M阶的B树（M&gt;2）有以下特性：</p>
<ol>
<li><p>根节点的儿子数的范围是 [2,M]。 </p>
</li>
<li><p>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为[ceil(M/2), M]。 </p>
</li>
<li><p>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。 </p>
</li>
<li><p>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]&lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …,P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k指向关键字大于 Key[k-1] 的子树。 </p>
</li>
<li><p>所有叶子节点位于同一层。 </p>
</li>
</ol>
<p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它 有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15) 大于 12，刚好符合刚才我们给出的特征。</p>
<p>然后我们来看下如何用B树进行查找。假设我们想要查找的关键字是9，那么步骤可以分为以下几步:</p>
<p>1.我们与根节点的关键字(17，35）进行比较，9小于17那么得到指针P1;</p>
<p>2.按照指针P1找到磁盘块2，关键字为(8,12)，因为9在8和12之间，所以我们得到指针P2;</p>
<p>3．按照指针P2找到磁盘块6，关键字为(9，10)，然后我们找到了关键字9。</p>
<p>你能看出来在B树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行I/O操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。<strong>B树相比于平衡二叉树来说磁盘工/0操作要少</strong>，在数据查询中比平衡二叉树效率要高。所以<strong>只要树的高度足够低，IO次数足够少，就可以提高查询性能。</strong></p>
<p><strong>小结：</strong></p>
<ol>
<li>B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</li>
<li>关键字集合分布在整棵树中,即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找。</li>
</ol>
<p><strong>再举例1：</strong><img src="/2022/04/22/MySQL/1652686027723.png" alt="1652686027723" loading="lazy"></p>
<h5 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h5><p>B+树也是一种多路搜索树，<strong>基于B树做出了改进</strong>，主流的DBMS都支持B+树的索引方式，比如MySQL。相t于B-Tree，<strong>B+Tree适合文件索引系统。</strong></p>
<p><img src="/2022/04/22/MySQL/1652686141568.png" alt="1652686141568" loading="lazy"></p>
<p><strong>B+树和B树的差异在于以下几点:</strong><br>1.有k个孩子的节点就有k个关键字。也就是孩子数量=关键字数，而B树中，孩子数量=关键字数+1。</p>
<p>2．非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大(或最小</p>
<p>3非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而B树中，非叶子节点<strong>既保存索引，也保存数据记录。</strong></p>
<p>4.所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</p>
<p><strong>B+树中间节点并不直接存储数据，这样的好处有什么？</strong></p>
<p>首先<strong>，B+树查询效率更稳定</strong>。因为B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关字。</p>
<p>其次，<strong>B+树的查询效率更高</strong>。这是因为通常B+树比B树更矮胖(阶数更大，深度更低)，查询所需要的磁盘I/o 也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。</p>
<p>不仅是对单个关键字的查询上，<strong>在查询范围上，B+树的效率也比B树高</strong>。这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。</p>
<blockquote>
<p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。 </p>
<p>但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p>
</blockquote>
<p><strong>思考题：为了减少IO，索引树会一次性加载吗</strong></p>
<blockquote>
<p>1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。<br>2、当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是:逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。</p>
</blockquote>
<p><strong>思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p>
<blockquote>
<p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT(占用4个字节）或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页（B+Tree 中的一个节点)中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3。也就是说一个深度为3的B+Tree索引可以维护10^3<em>10^3</em>10^3=10亿条记录。(这里假定一个数据页也存储10^3条行记录数据了)实际情况中每个节点可能不能填充满，因此在数据库中，<strong>B+Tree的高度一般都在2~4层</strong>。MysQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/o操作。    </p>
</blockquote>
<p><strong>思考：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p>
<blockquote>
<p>1、B+树的磁盘读写代价更低<br>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说Io读写次数也就降低了。<br>2、B+树的查询效率更加稳定<br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</blockquote>
<p><strong>Hash索引与B+树索引的区别</strong></p>
<blockquote>
<p>我们之前讲到过B+树索引的结构，Hash索引结构和B+树的不同，因此在索引使用上也会有差别</p>
<p>1、Hash索引<strong>不能进行范围查询</strong>，而B+树可以。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。</p>
<p>2、Hash 索引<strong>不支持联合索引的最左侧原则</strong>(即联合索引的部分索引无法使用)，而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。</p>
<p>3、Hash索引<strong>不支持ORDER BY排序</strong>，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索引数据是有序的，可以起到对该字段ORDER BY排序优化的作用。同理，我们也无法用Hash索引进行模糊查询，而B树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询(比如%结尾)的话就可以起到优化作用    </p>
<p>4.<strong>InnoDB不支持哈希索引</strong></p>
</blockquote>
<p><strong>思考：Hash索引与B+树索引是在键索引的时候手动指定的吗？</strong></p>
<blockquote>
<p>如果使用的是MySQL的话I我们需要了解MysQL的存储引擎都支持哪些索引结构，如下图所示(参考来源https:)/dev.mysql.com/doc/refman/8.0/en/create-index.html)。如果是其他的DBMS，可以参考相关的DBMS文档。<img src="/2022/04/22/MySQL/1652690582106.png" alt="1652690582106" loading="lazy"></p>
<p>你能看到，针对InnoDB和MyIlSAM存储引擎，都会默认采用B+树索引，无法使用Hash索引。InnoDB提供的自适应Hash是不需要手动指定的。如果是Memory/Heap和NDB存储引擎，是可以进行选择Hash索引的。</p>
</blockquote>
<h5 id="R树"><a href="#R树" class="headerlink" title="R树"></a>R树</h5><p>R-Tree在MysQL很少使用，仅支持<code> geometry数据类型</code>，支持该类型的存储引擎只有myisam、bdb、innodb、ndb、archive几种。举个R树在现实领域中能够解决的例子:查找2o英里以内所有的餐厅。如果没有R树你会怎么解决?一般情况下我们会把餐厅的坐标(xy)分为两个字段存放在数据库中，一个字段记录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满足要求。如果一个地区有100家餐厅的话，我们就要进行10o次位置计算操作了，如果应用到谷歌、百度地图这种超大数据库中，这种方法便必定不可行了。R树就很好的<strong>解决了这种高维空间搜索问题</strong>。它把B树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解结点的方法，保证树的平衡性。因此，R树就是一棵用来<strong>存储高维数据的平衡树。</strong>相对于B-Tree，R-Tree的优势在于范围查找。<img src="/2022/04/22/MySQL/1652690678410.png" alt="1652690678410" loading="lazy"></p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>使用索引可以帮助我们从海量的数据中快速定位想要查找的数据，不过索引也存在一些不足，比如占用存储空间、降低数据库写操作的性能等，如果有多个索引还会增加索引选择的时间。当我们使用索引时，需要平衡索引的利(提升查询效率)和弊(维护索引所需的代价)。</p>
<p>在实际工作中，我们还需要基于需求和数据本身的分布情况来确定是否使用索引，尽管<strong>索引不是万能的</strong>，但<strong>数据量大的时候不使用索引是不可想象的</strong>，毕竟索引的本质，是帮助我们提升数据检索的效率。</p>
<p><strong>附录：算法的时间复杂度</strong></p>
<p>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。<img src="/2022/04/22/MySQL/1652690811034.png" alt="1652690811034" loading="lazy"></p>
<h3 id="索引的创建与设计原则"><a href="#索引的创建与设计原则" class="headerlink" title="索引的创建与设计原则"></a>索引的创建与设计原则</h3><h4 id="1-索引的声明与使用"><a href="#1-索引的声明与使用" class="headerlink" title="1.索引的声明与使用"></a>1.索引的声明与使用</h4><h5 id="1-1索引的分类"><a href="#1-1索引的分类" class="headerlink" title="1.1索引的分类"></a>1.1索引的分类</h5><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p>
<ul>
<li>从功能逻辑上说，索引主要有4种，分别是普通索引、唯一索引、主键索引、全文索引。</li>
<li>按照物理实现方式，索引可以分为2种:聚簇索引和非聚簇索引。</li>
<li>按照作用字段个数进行划分，分成单列索引和联合索引。</li>
</ul>
<p><strong>1.普通索引</strong></p>
<p>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在<strong>任何数据类型</strong>中，其值是否唯一和非空要由字段本身的完整约束条件决定。建立索引以后，可以通过索引进行查询。例如，在表<strong>student的字段name</strong>上建立一个普通索引，查询记录时就可以根据该索引进行查询</p>
<p><strong>2.唯一性索引</strong></p>
<p>使用<strong>UNIQUE参数</strong>可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的但允许有空值。在一张数据表里<strong>可以有多个唯一索引。</strong></p>
<p>例如，在表student的字段email中创建唯一性索引，那么字段email的值就必须是唯一的。通过唯一性索引,可以更快速地确定某条记录。</p>
<p><strong>3.主键索引</strong></p>
<p>主键索引就是<strong>一种特殊的唯一性索引</strong>，在唯一索引的基础上增加了不为空的约束，也就是NOT NULL+UNIQUE，一张表里<strong>最多只有一个主键索引。</strong></p>
<p>why? 这是由主键索引的物理实现方式决定的，因为数据存储在文件只能按照一种顺序进行存储。</p>
<p><strong>4.单列索引</strong></p>
<p>在表中的单个字段上创建索引，单列索引只根据该字段进行索引。单列索引可以是普通索引吗，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个可以<strong>有多个</strong>单列索引。</p>
<p><strong>5.多列(组合、联合)索引</strong></p>
<p>多列索引是在表的<strong>多个字段组合</strong>上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段idname和gender上建立一个多列索引<strong>idx_id_name_gender</strong>，只有在查询条件中使用了字段id时该索引才会被使用。使用组合索引时<strong>遵循最左前缀集合</strong>。</p>
<p><strong>6.全文索引</strong></p>
<p>全文索引（也称全文检索)是目前<strong>搜索引擎</strong>使用的一种关键技术。它能够利用【<strong>分词技术】</strong>等多种算法智能分杉出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</p>
<p>使用参数<strong>FULLTEXT</strong>可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引只能创建在<strong>CHAR、VARCHAR 或TEXT</strong>类型及其系列类型的字段上，<strong>查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度</strong>。例如，表<strong>student</strong>的字段<strong>information是TEXT</strong>类型该字段包含了很多文字信息。在字段information上建立全文索引后，可以提高查询字段information的速度。</p>
<p>全文索引典型的有两种类型：自然语言的全文索引和布尔全文索引</p>
<ul>
<li>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中出现次数越少的词语，匹配时的相关度就越高。相反，非常常见的单词将不会被搜索，如果一个词语的在超过50%的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。</li>
</ul>
<p>MysQL数据库从3.23.23版开始支持全文索引，但MySQL5.6.4以前只有Myisam支持，5.6.4版本以后innodb才支持，但是<strong>官方版本不支持中文分词，</strong>需要第三方分词插件。在5.7.6版本，MySQL内置了ngram全文解析器，用来支持亚洲语种的分词。测试或使用全文索引时，要先看一下自己的MySQL版本、存储引擎和数据类型是否支持全文索引。</p>
<p><strong>7.补充：空间索引</strong></p>
<p>使用<strong>参数SPATIAL</strong>可以设置索引<strong>为空间索引</strong>。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL中的空间数据类型包括<strong>GEOMETRY、POINT、LINESTRING和POLYGON等</strong>。目前只有MyISAM存储引擎支持空间检索，而且索引的字段不能为空值。对于初学者来说，这类索引很少会用到。</p>
<p><strong>小结:不同的存储引擎支持的索引类型也不一样</strong></p>
<p>InnoDB：支持B-tree、Full-text等索引，不支持Hash索引</p>
<p>MyISAM：支持B-tree、Full-text等索引，不支持Hash索引</p>
<p>Memory :支持B-tree、Hash 等索引，不支持 Full-text索引</p>
<p>NDB :支持Hash索引，不支持 B-tree、Full-text等索引;</p>
<p>Archive :不支持B-tree、Hash、Full-text等索引;</p>
<h5 id="1-2创建索引"><a href="#1-2创建索引" class="headerlink" title="1.2创建索引"></a>1.2创建索引</h5><p>MySQL支持多种方法在单个或多个列上创建索引：在创建表的定义语句<strong>CREATE TABLE</strong>中指定索引列，使用<strong>ALTER TABLE</strong>语句在存在的表上创建索引，或者使用<strong>CREATE INDEX</strong>语句在已存在的表上添加索引</p>
<h6 id="1-创建表的时候创建索引"><a href="#1-创建表的时候创建索引" class="headerlink" title="1.创建表的时候创建索引"></a><strong>1.创建表的时候创建索引</strong></h6><p>使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义主键约束、外键约束或者唯一性约束,而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。</p>
<p>举例：<img src="/2022/04/22/MySQL/1652713242250.png" alt="1652713242250" loading="lazy"></p>
<p>但是，如果是显式创建表时创建索引的话，基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CRAETE TABLE table_name [col_name data_type]</span><br><span class="line">[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]</span><br></pre></td></tr></table></figure>

<ul>
<li>UNIQUE、FULLTEXT和SPATIAL为可选参数，分别表示唯一索引、全文索引和空间索引</li>
<li>INDEX与KEY为同义词，两者的作用相同，用来指定创建索引;</li>
<li>index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名;</li>
<li>col_name为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择;</li>
<li>length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度;</li>
<li>ASC 或 DESC指定升序或者降序的索引值存储。</li>
</ul>
<p><strong>1.创建普通索引</strong></p>
<p>在book表中的year_publication字段上建立普通索引，SQL语句如下：<img src="/2022/04/22/MySQL/1652713829189.png" alt="1652713829189" loading="lazy"></p>
<p>使用EXPLAIN语句查看是否正在使用：<img src="/2022/04/22/MySQL/1652713862370.png" alt="1652713862370" loading="lazy"></p>
<p>EXPLAIN语句输出结果主要关注两个字段：</p>
<p>（1）possible_keys行给出了MySQL在搜索数据记录时可选用的索引</p>
<p>（2）key行是M有SQL实际选用的索引</p>
<p>可以看到，possible_keys和key的值都为year_publication，查询时使用了索引</p>
<p><strong>2.创建唯一索引</strong></p>
<p>创建唯一索引的目的也是<strong>减少查询索引列操作的执行时间</strong>，尤其是对比较庞大的数据表。它与前面的普通索引类似，不同的是:索引列的值必须唯一，但允许有空值。如果是<strong>组合索引</strong>，则列值的<strong>组合必须唯一。</strong></p>
<p>举例：<img src="/2022/04/22/MySQL/1652714131616.png" alt="1652714131616" loading="lazy"></p>
<p>该语句执行完后，使用show create table查看表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test1 \G</span><br></pre></td></tr></table></figure>

<p>其中各个主要参数的含义为:</p>
<p>(1) Table表示创建索引的表。</p>
<p>(2) Non_unique表示索引非唯一，1代表非唯一索引，o代表唯一索引。</p>
<p>(3)Key_name表示索引的名称。</p>
<p>(4) Seq_in_index表示该字段在索引中的位置，单列索引该值为1，组合索引为每个字段在索引定义中的顺序。</p>
<p>(5)Column_name表示定义索引的列字段。</p>
<p>(6) Sub_part表示索引的长度。</p>
<p>(7）Null表示该字段是否能为空值。(8 ) Index_type表示索引类型。</p>
<p>有结果可以看出，id字段上已经成功建立了一个名为uk_idx_id的唯一索引。</p>
<p><strong>3.主键索引</strong></p>
<p>设定为主键后数据库会自动建立索引，InnoDB为聚簇索引，语法：</p>
<ul>
<li><p>随表一起键索引：<img src="/2022/04/22/MySQL/1652714405177.png" alt="1652714405177" loading="lazy"></p>
</li>
<li><p>删除主键索引：<img src="/2022/04/22/MySQL/1652714434090.png" alt="1652714434090" loading="lazy"></p>
</li>
<li><p>修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引</p>
</li>
</ul>
<p><strong>4.创建单列索引</strong></p>
<p>单列索引是再数据表中的某一字段上创建的索引，一个表中可以创建多个单列索引。前面例子中创建的索引都为单列索引</p>
<p>举例：<img src="/2022/04/22/MySQL/1652714567371.png" alt="1652714567371" loading="lazy"></p>
<p>该语句执行完毕后，使用show create table查看表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test2 \G</span><br></pre></td></tr></table></figure>

<p>有结果可以看出，id字段上已经成功建立一个名为single_idx_name的单列索引，索引长度为20</p>
<p><strong>5.创建组合索引</strong></p>
<p>组合索引是在多个字段上创建一个索引    。</p>
<p>举例：创建表test3，在表中的id、name和age字段上建立组合索引：<img src="/2022/04/22/MySQL/1652714712614.png" alt="1652714712614" loading="lazy"></p>
<p>该语句执行完后，使用SHOW INDEX :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test3 \G</span><br></pre></td></tr></table></figure>

<p>由结果可以看到;id、name和age字段上已经成功建立了一个名为multi_idx的组合索引。</p>
<p>组合索引可起几个索引的作用，但是使用时并不是随便查询哪个字段都可以使用索引，而是遵从“最左前u”。例如，索引可以搜索的字段组合为:（id, name, age) . (id,name)或者id。而(age)或者 (name,age)组合不能便用索引查询。</p>
<p>在test3表中，查询id和name字段，使用EXPLAIN语句查看索引的使用情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test3 WHERE id=1 AND nam=”zhangsan“ \G</span><br></pre></td></tr></table></figure>

<p>可以看到，查询id和name字段时，使用了名称为Multildx的索引，如果查询(name,age)组合或者单独查询name和age字段，会发现结果中possible_keys和key值为NULL，并没有使用在t3表中创建的索引进行查询</p>
<p><strong>6.创建全文索引</strong></p>
<p>FULLTEXT全文索引可以用于全文搜索，并且只为CHAR、VARCHAR 和TEXT列创建索引。索引总是对整个列进行，不支持局部（前缀）索引。</p>
<p>举例1:创建表test4，在表中的info字段上建立全文索引，SQL语句如下:<img src="/2022/04/22/MySQL/1652715009226.png" alt="1652715009226" loading="lazy"></p>
<blockquote>
<p>在MySQL5.7及之后版本中可以指定最后的ENGINE，因为在此版本中InnoDB支持全文索引</p>
</blockquote>
<p>语句执行完后，使用SHOW CREATE TABLE查看表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test4 \G</span><br></pre></td></tr></table></figure>

<p>有结果可以看到，info字段上已经成功建立了一个名为futxt_idx_info的FULLTEXT索引。</p>
<p>举例2：<img src="/2022/04/22/MySQL/1652715210828.png" alt="1652715210828" loading="lazy"></p>
<p>创建了一个个title和body字段添加全文索引的表</p>
<p>举例3：<img src="/2022/04/22/MySQL/1652715257722.png" alt="1652715257722" loading="lazy"></p>
<p>不同于like方式的查询：<img src="/2022/04/22/MySQL/1652715332857.png" alt="1652715332857" loading="lazy"></p>
<p>全文索引用match+against方式查询：<img src="/2022/04/22/MySQL/1652715357719.png" alt="1652715357719" loading="lazy"></p>
<p>明显的提高查询效率</p>
<blockquote>
<p>注意点：</p>
<p>1.使用全文索引前，搞清楚版本支持情况;<br>2.全文索引比like + %快N倍，但是可能存在精度问题;<br>3．如果需要全文索引的是大量数据,建议先添加数据I再创建索引。</p>
</blockquote>
<p><strong>7.创建空间索引</strong></p>
<p>创建空间索引中，要求空间类型的字段必须非空</p>
<p>举例：创建test5，在空间类型为GEOMETRY的字段上创建空间索引：<img src="/2022/04/22/MySQL/1652715501264.png" alt="1652715501264" loading="lazy"></p>
<p>该语句执行完后，使用SHOW CREATE TABLE查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test5 \G </span><br></pre></td></tr></table></figure>

<p>可以看到，test5表的geo字段上创建了名称为spa_idx_geo的空间索引。注意创建时指定空间类型字段值的非空约束，并且表的存储引擎为MyISAM。</p>
<h6 id="2-在已经存在的表上创建索引"><a href="#2-在已经存在的表上创建索引" class="headerlink" title="2.在已经存在的表上创建索引"></a>2.在已经存在的表上创建索引</h6><p>在已经存在的表上创建索引可以使用ALTER TABLE…ADD…或者CREATE INDEX…ON…语句</p>
<p><strong>基本语法</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1、创建索引 [UNIQUE]可以省略</span></span><br><span class="line"><span class="comment">-- 如果只写一个字段就是单值索引，写多个字段就是复合索引</span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] INDEX indexName <span class="keyword">ON</span> tabName(columnName(length));</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabName <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>] INDEX indexName (columnName(length));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2、删除索引</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX [indexName] <span class="keyword">ON</span> tabName;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3、查看索引</span></span><br><span class="line"><span class="comment">-- 加上\G就可以以列的形式查看了 不加\G就是以表的形式查看</span></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> tabName \G;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tabname \G;</span><br></pre></td></tr></table></figure>

<p><strong>使用alter命令为数据表添加索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1、该语句添加一个主键，这意味着索引值必须是唯一的，并且不能为NULL</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabName <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(column_list);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2、该语句创建索引的键值必须是唯一的(除了NULL之外，NULL可能会出现多次)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabName <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX indexName(column_list);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3、该语句创建普通索引，索引值可以出现多次</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabName <span class="keyword">ADD</span> INDEX indexName(column_list);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4、该语句指定了索引为FULLTEXT，用于全文检索</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabName <span class="keyword">ADD</span> FULLTEXT indexName(column_list);</span><br></pre></td></tr></table></figure>

<p><strong>使用create添加索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#添加普通索引</span><br><span class="line">CREATE INDEX indexname ON tabname(column_list)</span><br><span class="line"></span><br><span class="line">#添加唯一索引</span><br><span class="line">CREATE UNIQUE INDEX indexname ON tabname(column_list)</span><br><span class="line"></span><br><span class="line">#创建单列索引</span><br><span class="line">CREATE INDEX indexname ON tabname(column_list(length))</span><br><span class="line"></span><br><span class="line">#创建组合索引</span><br><span class="line">CREATE IDNEX idx_aut_info ON tabname(authors(20),info(50))</span><br><span class="line"></span><br><span class="line">#创建主键索引</span><br><span class="line">CREATE PRIMARY KEY ON tabname(column_list)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：添加AUTO_INCRMENT约束字段的唯一索引不能删除</p>
<p>删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。</p>
</blockquote>
<h4 id="2-MySQL8-0索引新特性"><a href="#2-MySQL8-0索引新特性" class="headerlink" title="2.MySQL8.0索引新特性"></a>2.MySQL8.0索引新特性</h4><h5 id="2-1支持降序索引"><a href="#2-1支持降序索引" class="headerlink" title="2.1支持降序索引"></a>2.1支持降序索引</h5><p>降序索引以降序存储键值。虽然在语法上，从MySQL 4版本开始就已经支持降序索引的语法了，但实际上该DESC定义是被忽略的，直到MysQL 8.x版本才开始真正支持降序索引(仅限于InnoDB存储引擎)。</p>
<p>MySQL在<strong>8.0版本之前创建的仍然是升序索引，使用时进行反向扫描，这大大降低了数据库的效率。</strong>在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。</p>
<p>举例:分别在MySQL 5.7版本和MySQL 8.0版本中创建数据表ts1，结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ts1(a int,b int,index idx_a_b(a,b,desc));#a后不写asc默认是升序</span><br></pre></td></tr></table></figure>

<p>在MySQL5.7版本中查看数据表ts1的结构，结果如下：<img src="/2022/04/22/MySQL/1652720607329.png" alt="1652720607329" loading="lazy"></p>
<p>从结果可以看出，索引仍然是默认的升序(使用时反向扫描)。<br>在MySQL 8.0版本中查看数据表ts1的结构，结果如下:</p>
<p><img src="/2022/04/22/MySQL/1652720629046.png" alt="1652720629046" loading="lazy"></p>
<p>从结果可以看出，索引已经是降序。下面继续测试降序索引在执行计划中的表现。</p>
<p>分别在MySQL 5.7版本和MySQL 8.o版本的数据表ts1中插入800条随机数据，执行语句如下:<img src="/2022/04/22/MySQL/1652720704825.png" alt="1652720704825" loading="lazy"></p>
<p>在MySQL5.7版本中查看数据表ts1的执行计划，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM ts1 ORDER BY a,b DESC LIMIT 5;</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，执行计划中扫描数为799，而且使用了Using filesort。<img src="/2022/04/22/MySQL/1652720880325.png" alt="1652720880325" loading="lazy"></p>
<blockquote>
<p>提示<br>Using filesort是MysQL中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员可以通过优化索引来尽量避免出现Using filesort，从而提高数据库执行速度。</p>
</blockquote>
<p>在MySQL 8.0版本中查看数据表ts1的执行计划。从结果可以看出，执行计划中扫描数为5，而且没有使用Usingfilesort。</p>
<p><img src="/2022/04/22/MySQL/1652720942195.png" alt="1652720942195" loading="lazy"></p>
<blockquote>
<p>注意<br>降序索引只对查询中特定的排序顺序有效，如果使用不当，反而查询效率更低。例如，上述查询排序条件改为order by a desc, b desc，MySQL 5.7的执行计划要明显好于MySQL 8.0。</p>
</blockquote>
<h5 id="2-2隐藏索引"><a href="#2-2隐藏索引" class="headerlink" title="2.2隐藏索引"></a>2.2隐藏索引</h5><p>在MysQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。</p>
<p>从MysQL 8.x开始支持<strong>隐藏索引(<strong>invisible indexes），只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引(即使使用force index(强制使用索引)，优化器也不会使用该索引)，确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。这种通过</strong>先将索引设置为隐藏索引，再删除索引的方式就是软删除。</strong></p>
<p>同时，如果你想验证<strong>某个索引删除之后的查询性能影响</strong>，就可以暂时先隐藏该索引。</p>
<blockquote>
<p>注意：</p>
<p>主键不能被设置为隐藏索引。当表中没有显示主键时，表中第一个唯一非空索引会称为隐式主键，也不能设置为隐藏索引</p>
</blockquote>
<p>索引默认是可见的，在使用CREATETABLE，CREATE INDEX或者ALTERTABLE等语句时可以通过<strong>VISIBLE或者INVISIBLE</strong>关键词设置索引的可见性。</p>
<p><strong>1.创建表时直接创建</strong></p>
<p>在MySQL中创建隐藏索引通过SQL语句INVISIBLE来实现，其语法如下：<img src="/2022/04/22/MySQL/1652755737778.png" alt="1652755737778" loading="lazy"><br>上述语句比普通索引多了一个关键字INVISIBLE，用来标记索引为不可见索引</p>
<p>练习：在创建班级表classes时，在字段cname上创建隐藏索引</p>
<p><img src="/2022/04/22/MySQL/1652756053065.png" alt="1652756053065" loading="lazy"></p>
<p>向表中添加数据，并通过explain查看发现，优化器并没有使用索引，而是全表扫描</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM classes HWERE cname = ‘高一’</span><br></pre></td></tr></table></figure>

<p><strong>2.在已存在的表上创建索引</strong></p>
<p>可以为已经存在的表设置隐藏索引，其语法：<img src="/2022/04/22/MySQL/1652756211837.png" alt="1652756211837" loading="lazy"></p>
<p>举例：<img src="/2022/04/22/MySQL/1652756235603.png" alt="1652756235603" loading="lazy"></p>
<p><strong>3.通过ALTER TABLE语句创建</strong></p>
<p>语法：<img src="/2022/04/22/MySQL/1652756264542.png" alt="1652756264542" loading="lazy"></p>
<p>举例：<img src="/2022/04/22/MySQL/1652756283342.png" alt="1652756283342" loading="lazy"></p>
<p><strong>4.恢复索引可见性状态</strong><img src="/2022/04/22/MySQL/1652756304291.png" alt="1652756304291" loading="lazy"></p>
<p>如果将index_cname索引切换成可见状态，通过explain查看执行计划，发现优化器选择了index_cname索引。</p>
<blockquote>
<p>注意<br>当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。</p>
</blockquote>
<p>通过设置隐藏索引的可见性可以查看索引对调优的帮助。</p>
<p><strong>5.使隐藏索引对查询优化器可见</strong></p>
<p>在MySQL 8.x版本中，为索引提供了一种新的测试方式，可以通过查询优化器的一个开关(use_invisible_indexes)来打开某个设置，使隐藏索引对查询优化器可见。如果use_invisible_indexes 设置为of(默认)，优化器会忽略隐藏索引。如果设置为on，即使隐藏索引不可见，优化器在生成执行计划时仍会考虑使用隐藏索引。</p>
<p>（1）在MySQL命令行执行如下命令查看查询优化器的开关设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@optimizer_switch \G</span><br></pre></td></tr></table></figure>

<p>在输出信息中找到如下属性配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sue_inviaible_indexes=off</span><br></pre></td></tr></table></figure>

<p>此属性配置值为off，说明隐藏索引默认对查询优化器不可见.</p>
<p>（2）使隐藏索引对查询优化器可见，需要在MySQL命令行执行如下命令：<img src="/2022/04/22/MySQL/1652756667403.png" alt="1652756667403" loading="lazy"></p>
<p>再次查看查询优化器的开关设置<img src="/2022/04/22/MySQL/1652756765892.png" alt="1652756765892" loading="lazy"></p>
<p>此时，在输出结果中可以看到：<img src="/2022/04/22/MySQL/1652756802677.png" alt="1652756802677" loading="lazy"></p>
<p>说明，此时隐藏索引对查询优化器可见。</p>
<p>（3）使用EXPLAIN查看以字段invisible_column作为查询条件的索引使用情况<img src="/2022/04/22/MySQL/1652756880490.png" alt="1652756880490" loading="lazy"></p>
<p>(4）如果需要使隐藏索引对查询优化器不可见，则只需要执行如下命令即可。<img src="/2022/04/22/MySQL/1652756899448.png" alt="1652756899448" loading="lazy"></p>
<p><img src="/2022/04/22/MySQL/1652756906743.png" alt="1652756906743" loading="lazy"></p>
<h4 id="3-索引的设计原则"><a href="#3-索引的设计原则" class="headerlink" title="3.索引的设计原则"></a>3.索引的设计原则</h4><p>为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。<strong>索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍</strong>。高效的索引对于邘获得良好的性能非常重要。设计索引时，应该考虑相应准则。</p>
<h5 id="3-1哪些情况适合创建索引"><a href="#3-1哪些情况适合创建索引" class="headerlink" title="3.1哪些情况适合创建索引"></a>3.1哪些情况适合创建索引</h5><h6 id="1-字段的数值有唯一性的限制"><a href="#1-字段的数值有唯一性的限制" class="headerlink" title="1.字段的数值有唯一性的限制"></a>1.<strong>字段的数值有唯一性的限制</strong></h6><p>索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中，如果<strong>某个字段是唯一性的</strong>，就可以直接<strong>创建唯一性索引，或者主键索引</strong>。这样可以更快速地通过该索引来确定某条记录。</p>
<p>例如，学生表中学号是具有唯一性的字段，为该字段建立唯一性索引可以很快确定某个学生的信息，如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p>
<blockquote>
<p>业务上具有唯一特性的字段，即使是组合字段，也必须创建唯一索引。</p>
<p>说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略不计，但提高查找速度明显</p>
</blockquote>
<h6 id="2-频繁作为where查询条件的字段"><a href="#2-频繁作为where查询条件的字段" class="headerlink" title="2.频繁作为where查询条件的字段"></a>2.频繁作为where查询条件的字段</h6><p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p>
<h6 id="3-经常-GROUP-BY-和-ORDER-BY-的列"><a href="#3-经常-GROUP-BY-和-ORDER-BY-的列" class="headerlink" title="3. 经常 GROUP BY 和 ORDER BY 的列"></a><strong>3.</strong> <strong>经常</strong> <strong>GROUP BY</strong> <strong>和</strong> <strong>ORDER BY</strong> <strong>的列</strong></h6><p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者 使用 ORDER BY 对数据进行排序的时候，就需要 <strong>对分组或者排序的字段进行索引</strong> 。如果待排序的列有多 个，那么可以在这些列上建立 <strong>组合索引</strong> 。</p>
<h6 id="4-UPDATE、DELETE的-WHERE-条件列"><a href="#4-UPDATE、DELETE的-WHERE-条件列" class="headerlink" title="4. UPDATE、DELETE的 WHERE 条件列"></a><strong>4. UPDATE、DELETE的 WHERE 条件列</strong></h6><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就 <strong>能大幅提升效率</strong>。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或 删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</strong> </p>
<h6 id="5-DISTINCT字段需要创建索引"><a href="#5-DISTINCT字段需要创建索引" class="headerlink" title="5.DISTINCT字段需要创建索引"></a>5.DISTINCT字段需要创建索引</h6><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p>
<h6 id="6-多表JOIN连接操作时，创建索引注意事项"><a href="#6-多表JOIN连接操作时，创建索引注意事项" class="headerlink" title="6.多表JOIN连接操作时，创建索引注意事项"></a>6.多表JOIN连接操作时，创建索引注意事项</h6><p>首先， <strong>连接表的数量尽量不要超过 3 张</strong> ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。 </p>
<p>其次， <strong>对 WHERE 条件创建索引</strong> ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。 </p>
<p>最后， <strong>对用于连接的字段创建索引</strong> ，并且该字段在多张表中的 <strong>类型必须一致</strong> 。比如 course_id 在student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。 </p>
<blockquote>
<p>为什么类型必须一致：例：‘101’=101；</p>
<p>会进行隐式类型转换，调用函数，索引会失效</p>
</blockquote>
<h6 id="7-使用列的类型小的创建索引"><a href="#7-使用列的类型小的创建索引" class="headerlink" title="7.使用列的类型小的创建索引"></a>7.使用列的类型小的创建索引</h6><p>我们这里所说的<strong>类型大小</strong>指的就是该类型表示的数据范围的大小。</p>
<p>我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有<strong>TINYINT、MEDIUMINT、INT、</strong><br><strong>BLGINT</strong>等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能<strong>使用INT就不要使用BIGINT</strong>，能使用MEDIUMINT就不要使用INT。这是因为:</p>
<ul>
<li>数据类型越小，在查询时进行的比较操作越快</li>
<li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/0带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li>
</ul>
<p>这个类型对于表的<strong>主键来说更加适用</strong>，因为不仅是聚簇索引会使用主键值，其他所有的二级索引的节点都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O。</p>
<h6 id="8-使用字符串前缀创建索引"><a href="#8-使用字符串前缀创建索引" class="headerlink" title="8.使用字符串前缀创建索引"></a>8.使用字符串前缀创建索引</h6><p>假设字符串很长，那存储一个字符串就需要占用很大的存储空间，在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么个问题：</p>
<ul>
<li>B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在索引中占用的存储空间越大。</li>
<li>如果B+树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。</li>
</ul>
<p>我们可以通过截取字段的前面一部分内容建立索引，这个就叫<strong>前缀索引</strong>。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。<strong>既节约空间，又减少了字符串的比较时间</strong>，还大体能解决排序的问题。</p>
<p>例如TEXT和BLOG类型的字段，进行全文检索会很浪费时间，如果只检索字段前面的若干字符，这样可以提高检索速度。</p>
<p>创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table shop(address varchar(120) not null); alter table shop add index(address(12));</span><br></pre></td></tr></table></figure>

<p>问题是：截取多少呢？截取多了达不到节省索引存储空间的目的；截取多了，重复内容太多，字段散列度(选择性)会降低。</p>
<p>先看一下字段在全部数据中的选择度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct address) / count(*) from shop;</span><br></pre></td></tr></table></figure>

<p>公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count(distinct left(列名, 索引长度))/count(*)</span><br></pre></td></tr></table></figure>

<p>例如：<img src="/2022/04/22/MySQL/1652757900281.png" alt="1652757900281" loading="lazy"></p>
<p>通过选择的当前索引的前缀查询出来的不重复的个数 / 总记录数</p>
<p>越大选择性越好</p>
<p><strong>引申另一个问题：索引列前缀对排序的影响</strong></p>
<p>如果使用了索引列前缀，比方说前边只把address列的前12个字符放到了二级索引中，下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM shop</span><br><span class="line">ORDER BY address</span><br><span class="line">LIMIT 12;</span><br></pre></td></tr></table></figure>

<p>因为二级索引中不包含完整的address列信息，所以无法对前12个相同，后面字符不同的列排序，也就是使用索引列前缀的方式<strong>无法支持使用索引排序</strong>，只能使用文件排序</p>
<p><strong>拓展：Alibaba《Java开发手册》</strong></p>
<p>【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。 </p>
<p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 高达 90% 以上 ，可以使用 count(distinct left(列名, 索引度))/count(*)的区分度来确定。 </p>
<h6 id="9-区分度高-散列性高-的列适合作为索引"><a href="#9-区分度高-散列性高-的列适合作为索引" class="headerlink" title="9.区分度高(散列性高)的列适合作为索引"></a>9.区分度高(散列性高)的列适合作为索引</h6><p><strong>列的基数</strong>指的是某一列中不重复数据的个数，比方说某个列包含值2，5，8，2，5，8，2，5，8，虽然有9条记录，但该列的基数却是3。也就是说，<strong>在记录行数一定的情况下，列的基数越大，该列中的值越分散;列的基数越小，该列中的值越集中</strong>。这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好<strong>为列的基数大的列建立索引</strong>，为基数太小列的建立索引效果可能不好。</p>
<p>可以使用公式 <strong>select count(distinct a)/count(*) from t1</strong>计算区分度，越接近1越好，一般超过33%就算是比较高效的索引了。</p>
<p><strong>拓展:联合索引把区分度高(散列性高)的列放在前面。</strong></p>
<h6 id="10-使用最频繁的列放到联合索引的左侧"><a href="#10-使用最频繁的列放到联合索引的左侧" class="headerlink" title="10.使用最频繁的列放到联合索引的左侧"></a>10.使用最频繁的列放到联合索引的左侧</h6><p>这样也可以较少的建立一些索引。同时，由于”最左前缀原则”，可以增加联合索引的使用率。</p>
<h6 id="11-在多个字段都要建立索引的情况下，联合索引优于单值索引"><a href="#11-在多个字段都要建立索引的情况下，联合索引优于单值索引" class="headerlink" title="11.在多个字段都要建立索引的情况下，联合索引优于单值索引"></a>11.在多个字段都要建立索引的情况下，联合索引优于单值索引</h6><h5 id="3-2限制索引的数目"><a href="#3-2限制索引的数目" class="headerlink" title="3.2限制索引的数目"></a>3.2限制索引的数目</h5><p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量<strong>不超过6</strong>个。原因:<br>①每个索引都需要占用<strong>磁盘空间</strong>，索引越多，需要的磁盘空间就越大。</p>
<p>②索引会影响<strong>INSERT、DELETE、UPDATE等语句的性能</strong>，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</p>
<p>③优化器在选择如何优化查询时，会根据统一信息，对<strong>每一个可以用到的索引来进行评估</strong>，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。</p>
<h5 id="3-3哪些情况不适合创建索引"><a href="#3-3哪些情况不适合创建索引" class="headerlink" title="3.3哪些情况不适合创建索引"></a>3.3哪些情况不适合创建索引</h5><h6 id="1-在where中使用不到的字段，不要设置索引"><a href="#1-在where中使用不到的字段，不要设置索引" class="headerlink" title="1.在where中使用不到的字段，不要设置索引"></a>1.在where中使用不到的字段，不要设置索引</h6><p>WHERE条件（包括GROUP BY、ORDER BY）里用不到的字段不需要创建索引，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的。举例：<img src="/2022/04/22/MySQL/1652774108868.png" alt="1652774108868" loading="lazy"></p>
<p>因为我们是按照student_id来进行检索的，所以不需要对其他字段创建索引，即使这些字段出现在SELECT字段中。</p>
<h6 id="2-数据量小的表最好不要使用索引"><a href="#2-数据量小的表最好不要使用索引" class="headerlink" title="2.数据量小的表最好不要使用索引"></a>2.数据量小的表最好不要使用索引</h6><p>如果表记录太少，比如少于1000个，那么是不需要创建索引的。表记录太少，<strong>是否创建索引对查询效率的影响并不大</strong>。甚至说，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。</p>
<h6 id="3-有大量重复数据的列上不要建立索引"><a href="#3-有大量重复数据的列上不要建立索引" class="headerlink" title="3.有大量重复数据的列上不要建立索引"></a>3.有大量重复数据的列上不要建立索引</h6><p>在条件表达式中经常用到的不同值较多的列上建立索引，但字段中如果有大量重复数据，也不用创建索引。比如在学生表的“<strong>性别</strong>“字段上只有“男”与“女”两个不同值，因此无须建立索引。如果建立索引，不但不会提高查询效率，反而会<strong>严重降低数据更新速度。</strong></p>
<p>举例1:要在100万行数据中查找其中的50万行(比如性别为男的数据)，一旦创建了索引，你需要先访问50万次索引，然后再访问50万次数据表，这样加起来的开销比不使用索引可能还要大。</p>
<blockquote>
<p>结论：当数据重复度大，比如高于10%的时候，也不需要对这个字段使用索引</p>
</blockquote>
<h6 id="4-避免对经常更新的表创建过多的索引"><a href="#4-避免对经常更新的表创建过多的索引" class="headerlink" title="4.避免对经常更新的表创建过多的索引"></a>4.避免对经常更新的表创建过多的索引</h6><p>第一层含义︰频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。</p>
<p>第二层含义:避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却会降低更新表的速度。</p>
<h6 id="5-不建议用无序的值作为索引"><a href="#5-不建议用无序的值作为索引" class="headerlink" title="5.不建议用无序的值作为索引"></a>5.不建议用无序的值作为索引</h6><p>例如身份证、UUID(在索引比较时需要转为ASCII。并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</p>
<h6 id="6-删除不再使用或很少使用的索引"><a href="#6-删除不再使用或很少使用的索引" class="headerlink" title="6.删除不再使用或很少使用的索引"></a>6.删除不再使用或很少使用的索引</h6><p>表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</p>
<h6 id="7-不要定义冗余或重复的索引"><a href="#7-不要定义冗余或重复的索引" class="headerlink" title="7.不要定义冗余或重复的索引"></a>7.不要定义冗余或重复的索引</h6><p><strong>1.冗余索引</strong></p>
<p>有时候有意或者无意的就对同一个列创建了多个索引，比如: index(a,b,c)相当于index(a)、index(a,b)、index(a,b,c)。</p>
<p>举例：键表语句：<img src="/2022/04/22/MySQL/1652775351558.png" alt="1652775351558" loading="lazy"></p>
<p>我们知道，通过<strong>idx_name_birthday_phone_number</strong>索引就可以对<strong>name</strong>列进行快速搜索，再创建一个专门针对name列的索引就算是一个<strong>冗余索引</strong>，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。</p>
<p><strong>2.重复索引</strong></p>
<p>另一种情况，我们可能会对某个列重复创建索引，<img src="/2022/04/22/MySQL/1652775498796.png" alt="1652775498796" loading="lazy"></p>
<p>我们看到，col1既是主键、又给他定义为唯一索引，还给定义了普通索引，主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。</p>
<h5 id="3-4小结"><a href="#3-4小结" class="headerlink" title="3.4小结"></a>3.4小结</h5><p>索引是一把<strong>双刃剑</strong>，可提高查询效率，但也会降低插入和更新的速度并占用磁盘空间。</p>
<p>选择索引的最终目的是为了使查询的速度变快，上面给出的原则是最基本的准则，但不能拘泥于上面的准则.</p>
<h3 id="性能分析工具的使用"><a href="#性能分析工具的使用" class="headerlink" title="性能分析工具的使用"></a>性能分析工具的使用</h3><p>在数据库调优中，我们的目标就是<strong>响应时间更快，吞吐量更大</strong>。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。</p>
<hr>
<h4 id="1-数据库服务器的优化步骤"><a href="#1-数据库服务器的优化步骤" class="headerlink" title="1.数据库服务器的优化步骤"></a>1.数据库服务器的优化步骤</h4><p>当我们遇到数据库调优问题的时候，该如何思考呢?这里把思考的流程整理成下面这张图。</p>
<p>整个流程划分成了<strong>观察(Show status）和行动(Action）</strong>两个部分。字母S的部分代表观察（会使用相应的分析工具)，字母A代表的部分是行动(对应分析可以采取的行动)。<img src="/2022/04/22/MySQL/1652776009979.png" alt="1652776009979" loading="lazy"></p>
<p>我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的SQL都有哪些，查看具体的sQL执行计划，甚至是SQL执行中的每一步的成本代价，这样才能定位问题所在，找到了问题，再采取相应的行动。</p>
<p>详细解释以下图：</p>
<p>首先在S1部分，我们需要观察服务器的状态<strong>是否存在周期性的波动</strong>。如果存在周期性波动，有可能是周期性节点的原因，比如双十一、促销活动等。这样的话，我们可以通过A1这一步骤解决，也就是加缓存，或者更改缓存失效策略。</p>
<p>如果缓存策略没有解决，或者不是周期性波动的原因，我们就需要<strong>进一步分析查询延迟和卡顿的原因</strong>。接下来进入S2这一步，我们需要开启慢查询。慢查询可以帮我们定位执行慢的SQL语句。我们可以通过设置<strong>long_query_time</strong>参数定义“慢”的阈值，如果SQL执行时间超过了long_query_time，则会认为是慢查询。当收集上来这些慢查询之后，我们就可以通过分析工具对慢查询日志进行分析。</p>
<p>在S3这一步骤中，我们就知道了执行慢的SQL，这样就可以针对性地用<strong>EXPLAIN</strong>查看对应SQL语句的执行计划，或者使用 <strong>show profile</strong>查看SQL中每一个步骤的时间成本。这样我们就可以了解sQL查询慢是因为执行时间长，还是等待时间长。</p>
<p>如果是SQL等待时间长，我们进入A2步骤。在这一步骤中，我们可以<strong>调优服务器的参数</strong>，比如适当增加数据库缓冲池等。如果是SQL执行时间长，就进入A3步骤，这一步中我们需要考虑是索引设计的问题?还是查询关联的数据表过多?还是因为数据表的字段设计问题导致了这一现象。然后在这些维度上进行对应的调整。</p>
<p>如果A2和A3都不能解决问题，我们需要考虑数据库自身的SQL查询性能<strong>是否已经达到了瓶颈</strong>，如果确认没有达到性能瓶颈，就需要重新检查，重复以上的步骤。如果<strong>已经达到了性能瓶颈</strong>，进入A4阶段，需要<strong>考虑增加服务器</strong>，<strong>采用读写分离的架构</strong>，或者考虑<strong>对数据库进行分库分表，比如垂直分库、垂直分表和水平分表等</strong>。</p>
<p>以上就是数据库调优的流程思路。如果我们发现执行SQL时存在不规则延迟或卡顿的时候，就可以采用分析工具帮我们定位有问题的SQL，这三种分析工具你可以理解是sQL调优的三个步骤:<strong>慢查询、EXPLAIN和 SHOW PROFILING。</strong></p>
<p>小结：<img src="/2022/04/22/MySQL/1652776358602.png" alt="1652776358602" loading="lazy"></p>
<h4 id="2-查看系统性能参数"><a href="#2-查看系统性能参数" class="headerlink" title="2.查看系统性能参数"></a>2.查看系统性能参数</h4><p>在MySQL中，可以是使用<strong>SHOW STATUS</strong>语法查询一些MySQL数据库服务器的<strong>性能参数、执行效率</strong>。</p>
<p>SHOW STATUS语句语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW [GLOBAL|SESSION] STATUS LIKE &#x27;参数&#x27;;</span><br></pre></td></tr></table></figure>

<p>一些常用的性能参数如下：</p>
<ul>
<li>Connections:连接MySQL服务器的次数。.</li>
<li>Uptime: MySQL服务器的上线时间。</li>
<li>Slow_queries:慢查询的次数。</li>
<li> lnnodb_rows_read: Select查询返回的行数</li>
<li>lnnodb_rows_inserted:执行INSERT操作插入的行数I. </li>
<li>Innodb_rows_updated:执行UPDATE操作更新的行数. </li>
<li>lnnodb_rows_deleted:执行DELETE操作删除的行数. </li>
<li>com_select:查询操作的次数。</li>
<li>Com_insert:插入操作的次数。对于批量插入的INSERT 操作，只累加一次。</li>
<li>Com_update:更新操作的次数。</li>
<li>com_delete:删除操作的次数。</li>
</ul>
<p>慢查询次数参数可以结合慢查询日志找出慢查询语句，然后针对慢查询语句进行<strong>表结构优化或者查询语句优化</strong></p>
<p>再比如，如下的指令可以查看相关的指令情况:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Innodb_rows_%&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="3-统计SQL的查询成本：last-query-cost"><a href="#3-统计SQL的查询成本：last-query-cost" class="headerlink" title="3.统计SQL的查询成本：last_query_cost"></a>3.统计SQL的查询成本：last_query_cost</h4><p>一条SQL查询语句在执行前需要确定查询执行计划，如果存在多种执行计划的话，MySQL 会计算每个执行计划所需要的成本，从中选择<strong>成本最小</strong>的一个作为最终执行的执行计划。</p>
<p>如果我们想要查看某条sQL语句的查询成本，可以在执行完这条sQL语句之后，通过查看当前会话中的last_query_cost变量值来得到当前查询的成本。它通常也是我们<strong>评价一个查询的执行效率的一个常用指标</strong>。这个查询成本对应的是<strong>SQL语句所需要读取的页的数量。</strong></p>
<p> 举例：表student_info：<img src="/2022/04/22/MySQL/1652800805940.png" alt="1652800805940" loading="lazy"></p>
<p>如果想查询id=900001的记录，然后查看成本，可以直接在聚簇索引上进行查找：<img src="/2022/04/22/MySQL/1652800859612.png" alt="1652800859612" loading="lazy"></p>
<p>运行结果（1条记录，运行时间为0.042秒）</p>
<p>然后看下查询优化器的版本，实际上只需要检索一个页<img src="/2022/04/22/MySQL/1652800937751.png" alt="1652800937751" loading="lazy"></p>
<p>如果想要查看id在900001到9000100之间的记录<img src="/2022/04/22/MySQL/1652800975163.png" alt="1652800975163" loading="lazy"></p>
<p>运行结果（100条记录，运行时间为0.046s）</p>
<p>然后看下查询优化器的成本，大概需要进行20个页的查询<img src="/2022/04/22/MySQL/1652801077419.png" alt="1652801077419" loading="lazy"></p>
<p>你能看到页的数量是刚才的20倍，但是查询的效率并没有明显的变化，实际上这两个sQL查询的时间基本上一样，就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然<strong>页数量(last_query_cost）增加了不少</strong>，但是通过缓冲池的机制,并<strong>没有增加多少查询时间</strong>。</p>
<p><strong>使用场景</strong>:它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p>
<blockquote>
<p>sQL查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论:</p>
<p>1.<strong>位置决定效率</strong>。如果页就在<strong>数据库缓冲池</strong>中，那么效率是最高的，否则还需要从<strong>内存或者磁盘中</strong>进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。<br>2．<strong>批量决定效率</strong>。如果我们从磁盘中对单一页进行随机读，那么效率是很低的(差不多10ms) ,而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</p>
<p>所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量<strong>放到缓冲池中</strong>，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p>
</blockquote>
<h4 id="4-定位执行慢的SQL：慢查询日志"><a href="#4-定位执行慢的SQL：慢查询日志" class="headerlink" title="4.定位执行慢的SQL：慢查询日志"></a>4.定位执行慢的SQL：慢查询日志</h4><p>MysQL的慢查询日志，用来<strong>记录在MysQL中响应时间超过阀值的语句</strong>，具体指运行时间超过<strong>long.query_time</strong>值的SQL，则会被记录到慢查询日志中。long_query_time的<strong>默认值为10</strong>，意思是运行10秒以上(不含10秒)的语句，认为是超出了我们的最大忍耐时间值。</p>
<p>它的主要作用是，帮助我们发现那些执行时间特别长的SQL查询，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，对解决问题很有帮助。比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合explain进行全面分析。</p>
<p>默认情况下，MySQL数据库<strong>没有开启慢查询日志</strong>，需要我们手动来设置这个参数。<strong>如果不是调优需要的话，一般不建议启动该参数</strong>，因为开启慢查询日志会或多或少带来一定的性能影响。</p>
<p>慢查询日志支持将日志记录写入文件。</p>
<h5 id="4-1开启慢查询日志"><a href="#4-1开启慢查询日志" class="headerlink" title="4.1开启慢查询日志"></a>4.1开启慢查询日志</h5><h6 id="1-开启slow-query-log"><a href="#1-开启slow-query-log" class="headerlink" title="1.开启slow_query_log"></a>1.开启slow_query_log</h6><p>在使用前，需要先看下慢查询是否已经开启，使用下面命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show variables like &#x27;&amp;slow_query_log&amp;&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652801501352.png" alt="1652801501352" loading="lazy"></p>
<p>可以看到slow_query_log=OFF，可以把慢查询日志打开，注意设置变量值的时候需要使用global，否则会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; set global slow_query_log=&#x27;ON&#x27;;</span><br></pre></td></tr></table></figure>

<p>然后我们再来看下慢查询日志是否开启，以及慢查询日志文件位置 </p>
<p><img src="/2022/04/22/MySQL/1652801658998.png" alt="1652801658998" loading="lazy"></p>
<p>可以看到慢查询日志已经开启，同时文件位置保存在/var/ lib/mysql/atguigu02-slow . log文件中。</p>
<h6 id="2-修改long-query-time阈值"><a href="#2-修改long-query-time阈值" class="headerlink" title="2.修改long_query_time阈值"></a>2.修改long_query_time阈值</h6><p>使用以下命令设置慢查询的时间阈值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show variables like &#x27;%long_query_time%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652801777563.png" alt="1652801777563" loading="lazy"></p>
<p>比如把时间设置为1秒：<img src="/2022/04/22/MySQL/1652801800349.png" alt="1652801800349" loading="lazy"></p>
<p><img src="/2022/04/22/MySQL/1652801837932.png" alt="1652801837932" loading="lazy"></p>
<p><strong>补充：配置文件中一并设置参数</strong></p>
<p>如下的方式相较于前面的命令行方式，可以看作时永久设置的方式</p>
<p>修改my .cnf 文件，[mysqld]下增加或修改参数long_query_time 、 slow_query_log和slow_query_log_file后，然后重启MySQL服务器。<img src="/2022/04/22/MySQL/1652801918870.png" alt="1652801918870" loading="lazy"></p>
<p>如果不指定存储路径，慢查询日志将默认存储到MySQL数据库的数据文件下。如果不指定文件名， 默认文件名为hostname-slow.log</p>
<h5 id="4-2查看慢查询数目"><a href="#4-2查看慢查询数目" class="headerlink" title="4.2查看慢查询数目"></a>4.2查看慢查询数目</h5><p>查看当前系统中有多少条慢查询记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE ‘Slow_queries’;</span><br></pre></td></tr></table></figure>

<h5 id="4-3案例演示"><a href="#4-3案例演示" class="headerlink" title="4.3案例演示"></a>4.3案例演示</h5><p>步骤一：建表<img src="/2022/04/22/MySQL/1652802126122.png" alt="1652802126122" loading="lazy"></p>
<p><strong>步骤二：设置参数log_bin_trust_function_creators</strong></p>
<p>创建函数，假如报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This function has none of DETERMINISTIC....</span><br></pre></td></tr></table></figure>

<ul>
<li>命令开启：允许创建函数设置：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global log_bin_trust_function_creators=1;</span><br><span class="line">#不加global只是当前会话有效</span><br></pre></td></tr></table></figure>

<p><strong>步骤三：创建函数</strong></p>
<p>随机产生字符串：<img src="/2022/04/22/MySQL/1652802431996.png" alt="1652802431996" loading="lazy"></p>
<p>产生随机数值：<img src="/2022/04/22/MySQL/1652802493533.png" alt="1652802493533" loading="lazy"></p>
<p><strong>步骤四：创建存储过程</strong><img src="/2022/04/22/MySQL/1652802512011.png" alt="1652802512011" loading="lazy"></p>
<p><strong>步骤五：调用存储过程</strong><img src="/2022/04/22/MySQL/1652802543296.png" alt="1652802543296" loading="lazy"></p>
<h5 id="4-4测试及分析"><a href="#4-4测试及分析" class="headerlink" title="4.4测试及分析"></a>4.4测试及分析</h5><p><strong>1.测试</strong><img src="/2022/04/22/MySQL/1652802659696.png" alt="1652802659696" loading="lazy"></p>
<p>从上面的结果可以看出来，查询学生编号为“3455655”的学生信息花费时间为2.09秒。查询学生姓名为“oQmLur的学生信息花费时间为2.39秒。已经达到了秒的数量级，说明目前查询效率是比较低的，下面的小节我们分析一下原因。</p>
<p><strong>2.分析</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &#x27;slow_queries&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充说明：</p>
<p>除了long_query_time变量外，控制慢查询日志的还有一个系统变量：min_examined_row_limit。这个变量的意思是，<strong>查询扫描过的最少记录数</strong>。这个变量和查询执行时间，共同组成了判别一个查询是否是慢查询的条件。如果查询扫描过的记录数大于等于这个变量的值，并且查询执行时间超过long_query_time的值，那么，这个查询就被记录到慢查询日志中;反之，则不被记录到慢查询日志中。<img src="/2022/04/22/MySQL/1652802988135.png" alt="1652802988135" loading="lazy"></p>
<p>这个值默认是0。与long_query_time=10合在一起，表示只要查询的执行时间超过10秒钟，哪怕一个记录也没有扫描过，都要被记录到慢查询日志中。你也可以根据需要，通过修改“my.ini”文件，来修改查询时长，或者通过SET 指令，用SQL语句修改“min_examined_row_limit”的值。</p>
</blockquote>
<h5 id="4-5慢查询日志分析工具：mysqldumpslow"><a href="#4-5慢查询日志分析工具：mysqldumpslow" class="headerlink" title="4.5慢查询日志分析工具：mysqldumpslow"></a>4.5慢查询日志分析工具：mysqldumpslow</h5><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MysQL提供了日志分析工具<strong>mysqldumpslow</strong> 。</p>
<p>查看mysqldumpslow的帮助信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow --help</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652803226505.png" alt="1652803226505" loading="lazy"></p>
<p>mysqldumpslow命令的具体参数如下：</p>
<ul>
<li><p>-a: 不将数字抽象成N，字符串抽象成S </p>
</li>
<li><p>-s: 是表示按照何种方式排序： </p>
<ul>
<li>c: 访问次数 </li>
<li>l: 锁定时间 </li>
<li>r: 返回记录 </li>
<li><strong>t:</strong> <strong>查询时间</strong> </li>
<li>al:平均锁定时间 </li>
<li>ar:平均返回记录数 </li>
<li>at:平均查询时间 （默认方式） </li>
<li>ac:平均查询次数 </li>
</ul>
</li>
<li><p> -t: 即为返回前面多少条的数据；</p>
</li>
<li><p>-g: 后边搭配一个正则匹配模式，大小写不敏感</p>
</li>
</ul>
<p>举例：我们想要按照查询时间排序，查看前五条 SQL 语句，这样写即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s t -t 5 /var/lib/mysql/atguigu01-slow.log</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652803421497.png" alt="1652803421497" loading="lazy"></p>
<p><strong>工作常用参考</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#得到返回记录集最多的10个SQL </span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log </span><br><span class="line"></span><br><span class="line">#得到访问次数最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log </span><br><span class="line"></span><br><span class="line">#得到按照时间排序的前10条里面含有左连接的查询语句 </span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log</span><br><span class="line"></span><br><span class="line">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况 </span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span><br></pre></td></tr></table></figure>

<h5 id="4-6关闭慢查询日志"><a href="#4-6关闭慢查询日志" class="headerlink" title="4.6关闭慢查询日志"></a>4.6关闭慢查询日志</h5><p>MySQL服务器停止慢查询日志有两种方法：</p>
<p><strong>方式一：永久性方式</strong></p>
<p>修改my.cnf或者my.ini文件，把[mysqld]组下的slow_query_log值设置为OFF，修改保存后，再重启MySQL服务，即可生效;</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="literal">OFF</span></span><br></pre></td></tr></table></figure>

<p>或者，把slow_query_log一项注释掉或删除</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment">#slow_query_log=OFF</span></span><br></pre></td></tr></table></figure>

<p>重启MySQL服务，执行如下语句查询慢查询日志功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%slow%&#x27;; #查询慢查询日志所在目录</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%long_query_time%&#x27; #查询超时时长</span><br></pre></td></tr></table></figure>

<p>可以看到，MySQL系统中的慢查询日志是关闭的。</p>
<p><strong>方式二：临时性方式</strong></p>
<p>使用SET语句来设置。</p>
<p>（1）停止MySQL慢查询日志功能，具体SQL语句如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL slow_query_log=of;</span><br></pre></td></tr></table></figure>

<p>（2）重启MySQL服务，使用SHOW语句查询慢查询日志功能信息，具体SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%slow%&#x27;;</span><br><span class="line">#以及</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%long_query_time%&#x27;;</span><br></pre></td></tr></table></figure>

<h5 id="4-7删除慢查询日志"><a href="#4-7删除慢查询日志" class="headerlink" title="4.7删除慢查询日志"></a>4.7删除慢查询日志</h5><p>使用SHOW语句显示慢查询日志信息，具体SQL语句如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;slow_query_log%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652804981666.png" alt="1652804981666" loading="lazy"></p>
<p>从执行结果可以看出，慢查询日志的目录默认为MysQL的数据目录，在该目录下<strong>手动删除慢查询日志文件</strong>即可。</p>
<p>使用命令mysqladmin flush-logs 来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot -p flush-logs slow</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示</p>
<p>慢查询日志都是使用mysqladmin flush-logs命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。</p>
</blockquote>
<h4 id="5-查看SQL执行成本：SHOW-PROFILE"><a href="#5-查看SQL执行成本：SHOW-PROFILE" class="headerlink" title="5.查看SQL执行成本：SHOW PROFILE"></a>5.查看SQL执行成本：SHOW PROFILE</h4><p>Show Profile是MySQL提供的可以用来分析当前会话中SQL都做了什么、执行的资源消耗的情况工具，可用于sql调优的测量。<strong>默认情况下处于关闭状态</strong>，并保存最近的15次运行结果。</p>
<p>可以在会话级别开启这个功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show variables like &#x27;profiling&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652805311416.png" alt="1652805311416" loading="lazy"></p>
<p>通过设置profiling=’ON‘来开启slow profile;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; set profiling = &#x27;ON&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652805357832.png" alt="1652805357832" loading="lazy"></p>
<p>然后执行相关查询语句，接着看下当前会话都有哪些 profiles，使用下面这条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show profiles;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652805409873.png" alt="1652805409873" loading="lazy"></p>
<p>能看到当前会话一共有 2 个查询。如果我们想要查看最近一次查询的开销，可以使用： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show profile;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652805437849.png" alt="1652805437849" loading="lazy"></p>
<p>我们也可以查看指定的Query ID的开销，比如show profile for query 2查询结果是一样的。在SHOW PROFILE 中可以查看不同部分的开销，比如cpu、block.io等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show profile cpu,block io for query 2;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652805709800.png" alt="1652805709800" loading="lazy"></p>
<p>通过上面的结果，就可以弄清楚每一步耗时，以及在不同部分，比如CPU、block.io的执行时间，这样我们可以判断出SQL到底慢在哪里</p>
<p><strong>show profile的常用查询参数：</strong> </p>
<p>① ALL：显示所有的开销信息。 ② BLOCK IO：显示块IO开销。 ③ CONTEXT SWITCHES：上下文切换开销。 ④ CPU：显示CPU开销信息。 ⑤ IPC：显示发送和接收开销信息。 ⑥ MEMORY：显示内存开销信 息。 ⑦ PAGE FAULTS：显示页面错误开销信息。 ⑧ SOURCE：显示和Source_function，Source_file,Source_line相关的开销信息。 ⑨ SWAPS：显示交换次数开销信息。 </p>
<p><strong>日常开发需注意的结论:</strong><br>converting HEAP to MyISAM:查询结果太大，内存不够，数据往磁盘上搬了。</p>
<p>Creating tmp table:创建临时表。先拷贝数据到临时表，用完后再删除临时表。</p>
<p>Copying to tmp table on disk:把内存中临时表复制到磁盘上，警惕!</p>
<p>blocked 。</p>
<p>如果在show profile诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化。</p>
<p><strong>注意:</strong><br>不过SHOW PROFILE 命令将被弃用，我们可以从information_schema 中的profiling数据表进行查看。</p>
<h4 id="6-分析查询语句：EXPLAIN"><a href="#6-分析查询语句：EXPLAIN" class="headerlink" title="6.分析查询语句：EXPLAIN"></a>6.分析查询语句：EXPLAIN</h4><blockquote>
<p>什么是explain？</p>
<p>即：sql的执行计划，使用explain关键字可以模拟优化器执行sql查询语句，从而知道mysql是如何处理sql语句的</p>
</blockquote>
<h5 id="6-1概述"><a href="#6-1概述" class="headerlink" title="6.1概述"></a>6.1概述</h5><p><strong>定位了查询慢的SQL之后，就可以使用EXPLAIN或DESCRIBE工具做针对性的分析查询语句。</strong>DESCRIBE语句的使用方法与EXPLAIN语句一样，分析结果也是一样的</p>
<p>MysQL中有专门负责优化SELECT语句的优化器模块，主要功能:通过计算分析系统中收集到的统计信息，为客户端请求的Query提供它认为最优的执行计划（他认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间)。<br>这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL为我们提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划，大家看懂EXPLAIN语句的各个输出项，可以有针对性的提升我们查询语句的性能。</p>
<p><strong>1.能做什么？</strong></p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<p><strong>2.官网介绍</strong></p>
<p><strong><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">https://dev.mysql.com/doc/refman/5.7/en/explain-output.html</a></strong> </p>
<p><strong><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">https://dev.mysql.com/doc/refman/8.0/en/explain-output.html</a></strong> </p>
<p><img src="/2022/04/22/MySQL/1653095427721.png" alt="1653095427721" loading="lazy"></p>
<p><strong>3.版本情况</strong></p>
<ul>
<li><p>MySQL 5.6.3以前只能EXPLAIN SELECT;MYSQL 5.6.3以后就可以EXPLAIN SELECT，UPDATE,DELETE</p>
</li>
<li><p>在5.7以前的版本中，想要显示partitions需要使用explain partitions命令;想要显示filtered需要使用explain extended命令。在5.7版本后，默认explain直接显示<strong>partitions和filtered</strong>中的信息。</p>
</li>
</ul>
<p><img src="/2022/04/22/MySQL/1653095561908.png" alt="1653095561908" loading="lazy"></p>
<h5 id="6-2基本语法"><a href="#6-2基本语法" class="headerlink" title="6.2基本语法"></a>6.2基本语法</h5><p>EXPLAIN或DESCSRIBE语句的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT select_options</span><br><span class="line">#或</span><br><span class="line">DESCRIBE SELECT select_options</span><br></pre></td></tr></table></figure>

<p>如果想看看某个查询执行计划，可以在具体语句前加explain：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; EXPLAIN SELECT 1;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1653095842869.png" alt="1653095842869" loading="lazy"></p>
<p>输出的上述信息就是所谓的执行计划。在这个执行计划的辅助下，我们需要知道应该怎样改进自己的查询语句以使查询执行起来更高效。其实除了以SELECT开头的查询语句，其余的DELETE、INSERT、REPLACE 以及UPDATE语句等都可以加上EXPLAIN，用来查看这些语句的执行计划，只是平时我们对SELECT语句更感兴趣。</p>
<p>注意:执行EXPLAIN时并没有真正的执行该后面的语句，因此可以安全的查看执行计划。</p>
<p>EXPLAIN语句输出的各个列的作用如下:</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>在一个大的查询语句中每个SELECT关键字对应一个<strong>唯一id</strong>(表的读取顺序)</td>
</tr>
<tr>
<td>select_type</td>
<td>SELECT关键字对应的那个查询的类型</td>
</tr>
<tr>
<td>table</td>
<td>表明</td>
</tr>
<tr>
<td>pertitions</td>
<td>匹配的分区信息</td>
</tr>
<tr>
<td>type</td>
<td>针对单表的访问方法(访问类型)</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>实际使用的索引长度</td>
</tr>
<tr>
<td>ref</td>
<td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td>rows</td>
<td>预估需要读取的行数</td>
</tr>
<tr>
<td>filterd</td>
<td>某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>一些额外信息</td>
</tr>
</tbody></table>
<h5 id="6-3数据准备"><a href="#6-3数据准备" class="headerlink" title="6.3数据准备"></a>6.3数据准备</h5><p><strong>1.建表</strong></p>
<p><img src="/2022/04/22/MySQL/1653096704579.png" alt="1653096704579" loading="lazy"></p>
<p><strong>2.设置参数log_bin_trust_function_creators</strong></p>
<p>创建函数，加入报错，开启：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global log_bin_trust_function_creators; #不加global只对当前窗口有效</span><br></pre></td></tr></table></figure>

<p><strong>3.创建函数</strong></p>
<p><img src="/2022/04/22/MySQL/1653096838285.png" alt="1653096838285" loading="lazy"></p>
<p><strong>4.创建存储过程</strong></p>
<p>创建往s1表中插入数据的存储过程：<img src="/2022/04/22/MySQL/1653096886918.png" alt="1653096886918" loading="lazy"></p>
<p>创建往s2表中插入数据的存储过程：<img src="/2022/04/22/MySQL/1653096956683.png" alt="1653096956683" loading="lazy"></p>
<p><strong>5.调用存储过程</strong></p>
<p><img src="/2022/04/22/MySQL/1653096975431.png" alt="1653096975431" loading="lazy"></p>
<h5 id="6-4EXPLAIN各列作用"><a href="#6-4EXPLAIN各列作用" class="headerlink" title="6.4EXPLAIN各列作用"></a>6.4EXPLAIN各列作用</h5><h6 id="1-table"><a href="#1-table" class="headerlink" title="1.table"></a><strong>1.table</strong></h6><p>不论我们的查询语句有多复杂，里边儿 <strong>包含了多少个表</strong> ，到最后也是需要对每个表进行 <strong>单表访问</strong> 的，所以MySQL规定<strong>EXPLAIN语句输出的每条记录都对应着某个单表的访问方法</strong>，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。</p>
<h6 id="2-id"><a href="#2-id" class="headerlink" title="2.id"></a>2.id</h6><p><img src="/2022/04/22/MySQL/1653097396890.png" alt="1653097396890" loading="lazy"></p>
<p><img src="/2022/04/22/MySQL/1653097545054.png" alt="1653097545054" loading="lazy"></p>
<ul>
<li>id相同顺序执行</li>
<li>id不同，值越大优先级越高，越先被执行</li>
<li>两种情况同时存在，永远是id越大越先执行，id相同顺序执行</li>
<li><strong>关注点：</strong>id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</li>
</ul>
<h6 id="3-select-type"><a href="#3-select-type" class="headerlink" title="3.select_type"></a>3.select_type</h6><p>一条大的查询语句里边可以包含若干个SELECT关键字，<strong>每个SELECT关键字代表着一个小的查询语句</strong>，而每个SELECT关键字的FROM子句中都可以包含若干张表(这些表用来做连接查询)，<strong>每一张表都对应着执行计划输出中的一条记录，对于在同一个SELECT关键字中的表来说，它们的id值是相同的</strong>。</p>
<p>MysQL为每一个SELECT关键字代表的小查询都定义了一个称之为<strong>select_type</strong>的属性，意思是我们只要知道了某个小查询的select_type属性，就知道了这个小查询在整个大查询中扮演了一个什么角色，我们看一下select_type都能取哪些值，请看官方文档:</p>
<p><img src="/2022/04/22/MySQL/1653098304861.png" alt="1653098304861" loading="lazy"></p>
<p>具体分析：</p>
<p>select_type:查询类型，用于区别普通查询、联合查询、子查询等复杂查询</p>
<ul>
<li><p>SIMPLE：简单select查询，查询中不包含子查询或union</p>
</li>
<li><p>PRIMARY：查询中若包含任何复杂的子部分，最外层则被标记为primary</p>
</li>
<li><p>SUBQUERY：在select或where列表中包含了子查询 <img src="/2022/04/22/MySQL/1653099167641.png" alt="1653099167641" loading="lazy"><img src="/2022/04/22/MySQL/1653098552304.png" alt="1653098552304" loading="lazy"></p>
</li>
<li><p>DEPENDENT SUBUERY<img src="/2022/04/22/MySQL/1653099157786.png" alt="1653099157786" loading="lazy"></p>
</li>
<li><p>DERIUED：在from列表中包含的子查询被标记为此(衍生)mysql会递归执行这些子查询，把结果放在临时表</p>
</li>
<li><p>UNION：若第二个select出现在union后，则被标记为UNION，若union包含在from子句的子查询中，外层select被标记为derived，对于union或union all来说，除了最左边小查询外，其余的就是union</p>
</li>
<li><p>DEPENDENT UNION<img src="/2022/04/22/MySQL/1653099265336.png" alt="1653099265336" loading="lazy"></p>
</li>
<li><p>UNION RESULT：从union表获取结果的select(合并之后的查询就是这个选项)</p>
</li>
<li><p>MATERIALIZED<img src="/2022/04/22/MySQL/1653099413713.png" alt="1653099413713" loading="lazy"></p>
</li>
</ul>
<h6 id="4-partitions"><a href="#4-partitions" class="headerlink" title="4.partitions"></a>4.partitions</h6><p><img src="/2022/04/22/MySQL/1653099546460.png" alt="1653099546460" loading="lazy"></p>
<h6 id="5-type☆"><a href="#5-type☆" class="headerlink" title="5.type☆"></a>5.type☆</h6><p><strong>type：访问类型，结果值从最好到最坏依次：system&gt;const&gt;eq_ref&gt;ref&gt;fulltext&gt;ref_or_null&gt;index_merge&gt;unique_subquery&gt;index_subquery&gt;range&gt;index&gt;All</strong></p>
<p>常见指标主要有：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;All,一般只要要达到range级别，最好到ref</p>
<ul>
<li><p><strong>system</strong></p>
<p>当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyIASM，那么对该表访问方法就是sytem</p>
</li>
<li><p><strong>const</strong></p>
<p>当我们根据主键或唯一的二级索引(unique)与常数进行等值匹配时，对单表访问方法就是const</p>
</li>
<li><p><strong>eq_ref</strong></p>
<p>在连接查询时，如果被驱动表是通过主键或唯一二级索引列等值匹配的方式进行访问（如果该主键或唯一二级索引是联合索引，所有索引列都必须等值比较），则对该被驱动表的访问方法就是eq_ref</p>
</li>
<li><p><strong>ref</strong></p>
<p>当通过普通二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是ref</p>
</li>
<li><p><strong>range</strong></p>
<p>如果使用索引获取某些范围区间的记录，就可能使用range</p>
</li>
<li><p><strong>index</strong></p>
<p>当我们可以使用索引覆盖，但需要扫描全部索引记录时，该表访问方法是index</p>
</li>
<li><p>all</p>
<p>全表扫描</p>
</li>
</ul>
<h6 id="6-possible-keys和key"><a href="#6-possible-keys和key" class="headerlink" title="6.possible_keys和key"></a>6.possible_keys和key</h6><p>在EXPLAIN语句输出的执行计划中, possible_keys列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些。一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。key列表示实际用到的索引有哪些，如果为NULL，则没有使用索引。比方说下边这个查询:</p>
<h6 id="7-key-len☆"><a href="#7-key-len☆" class="headerlink" title="7.key_len☆"></a><strong>7.key_len</strong>☆</h6><p>实际使用到的索引长度（即，字节数）</p>
<p>检查是否充分利用索引，值越大越好（针对于联合索引）</p>
<h6 id="8-ref"><a href="#8-ref" class="headerlink" title="8.ref"></a>8.ref</h6><p>当使用索引列等值查询时，与索引列进行等值匹配的对象信息，比如只是一个常数或某个列</p>
<h6 id="9-rows☆"><a href="#9-rows☆" class="headerlink" title="9.rows☆"></a>9.rows☆</h6><p>预估读取的记录行数，值越小越好</p>
<h6 id="10-filtered"><a href="#10-filtered" class="headerlink" title="10.filtered"></a>10.filtered</h6><p>某个表经过搜索条件过滤后剩余记录条数中应用到结果的条数的百分比</p>
<p>对于单表查询来说，这个filtered列的值没什么意义，我们更关注连接查询中驱动表对应的执行计划记录的filtered值，它决定了被驱动表要执行的次数（即：rows*filtered）</p>
<h6 id="11-Extra☆"><a href="#11-Extra☆" class="headerlink" title="11.Extra☆"></a>11.Extra☆</h6><p>一些额外信息，可以通过额外信息来更准确的理解MySQL到底将如何执行给定的查询语句。</p>
<ul>
<li><p>no table used</p>
<p>当查询语句没有from子句时会提示该信息</p>
<blockquote>
<p>explain select 1</p>
</blockquote>
</li>
<li><p>Impossible WHERE</p>
<p>查询语句的WHERE子句永远为FALSE时将会提示该信息</p>
<blockquote>
<p>explain select * from s1 where 1！=1 </p>
</blockquote>
</li>
<li><p>using where</p>
<p>(1)当使用全表扫描(没使用索引)来执行对某个表的查询，并且该语句的where子句中有针对该表的搜索条件时，会提示该信息</p>
<blockquote>
<p>explain select * from s1 where common_field=’a’</p>
</blockquote>
<p>(2)当使用索引执行来执行对某个表的查询，并且该语句的where子句中有除了该索引包含的列之外的其他搜索条件时，会提示该信息</p>
<blockquote>
<p>explain select * from s1 where key1=’a’ and common_field = ‘a’</p>
</blockquote>
</li>
<li><p>no matching min/max row</p>
<p>当查询列表处有min或max聚合函数，但表中并没有where子句中的搜索条件的记录时，会提示该信息</p>
<blockquote>
<p>explain select MIN(key1) from s1 where key1=’abcdef’</p>
<p>表s1中没有abcdef这一条记录</p>
</blockquote>
</li>
<li><p>using index</p>
<p>当查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用覆盖索引的情况下，在‘Extra’列将会提示该额外信息。</p>
<blockquote>
<p>EXPLAIN SELECT key1 FROM s1 WHERE key1=’a’;</p>
</blockquote>
</li>
<li><p>using index condition</p>
<p>有些搜索条件中虽然出现了索引列，但却不能使用到索引</p>
<blockquote>
<p>EXPLAIN SELECT * FROM s1 WHERE key&gt;’z’ AND key1 LIKE ‘%a’</p>
</blockquote>
</li>
<li><p>using join buffer</p>
<p>在连接查询过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为其分配一块名叫“join buffer”的内存块来加快查询速度</p>
<blockquote>
<p>EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field =  s2.common_field</p>
</blockquote>
</li>
</ul>
<h2 id="InnoDB数据存储结构"><a href="#InnoDB数据存储结构" class="headerlink" title="InnoDB数据存储结构"></a>InnoDB数据存储结构</h2><h3 id="1-数据库的存储结构：页"><a href="#1-数据库的存储结构：页" class="headerlink" title="1.数据库的存储结构：页"></a>1.数据库的存储结构：页</h3><p>索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都是保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的<strong>存储引擎</strong>负责对表中数据的读取和写入工作。不同存储引擎中<strong>存放的格式</strong>一般是不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。</p>
<h4 id="1-1磁盘与内存交互基本单位"><a href="#1-1磁盘与内存交互基本单位" class="headerlink" title="1.1磁盘与内存交互基本单位"></a>1.1磁盘与内存交互基本单位</h4><p>InnoDB将数据划分为若干个页，InnoDB中页的大小默认为<strong>16KB。</strong></p>
<p>以<strong>页</strong>作为磁盘和内存之间交互的<strong>基本单位</strong>，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，<strong>在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载</strong>。<strong>也就是说，数据库管理存储空间的基本单位是页(Page)，数据库I/o操作的最小单位是页。</strong><br>一个页中可以存储多个行记录。</p>
<blockquote>
<p>记录时按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次IO操作）只能处理一行数据，效率会非常低</p>
</blockquote>
<p><img src="/2022/04/22/MySQL/1652691435656.png" alt="1652691435656" loading="lazy"></p>
<h4 id="1-2页结构概述"><a href="#1-2页结构概述" class="headerlink" title="1.2页结构概述"></a>1.2页结构概述</h4><p>页a、页b、页c…页n这些页可以<strong>不在物理结构上相连</strong>，只要通过<strong>双向链表</strong>相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个<strong>单向链表</strong>，每个数据页都会为存储在它里边的记录生成一个<strong>页目录</strong>，在通过主键查找某条记录的时候可以在页目录中<strong>使用二分法</strong>快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p>
<h4 id="1-3页的大小"><a href="#1-3页的大小" class="headerlink" title="1.3页的大小"></a>1.3页的大小</h4><p>不同的数据库管理系统（简称DBMS ）的页大小不同。比如在MysQL的InnoDB存储引擎中，默认页的大小是<strong>16KB</strong>，我们可以通过下面的命令来进行查看:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%innodb_page_size%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652691326064.png" alt="1652691326064" loading="lazy"></p>
<p>SQL Server中页的大小为 <strong>8KB</strong>，而在Oracle中我们用术语“块”(Block)来代表“页”，Oralce支持的块大小为2KB，4KB，8KB，16KB，32KB和64KB。</p>
<h4 id="1-4页的上层结构"><a href="#1-4页的上层结构" class="headerlink" title="1.4页的上层结构"></a>1.4页的上层结构</h4><p>另外在数据库中，还存在着区(Extent)、段(Segment)和表空间(Tablespace)的概念。行、页、区、段、表空间的关系如下图所示:<img src="/2022/04/22/MySQL/1652691645599.png" alt="1652691645599" loading="lazy"></p>
<p>区(Extent)是比页大一级的存储结构，在InnoDB存储引擎中，<strong>一个区会分配64个连续的页</strong>。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB= 1MB。</p>
<p>段(Segment)由一个或多个区组成，区在文件系统是一个连续分配的空间(在InnoDB中是连续的64个页)，不过在段中不要求区与区之间是相邻的。<strong>段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在</strong>。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p>
<p>表空间（Tablespace）是一逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间，书库由一个或表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等</p>
<h3 id="2-页的内部结构"><a href="#2-页的内部结构" class="headerlink" title="2.页的内部结构"></a>2.页的内部结构</h3><p>页如果按类型划分的话，常见的有数据页（保存B+树节点)、系统页、Undo页和事务数据页等。数据页是我们最常使用的页。</p>
<p>数据页的<strong>16KB</strong> 大小的存储空间被划分为七个部分，分别是文件头(File Header)、页头(Page Header)、最大最小记录(Infimum+supremum)、用户记录(User Records)、空闲空间(Free Space)、页目录(Page Directory)和文件尾(File Tailer) 。页结构的示意图如下所示:<img src="/2022/04/22/MySQL/1652692705943.png" alt="1652692705943" loading="lazy"></p>
<p>这7个部分作用分别如下，我们简单梳理如下表示：<img src="/2022/04/22/MySQL/1652692754560.png" alt="1652692754560" loading="lazy"></p>
<p>我们可以把这7个结构分成3个部分。</p>
<h4 id="第一部分：File-Header-文件头部-和File-Trailer-文件尾部"><a href="#第一部分：File-Header-文件头部-和File-Trailer-文件尾部" class="headerlink" title="第一部分：File Header(文件头部)和File Trailer(文件尾部)"></a>第一部分：File Header(文件头部)和File Trailer(文件尾部)</h4><p>首先是文件通用部分，也就是文件头和文件尾</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><h4 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h4><p>满足ACID特性的一组操作，要么全部成功，要么全部失败，可以通过Commit提交，或Rollback回滚 <img src="/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323233373932352e706e67.png" alt="img" loading="lazy"> </p>
<blockquote>
<p>举个栗子</p>
</blockquote>
<p>转账操作：小明要给小红转账1000，这个事物涉及两个操作：</p>
<ol>
<li>小明账户减少1000</li>
<li>小红账户增加1000</li>
</ol>
<p>而事物会把这两个操作再逻辑上看成一个整体，要么全部成功，要么全部失败</p>
<p>这样因为事物的存在就不会出现小明余额减少而小红余额没变的情况</p>
<h4 id="数据库事物"><a href="#数据库事物" class="headerlink" title="数据库事物"></a>数据库事物</h4><blockquote>
<p>数据库事物的作用</p>
</blockquote>
<p>数据库的事物可以保证多个对数据库的操作(sql语句)构成一个逻辑上的整体，而这个逻辑上的整体需要遵循：<strong>要么全部成功、要么全部失败</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 开启一个事物</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"># 多余的<span class="keyword">sql</span>语句</span><br><span class="line">sql1，sql2...</span><br><span class="line"># 提交事物</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p> <img src="/2022/04/22/MySQL/640-20201207160554677.png" alt="img" loading="lazy"> </p>
<h4 id="数据库的ACID"><a href="#数据库的ACID" class="headerlink" title="数据库的ACID"></a>数据库的ACID</h4><p> <img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7.png" alt="事务的特性" loading="lazy"> </p>
<ol>
<li><p>原子性(Atomicity)</p>
<p>事物被视为不可分割的修小单位，事物的所有操作要么全部成功 ，要么全部失败回滚，而回滚可以通过回滚日志(undo log)来实现</p>
</li>
<li><p>一致性(Consistency)</p>
<p>事物在执行前后保持一致性状态，例如转账事物中，无论是否成功，转账人和收款人总额不变</p>
</li>
<li><p>隔离性(Lsolation)</p>
<p>一个事物在最终提交前，对其他事物不可见</p>
</li>
<li><p>持久性(Durability)</p>
<p>一旦事物提交，则所作修改时永久性的保留在数据库中 ，即使发生系统崩溃，事物执行过的结果也不会丢失。 系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。 </p>
</li>
</ol>
<hr>
<p><strong>事物的ACID并不是一种平级关系：</strong></p>
<ul>
<li><p>只有满足一致性，事物的执行结果才是正确的</p>
</li>
<li><p>在无并发的情况下，事物串行执行，隔离性一定能满足，只需要满足原子性，就一定满足一致性</p>
</li>
<li><p>在并发情况下，多个事物并行执行，事物不仅要满足原子性、还需要满足隔离性，才能保证一致性</p>
</li>
<li><p>事物满足持久化是为了能应对系统崩溃的情况</p>
<p><img src="/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373231303433373032332e706e67.png" alt="img" loading="lazy"> </p>
</li>
</ul>
<h4 id="事物实现原理"><a href="#事物实现原理" class="headerlink" title="事物实现原理"></a>事物实现原理</h4><ul>
<li>InnoDB引擎通过使用redo log(重做日志)来保证事物的持久性，使用undo log(回滚日志)保证事物的原子性</li>
<li>通过锁机制、MVCC来保证事物的隔离性(默认隔离级别可重复读)</li>
</ul>
<p>保证了事物的原子性、持久性、隔离性，才能保证一致性</p>
<h4 id="事务的状态"><a href="#事务的状态" class="headerlink" title="事务的状态"></a>事务的状态</h4><p>事务是一个抽象概念，对应着一个或多个数据库操作，根据这些操作所执行的不同阶段把事务大致分为几个状态:</p>
<ul>
<li><p>活动的（active）</p>
<p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在 活动的 状态。</p>
</li>
<li><p>部分提交的（partially comitted）</p>
<p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并 没有刷新到磁盘时，我们就说该事务处在 部分提交的 状态</p>
</li>
<li><p>失败的（failed）</p>
<p>当事务处在 活动的 或者 部分提交的 状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 失败的 状态。</p>
</li>
<li><p>中止的（aborted）</p>
<p>如果事务执行了一部分而变为 失败的 状态，那么就需要把已经修改的事务中的操作还原到事务执 行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为 回滚 。当 回滚 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了 中止的 状态。</p>
</li>
<li><p>提交的（committed）</p>
<p>当一个处在 部分提交的 状态的事务将修改过的数据都 同步到磁盘 上之后，我们就可以说该事务处在了 提交的 状态。 </p>
</li>
</ul>
<p><img src="/2022/04/22/MySQL/1651305961834.png" alt="1651305961834" loading="lazy"></p>
<h3 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h3><p>事务分为显示事务和隐式事务</p>
<h4 id="1-显示事务"><a href="#1-显示事务" class="headerlink" title="1.显示事务"></a>1.显示事务</h4><p>步骤一：START TRANSACTION 或 BEGIN,作用是显示开启一个事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">#或者</span><br><span class="line">mysql&gt; START TRANSACTION;</span><br></pre></td></tr></table></figure>

<p>START TRANSACTION 语句相较于 BEGIN 特别之处在于，后边能跟随几个 修饰符 ： </p>
<ol>
<li>READ ONLY:标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，不能修改数据</li>
<li>READ WRITE：标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</li>
<li>WITH CONSISTENT SNAPSHOT ：启动一致性读。</li>
</ol>
<p>步骤二：一系列事务中的操作（主要是DML,不含DDL）</p>
<p>步骤三：提交事务或终止事务(即回滚事务)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 提交事务。当提交事务后，对数据库的修改是永久性的。 </span><br><span class="line">mysql&gt; COMMIT;</span><br><span class="line"></span><br><span class="line"># 回滚事务。即撤销正在进行的所有没有提交的修改 </span><br><span class="line">mysql&gt; ROLLBACK; </span><br><span class="line"># 将事务回滚到某个保存点。 </span><br><span class="line">mysql&gt; ROLLBACK TO [SAVEPOINT]</span><br></pre></td></tr></table></figure>

<h4 id="2-隐式事务"><a href="#2-隐式事务" class="headerlink" title="2.隐式事务"></a>2.隐式事务</h4><p>MySQL中有一个系统变量autocommit：<img src="/2022/04/22/MySQL/1651306388108.png" alt="1651306388108" loading="lazy"></p>
<p>当然，如果我们想关闭这种 自动提交 的功能，可以使用下边两种方法之一： </p>
<ul>
<li><p>显式的的使用 START TRANSACTION 或者 BEGIN 语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。 </p>
</li>
<li><p>把系统变量 autocommit 的值设置为 OFF ，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit = OFF; </span><br><span class="line">#或</span><br><span class="line">SET autocommit = 0;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-隐式提交数据的情况"><a href="#3-隐式提交数据的情况" class="headerlink" title="3.隐式提交数据的情况"></a>3.隐式提交数据的情况</h4><ul>
<li><p>数据定义语言（DDL）</p>
</li>
<li><p>隐式使用或修改mysql数据库中的表</p>
</li>
<li><p>事务控制或关于锁定的语句</p>
<p>① 当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了 </p>
<p>另一个事务时，会 隐式的提交 上一个事务。即： </p>
<p>② 当前的 autocommit 系统变量的值为 OFF ，我们手动把它调为 ON 时，也会 隐式的提交 前边语 </p>
<p>句所属的事务。 </p>
<p>③ 使用 LOCK TABLES 、 UNLOCK TABLES 等关于锁定的语句也会 隐式的提交 前边语句所属的事 </p>
<p>务。</p>
</li>
<li><p>加载数据的语句</p>
</li>
<li><p>关于MySQL复制的一些语句</p>
</li>
<li><p>其他一些语句</p>
</li>
</ul>
<blockquote>
<p>当我们设置 autocommit=0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事 务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。 </p>
<p>当我们设置 autocommit=1 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效，在 ROLLBACK 时才会回滚。</p>
</blockquote>
<h3 id="事物的隔离级别"><a href="#事物的隔离级别" class="headerlink" title="事物的隔离级别"></a>事物的隔离级别</h3><h4 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h4><p>在并发环境下，事物的隔离性很难保证，因此会出现很多并发一致性问题</p>
<p><strong>丢失修改</strong></p>
<p>丢失修改是指一个事物的更新操作被另一个事物更新操作替换。例如：T1和T2两个事物对一个数据修改，T1先修改并提交生效，T2随后修改，T2的修改覆盖了T1的修改 <img src="/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313734343234342e706e67.png" alt="img" loading="lazy"> </p>
<p><strong>读脏数据</strong></p>
<p>读脏数据指在不同事物下，当前事物读取到了另外事物未提交的数据。 例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。  <img src="/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313932303336382e706e67.png" alt="img" loading="lazy"> </p>
<p><strong>不可重复读</strong></p>
<p>不可重复度指一个事物内多次读取同一数据集合，在这一事物还未结束前，另一事物也访问了同一数据集合并做了修改，从而导致第一个事物两次读取同一数据结果不一致。例如 ：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。  <img src="/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323130323031302e706e67.png" alt="img" loading="lazy"> </p>
<p><strong>幻影读</strong></p>
<blockquote>
<p>某次select的结果不足以支撑后续业务操作</p>
</blockquote>
<p>幻读本质上也属于不可重复读， T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。  <img src="/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323133343330362e706e67.png" alt="img" loading="lazy"> </p>
<blockquote>
<p>不可重复读和幻读区别</p>
</blockquote>
<p>不可重复读的重点是修改 比如多次读取一条记录发现其中某些列的值被修改 ，而幻读的重点在于新增或删除 比如多次查询同一条查询语句（DQL）时，记录发现记录增多或减少了。 </p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例一：事物1中A读取自己的工资1000的操作还没完成，事物2的B就修改了A的工资为2000，导致A再次读取自己的工资变为2000；这就是不可重复度</span></span><br><span class="line"><span class="comment">//例二：某工资单表中薪资大于3000的有4人，事物1读取了所有工资大于3000的人查到四条记录，这时事物2插入了一条大于3000的记录，事物1再次读取发现变为了5条，这就是幻读</span></span><br></pre></td></tr></table></figure>



<hr>
<p>产生并发一致性问题的主要原因是破坏了事物的隔离级别，解决方法是通过并发控制来保证隔离性。并发控制通过封锁来实现，但封锁操作需要用户操作，数据库管理系统提供了事物的隔离性级别，以轻松方式处理并发一致性问题</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><ul>
<li><strong>未提交读（READ UNCOMMITTED</strong>）</li>
</ul>
<p>事物中的修改，即使没有提交对其他事物也是可见。可能会发生脏读、幻读，不可重复度</p>
<ul>
<li><strong>提交读（READ COMMITTED）</strong></li>
</ul>
<p>一个事务只能读取已经提交的事物所作的修改，解决脏读，会发生不可重复读、幻读</p>
<ul>
<li><strong>可重复读（REPEATABLE READ）</strong></li>
</ul>
<p>保证在一个事物中多次读取统一数据的结果一样，解决脏读和不可重复读，会发生幻读</p>
<ul>
<li><strong>可串行化（SERIALIZABLE）</strong></li>
</ul>
<p>强制事物串行执行，多个事物互不干扰，不会出现并发一致性问题。</p>
<p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事物执行，也就是保证事物串行执行。解决脏读、不可重复读、幻读</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h4 id="MySQL默认隔离级别"><a href="#MySQL默认隔离级别" class="headerlink" title="MySQL默认隔离级别"></a>MySQL默认隔离级别</h4><p>MySQL8.0默认隔离级别是可重复读</p>
<hr>
<p>MySQL的InnoDB的可重复读，加上加锁读来保证避免幻读。而这个加锁读的机制是<strong>Next-Key Locks</strong></p>
<h4 id="设置隔离级别"><a href="#设置隔离级别" class="headerlink" title="设置隔离级别"></a>设置隔离级别</h4><p><strong>通过一下语句修改事物的隔离级别</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION IOSLATION LEVEL 隔离级别;</span><br><span class="line">其中隔离级别：</span><br><span class="line">    READ UNCOMMITTED</span><br><span class="line">    READ COMMITTED</span><br><span class="line">    REPEATABLE READ</span><br><span class="line">    SERIALIZABLE</span><br><span class="line">或者</span><br><span class="line">SET [GLOBAL|SESSION] TRANSACTION_ISOLATION=<span class="string">&#x27;隔离级别&#x27;</span></span><br><span class="line">其中隔离级别：</span><br><span class="line">    READ-UNCOMMITTED</span><br><span class="line">    READ-COMMITTED</span><br><span class="line">    REPETABLE-READ</span><br><span class="line">    SERIALIZABLE</span><br></pre></td></tr></table></figure>

<p>关于设置时使用GLOBAL或SESSION的影响：</p>
<ul>
<li><p>使用GLOBAL关键字（全局范围）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line"># 或者</span><br><span class="line">SET GLOBAL TRANSACTION_ISOLATION=<span class="string">&#x27;SERIALIZABLE&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>则：</p>
<ul>
<li>当前已经存在的会话无效</li>
<li>只对执行完该语句之后产生的会话起作用</li>
</ul>
</li>
<li><p>使用SESSION关键字（在会话范围影响）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION TRANSCATION IOSLATION LEVEL SERIALIZABLE;</span><br><span class="line">#或者</span><br><span class="line">SET SESSION TRANSACTION_ISOLATION=<span class="string">&#x27;SERIALIZABLE&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>则：</p>
<ul>
<li>对当前会话的所有后续的事物有效</li>
<li>如果在事物之间执行，则对后续的事物有效</li>
<li>该语句可以在已经开启的事物中间执行，但不会影响当前正在执行的事物</li>
</ul>
</li>
</ul>
<blockquote>
<p>小结：数据库规定了多种事物隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性越好，并发度越低</p>
</blockquote>
<h4 id="实际情况演示"><a href="#实际情况演示" class="headerlink" title="实际情况演示"></a>实际情况演示</h4><blockquote>
<p>使用2个命令行，模拟多线程(多事物)对同一份数据的脏读</p>
</blockquote>
<p>MySQL 命令行的默认配置中事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。如果要显式地开启一个事务需要使用命令：<code>START TRANSACTION</code>。</p>
<p>我们可以通过下面的命令来设置隔离级别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE]</span><br></pre></td></tr></table></figure>

<p>我们再来看一下我们在下面实际操作中使用到的一些并发控制语句:</p>
<ul>
<li><code>START TRANSACTION</code> |<code>BEGIN</code>：显式地开启一个事务。</li>
<li><code>COMMIT</code>：提交事务，使得对数据库做的所有修改成为永久性。</li>
<li><code>ROLLBACK</code>：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。</li>
</ul>
<p><strong>脏读（读未提交）</strong><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-31-1%E8%84%8F%E8%AF%BB(%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4)%E5%AE%9E%E4%BE%8B.jpg" alt="img" loading="lazy"> </p>
<p><strong>避免脏读（读已提交）</strong><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-31-2%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%E5%AE%9E%E4%BE%8B.jpg" alt="img" loading="lazy"> </p>
<p><strong>不可重复读</strong><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-32-1%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%AE%9E%E4%BE%8B.jpg" alt="img" loading="lazy"> </p>
<p><strong>可重复读</strong> <img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-33-2%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.jpg" alt="img" loading="lazy"> </p>
<p><strong>幻读</strong> <img src="/2022/04/22/MySQL/phantom_read.png" alt="img" loading="lazy"> </p>
<blockquote>
<p>解决幻读方法</p>
</blockquote>
<p>解决幻读方法有很多，但核心思想就是一个事物在操作这张表数据时，另外一个事物不允许新增或删除这张表的数据，解决幻读方式：<br>1.将事物隔离级别调整为SERIALIZABLE</p>
<p>2.在可重复读隔离级别下，给事物操作的这张表添加表锁</p>
<p>3.在可重复读隔离级别下，给事物操作的这张表添加Next-key Locks</p>
<blockquote>
<p>说明：Next-key Locks 相当于行锁+间歇锁</p>
</blockquote>
<h3 id="事务的常见分类"><a href="#事务的常见分类" class="headerlink" title="事务的常见分类"></a>事务的常见分类</h3><p>从事务理论角度：</p>
<ul>
<li>扁平事务（Flat Transactions） </li>
<li>带有保存点的扁平事务（Flat Transactions with Savepoints） </li>
<li>链事务（Chained Transactions） </li>
<li>嵌套事务（Nested Transactions） </li>
<li>分布式事务（Distributed Transactions）</li>
</ul>
<h3 id="MySQL事务日志"><a href="#MySQL事务日志" class="headerlink" title="MySQL事务日志"></a>MySQL事务日志</h3><p>事物有四种特性:原子性、隔离性、一致性、持久性</p>
<ul>
<li>事物的隔离性是由锁机制实现的</li>
<li>而事物的原子性、一致性和持久性由事物的redo日志和undo日志来保证<ul>
<li>REDO LOG成为重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久行</li>
<li>UNDO LOG日志称为回滚日志，回滚行记录到某个特定版本，用来保证原子性、一致性。</li>
</ul>
</li>
</ul>
<p>两种日志都可以视为恢复操作，但是：</p>
<ul>
<li>redo log：是存储引擎（innodb）生成的日志，记录的是<strong>物理级别</strong>的日志，比如页号xxx、偏移量yyy写入了zzz数据，主要为了保证数据的可靠性</li>
<li>undo log：是存储引擎（innodb）生成的日志记录的是逻辑操作日志，比如对某一行数据insert操作，那么undo log就记录一条与之相反delete操作。主要用于事务的回滚和一致性非锁定读（undo log回滚行记录到某种特定版本–MVCC，多版本并发控制）</li>
</ul>
<h4 id="1-redo日志"><a href="#1-redo日志" class="headerlink" title="1.redo日志"></a>1.redo日志</h4><p>InnoDB存储引擎是以<strong>页为单位</strong>来管理存储空间的，在真正访问页面之前，需要把<strong>磁盘上的</strong>页缓存到内存中的Buffer Pool之后才可以访问。所有的变更都必须<strong>先更新缓冲池中的数据</strong>，然后缓冲池中的脏页会以<strong>一定的频率</strong>被刷入磁盘（checkPoint机制），通过缓冲池来优化CPU和磁盘之间的鸿沟，这样来保证整体性能下降太快。</p>
<h5 id="1-1为什么需要redo-log"><a href="#1-1为什么需要redo-log" class="headerlink" title="1.1为什么需要redo log"></a>1.1为什么需要redo log</h5><p><strong>一方面，</strong>缓冲池的存在可以帮助我们消除CPU和磁盘间的鸿沟，checkpoint机制可以保证数据的最终落点，然而由于checkpoint并不是每次数据变更都触发，而是以一定频率去处理。所以最坏情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就会丢失。</p>
<p><strong>另一方面，</strong>事务包含持久性特性，就是说一个已提交的事务所作的修改应该是永久的，即使发生宕机所作的更改也不应该丢失。</p>
<hr>
<p>那么，应该如何保持这个持久性呢？<strong>一个简单的做法</strong>：在事务提交完成之前把该事务所作的修改的所有页面刷新到磁盘，但这个做法有些问题：</p>
<ul>
<li><p><strong>修改量与刷新磁盘工作量严重不成比例</strong></p>
<p>有时候我们仅仅修改了某个数据页的一个字节，但在InnoDB中是以页为单位来进行磁盘IO的，也就是说我们在提交事务时不得不将一整个数据页从内存中刷新到磁盘，而一个数据页有16KB大小，只修改一个字节就要刷新16KB数据到磁盘显得小题大做</p>
</li>
<li><p><strong>随机IO刷新较慢</strong></p>
<p>一个事务可以包含很多语句，即使一条语句也可能修改很多页面，如果事务修改的页面并不相邻，这意味着在将事务修改的Bufer Pool中的页面刷新到磁盘时，会有很多随机IO，而随机IO要比顺序IO慢很多</p>
</li>
</ul>
<p><strong>另一个解决思路</strong>：我们只是想让事务所作的修改对数据库数据永久生效，即使系统崩溃，在重启后也能恢复过来，所以没有必要再每次事务提交后，将事务所作的再内存中修改的数据页刷新到磁盘，而是<strong>只需要将所作的修改记录下来即可</strong>，比如某个事务将系统表空间中第10号页面中的偏移量为100的哪个字节的值1修改为2，我们秩只需记录一下：将第10号表空间的偏移量100的值修改为2即可。</p>
<p>InnooDB引擎的事务采用了WAL技术（Write-Ahead Loging），这种技术的思想先写日志，再写磁盘，只有日志写成功，才算事务提交成功，这里的日志就是redo log，当系统发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID的D，这就是redo log的作用。<img src="/2022/04/22/MySQL/1650873846555.png" alt="1650873846555" loading="lazy"></p>
<h5 id="1-2redo-log的好处、特点"><a href="#1-2redo-log的好处、特点" class="headerlink" title="1.2redo log的好处、特点"></a>1.2redo log的好处、特点</h5><p>1.好处</p>
<ul>
<li>redo日志降低了刷盘效率</li>
<li>redo日志占用的空间非常小</li>
</ul>
<p>存储表空间ID、也好、偏移量以及需要更新的值，所需的存储空间是很小的，刷盘块</p>
<p>2.特点</p>
<ul>
<li><p>redo日志是顺序写入磁盘的</p>
<p>在执行事务过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的</p>
</li>
<li><p>事务执行过程由redo log不断记录</p>
<p>redo log更bing log的区别redo log是存储引擎层产生的，而bing log是数据库层产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log里顺序记录，我、而bin log 不会记录，直到事务提交，才会一次写入到bin log文件中。</p>
</li>
</ul>
<h5 id="1-3redo的组成"><a href="#1-3redo的组成" class="headerlink" title="1.3redo的组成"></a>1.3redo的组成</h5><p>redo log可以分为以下两个部分：</p>
<ul>
<li><p>重做日志的缓冲（redo log buffer），保存在内存，易丢失</p>
<p>在服务器启动时向操作系统申请的一大片称之为redo log buffer的连续内存空间，翻译成中文是redo日志缓冲区。这片内存空间被划分为若干个连续的redo log block。一个redo log block占用512字节大小<img src="/2022/04/22/MySQL/1650875129562.png" alt="1650875129562" loading="lazy"></p>
<p>参数设置：innodb_log_buffer_size;</p>
<p>redo log buffer大小，默认16M，最大值4096M，最小值1M<img src="/2022/04/22/MySQL/1650875207176.png" alt="1650875207176" loading="lazy"></p>
</li>
<li><p>重做日志文件（redo log file），保存在硬盘中，持久的</p>
</li>
</ul>
<h5 id="1-4redo的整体流程"><a href="#1-4redo的整体流程" class="headerlink" title="1.4redo的整体流程"></a>1.4redo的整体流程</h5><p>以一个更新事务为例，redo log流传过程，如下图所示：<img src="/2022/04/22/MySQL/1650897393027.png" alt="1650897393027" loading="lazy"></p>
<ol>
<li>先将原始数据从磁盘读入到内存中，修改数据的内存拷贝</li>
<li>生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值</li>
<li>当事务commit时，将redo log buffer中的内容刷新到redo log file中，对redo log file采用追加写方式</li>
<li>定期将内存中修改的数据刷新到磁盘</li>
</ol>
<blockquote>
<p>Write-Ahead Log(预先日志持久化)，在持久化一个数据页之前，先将内存中相应的日志页持久化</p>
</blockquote>
<h5 id="1-5redo-log刷盘策略-redo-log-buffer-gt-redo-log-file"><a href="#1-5redo-log刷盘策略-redo-log-buffer-gt-redo-log-file" class="headerlink" title="1.5redo log刷盘策略(redo log buffer -&gt; redo log file)"></a>1.5redo log刷盘策略(redo log buffer -&gt; redo log file)</h5><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以一定频率刷入到真正的redo log file中。这里的<strong>频率就是要说的刷盘策略</strong><img src="/2022/04/22/MySQL/1650898012282.png" alt="1650898012282" loading="lazy"></p>
<p>理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘时机是根据策略进行的。</p>
<blockquote>
<p>每条redo记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘，只是刷入到文件系统缓存(page cache)中(现代系统为了提高文件写入效率做的一个优化)，真正的写入会交给系统自己决定(比如page cache足够大了)。对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了(虽然整个系统宕机的概率还是比较小)</span></span><br></pre></td></tr></table></figure>

<p>针对这种情况，InnoDB给出innodb_flush_log参数，该参数控制commit提交事务时，如何将redo log bufer中的日志刷新到redo log file中，它支持三种策略：</p>
<ul>
<li>设置0：表示每次事务提交时不进行刷盘操作(系统默认master thread每个1s进行一次重做日志的同步)</li>
<li>设置1：表示每次事务提交时都将进行同步，刷盘操作(默认值)</li>
<li>设置2：表示每次事务提交时都只把redo log buffer内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件</li>
</ul>
<p><img src="/2022/04/22/MySQL/1650900198762.png" alt="1650900198762" loading="lazy"></p>
<p>另外，InnoDB存储引擎由一个后台线程，每隔1s，就会把redo log buffer中的内容写入到文件系统缓存(page cache)，然后调用刷盘操作。<img src="/2022/04/22/MySQL/1650900288062.png" alt="1650900288062" loading="lazy"></p>
<p>也就是说，一个没有提交事务的redo log记录，也可能刷盘。因为在事务执行过程中redo log记录是会写入redo log buffer中的，这些redo log记录会被后台线程刷盘<img src="/2022/04/22/MySQL/1650900546538.png" alt="1650900546538" loading="lazy"></p>
<p>除了后台线程每秒1次的轮询操作，还有一种情况，当redo log buffer占用空间即将达到innodb_log_buffer_size（这个参数默认16M）的一半的时候，后台线程会主动刷盘</p>
<h5 id="1-6不同刷盘策略演示"><a href="#1-6不同刷盘策略演示" class="headerlink" title="1.6不同刷盘策略演示"></a>1.6不同刷盘策略演示</h5><p><strong>1.流程图</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Innodb_flush_log_at_trx_commit=1</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1650957070916.png" alt="1650957070916" loading="lazy"></p>
<blockquote>
<p>小结：Innodb_flush_log_at_trx_commit=1</p>
<p>为1时，只要事务提交成功，redo log记录就一定在硬盘里，不会有数据丢失。</p>
<p>如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但事务并没有提交，所以日志丢了也不会有损失，可以保证ACID的D，数据绝对不会丢失，但是效率最差。</p>
<p>建议使用默认值，虽然操作系统宕机概率理论小于数据库宕机概率，但一般既然使用了事务，那么数据的安全更重要些</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Innodb_flush_log_at_trx_commit=2</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1650957504388.png" alt="1650957504388" loading="lazy"></p>
<blockquote>
<p>小结：Innodb_flush_log_at_trx_commit=2</p>
<p>为2时，只要事务提交成功，redo log buffer中的内容只写入文件系统缓存(page cache)</p>
<p>如果仅仅只是MySQL挂了不会有数据丢失，但是操作系统宕机可能会有1秒数据的丢失，这种情况下无法满足ACID中的D，但是数值2效率更高</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Innodb_flush_log_at_trx_commit=0</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1650957883071.png" alt="1650957883071" loading="lazy"></p>
<blockquote>
<p>小结：Innodb_flush_log_at_trx_commit=0</p>
<p>为0时，master thread中每1秒进行一次重做日志的fsync操作，因此示例crash最多丢失1秒的事务（master thread负责将缓冲池中的数据异步刷新到磁盘，保证数据一致性）</p>
<p>数值0的话，是一种折中的做法，它的效率理论高于1，低于2的，这种策略也有丢失数据的风险，也无法保证D</p>
</blockquote>
<h5 id="1-7写入redo-log-buffer过程"><a href="#1-7写入redo-log-buffer过程" class="headerlink" title="1.7写入redo log buffer过程"></a>1.7写入redo log buffer过程</h5><h6 id="1-补充概念：Mini-Transaction"><a href="#1-补充概念：Mini-Transaction" class="headerlink" title="1.补充概念：Mini-Transaction"></a><strong>1.补充概念：Mini-Transaction</strong></h6><p>MySQL把对底层页面中的一次原子访问的过程成为一个Mini-Transaction，简称mtr，比如向某个索引对应的B+树中插入一条记录的过程就是一个Mini-Transaction。一个所谓的mtr可以包含一组redo日志，在进行崩溃恢复时这一组redo日志作为一个不可分割的整体</p>
<p>一个事务可以包含若干条语句，每一条语句其实可以包含若干个mtr，每一个mtr又可以包含若干条redo日志，如图：<img src="/2022/04/22/MySQL/1650959125776.png" alt="1650959125776" loading="lazy"></p>
<h6 id="2-redo日志写入log-buffer"><a href="#2-redo日志写入log-buffer" class="headerlink" title="2.redo日志写入log buffer"></a><strong>2.redo日志写入log buffer</strong></h6><p>向log buffer中写入redo日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。当我们想往log buffer中写入日志时，第一个遇到的问题时往哪个block中的哪个偏移量处，所以InnoDB的设计者特意提供了一个称之为buf_free的全局变量，该变量指明后续redo日志应该写入到log buffer中的哪个位置，如图：<img src="/2022/04/22/MySQL/1650959522543.png" alt="1650959522543" loading="lazy"></p>
<p>一个mtr执行过程中可能产生若干条redo日志，这些redo日志是一个不可分割的组，所以其实并不是每生成一条redo日志，就将其插入到log buffer中，而是每个mtr运行过程中产生的日志先暂时存到一个地方，当该mtr结束的时候，将过程中产生的一组redo日志再全部复制到log bufer。我们假设两个名为T1、T2的事务都包含2个mtr，我们给这几个mtr命名一下：</p>
<ul>
<li>事务T1的两个mtr分别称为mtr_T1_1和mtr_T1_2</li>
<li>事务T2的两个mtr分别称为mtr_T2_1和mtr_T2_2</li>
</ul>
<p>每个mtr都会产生一组redo日志，用示意图来描述一下这些mtr产生的日志情况<img src="/2022/04/22/MySQL/1650960042591.png" alt="1650960042591" loading="lazy"></p>
<p>不同的事物可能是并发执行的，所以T1、T2之间的mtr可能是交替执行。每当一个mtr执行完成，伴随着该mtr生成的一组redo日志就需要被复制到log buffer中，也就是说不同事务的mtr可能是交替写入log buffer的，如图：(将一个mtr中的所有redo日志当成一个整体来画)<img src="/2022/04/22/MySQL/1650960214857.png" alt="1650960214857" loading="lazy"></p>
<p>有的mtr产生的redo日志量非常大，比如mtr_t1_2产生的redo日志占用空间比较大，占用了3个block来存储</p>
<h6 id="3-redo-log-block的结构图"><a href="#3-redo-log-block的结构图" class="headerlink" title="3.redo log block的结构图"></a><strong>3.redo log block的结构图</strong></h6><p>一个redo log block是由日志头、日志体、日志尾组成。日志头占用12字节，日志尾占用8字节，所以一个block真正能存储的数据就是512-12-8=492字节。</p>
<blockquote>
<p>为什么一个block是512字节？</p>
<p>和磁盘的扇区有关，机械硬盘默认扇区就是512字节，如果要写入的数据大于512字节，那么要写入的扇区肯定不止一个，这是就涉及到盘片的转动，找到下一个扇区，假设现在需要写入两个扇区A和B，如果扇区A写入成功，但扇区B失败，那么会出现非原子性的写入 ，而如果每次只写入和扇区大小一样二点512字节，那么每次的写入都是原子性的</p>
</blockquote>
<h5 id="1-8redo-log-file"><a href="#1-8redo-log-file" class="headerlink" title="1.8redo log file"></a>1.8redo log file</h5><p>1.相关参数设置</p>
<ul>
<li>innodb_log_group_home_dir:指定redo log文件组所在的路径，默认值为./，表示在数据库的数据目录下，MySQL的默认数据目录(var/lib/mysql)下默认有两个名为ib_logfile0和ib_logfile1的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中，此redo日志文件的位置可以修改。</li>
<li>innodb_log_files_in_group:指名redo log file的个数，命名方式如：ib_logfile0,iblogfile1…iblogfilen。默认2个，最大100个。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show variables like &#x27;innodb_log_files_in_group&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1651153649950.png" alt="1651153649950" loading="lazy"></p>
<ul>
<li>innodb_flush_log_at_trx_commit:控制redo log刷新到磁盘的策略，默认为1</li>
<li>innodb_log_file_size:单个redo log文件设置大小，默认值48M，最大值512G.最大值指的是redo log系列文件之和，(即innodb_log_files_group*innodb_log_file_size不能大于512G)<img src="/2022/04/22/MySQL/1651153842808.png" alt="1651153842808" loading="lazy"></li>
</ul>
<p>根据业务修改其大小，以便容纳较大的事务。编辑my.cnf文件并重启数据库生效，如下图所示：</p>
<p><img src="/2022/04/22/MySQL/1651153977055.png" alt="1651153977055" loading="lazy"></p>
<blockquote>
<p>在数据库实例更新比较频繁的情况下，可以适当加大redo log组数和大小。但也不推荐redo log设置过大，在mysql崩溃恢复时会重新执行redo日志中的记录</p>
</blockquote>
<p>2.日志文件组<img src="/2022/04/22/MySQL/1651154063137.png" alt="1651154063137" loading="lazy"></p>
<p>总共的redo日志文件大小其实就是： innodb_log_file_size × innodb_log_files_in_group 。 </p>
<p>采用循环使用的方式向redo日志文件组里写数据的话，会导致后写入的redo日志覆盖掉前边写的redo日志？当然！所以InnoDB的设计者提出了checkpoint的概念。 </p>
<p>3.checkpoint</p>
<p>在整个日志文件组有两个重要属性：</p>
<p>write pos：当前记录的位置，一边写一边后移</p>
<p>checkpoint：当前要擦除的位置，也是往后移</p>
<p>每次刷盘redo log记录到日志文件组中，write pos位置就会后移更新。每次mysql加载日志文件组恢复数据时，会清空加载过的redo log记录，并把checkpoint后移更新。write pos和checkpoint之间空着的部分可以用来写入新的redo log记录</p>
<p><img src="/2022/04/22/MySQL/1651154092511.png" alt="1651154092511" loading="lazy"></p>
<p>如果 write pos 追上 checkpoint ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 redo log记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。</p>
<p><img src="/2022/04/22/MySQL/1651154127091.png" alt="1651154127091" loading="lazy"></p>
<h5 id="1-9redo-log小结"><a href="#1-9redo-log小结" class="headerlink" title="1.9redo log小结"></a>1.9redo log小结</h5><p>InnoDB的更新操作采用的是Write Ahead Log(<strong>预先日志持久化</strong>)策略，即先写日志，再写入磁盘<img src="/2022/04/22/MySQL/1651155157883.png" alt="1651155157883" loading="lazy"></p>
<h4 id="Undo日志"><a href="#Undo日志" class="headerlink" title="Undo日志"></a>Undo日志</h4><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中 更新数据 的 前置操作 其实是要先写入一个 undo log 。 </p>
<h5 id="1-如何理解Undo日志"><a href="#1-如何理解Undo日志" class="headerlink" title="1.如何理解Undo日志"></a>1.如何理解Undo日志</h5><p>事务需要保证原子性；也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p>
<ul>
<li>事务执行过程中可能遇到各种错误，比如服务器本身错误、操作系统错误，甚至断电导致的错误</li>
<li>程序员在事务执行期间手动输入ROLLBACK语句结束当前事务</li>
</ul>
<p>以上情况出现，就需要把数据改回原来的样子，这个过程称之为回滚，这样就造成一个假象：这个事务看起来什么都没做，所以符合原子性要求。</p>
<p>每当对一条记录进行改动时，（这里的改动是指insert、delete、update），都需要”留一手“–把回滚时所需的东西记录下来。比如：<img src="/2022/04/22/MySQL/1651157169184.png" alt="1651157169184" loading="lazy"></p>
<p>MySQL把这些为了回滚而记录的这些内容称之为撤销日志或者回滚日志，查询操作并不会修改任何记录，所以在查询操作时，并不需要相应的undo日志。</p>
<p>此外，undo log会产生redo log，也就是undo log的产生伴随着redo log的产生，这是因为undo log也需要持久性保护</p>
<h5 id="2-Undo日志的作用"><a href="#2-Undo日志的作用" class="headerlink" title="2.Undo日志的作用"></a>2.Undo日志的作用</h5><p>作用1：回滚数据<img src="/2022/04/22/MySQL/1651157557490.png" alt="1651157557490" loading="lazy"></p>
<p>作用2：MVCC<img src="/2022/04/22/MySQL/1651157569892.png" alt="1651157569892" loading="lazy"></p>
<h5 id="3-undo的存储结构"><a href="#3-undo的存储结构" class="headerlink" title="3.undo的存储结构"></a>3.undo的存储结构</h5><p>3.1回滚段与undo页</p>
<p>InnoDB对undo log的管理采用段的方式，也就是 回滚段（rollback segment） 。每个回滚段记录了1024 个 undo log segment ，而在每个undo log segment段中进行 undo页 的申请。 </p>
<ul>
<li>在 InnoDB1.1版本之前 （不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为 1024 。虽然对绝大多数的应用来说都已经够用。 </li>
<li>从1.1版本开始InnoDB支持最大 128个rollback segment ，故其支持同时在线的事务限制提高到了 128*1024 。</li>
</ul>
<p><img src="/2022/04/22/MySQL/1651157708035.png" alt="1651157708035" loading="lazy"></p>
<p><img src="/2022/04/22/MySQL/1651217991131.png" alt="1651217991131" loading="lazy"></p>
<p><img src="/2022/04/22/MySQL/1651218067477.png" alt="1651218067477" loading="lazy"></p>
<p>3.2回滚段与事务</p>
<p>​    1.每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。 </p>
<ol start="2">
<li>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数 </li>
</ol>
<p>据会被复制到回滚段。 </p>
<ol start="3">
<li><p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘 区或者在回滚段允许的情况下扩展新的盘区来使用。 </p>
</li>
<li><p>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。 </p>
</li>
<li><p>当事务提交时，InnoDB存储引擎会做以下两件事情： </p>
</li>
</ol>
<ul>
<li>将undo log放入列表中，以供之后的purge操作 </li>
<li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用 </li>
</ul>
<p>3.3回滚段中的数据分类</p>
<ol>
<li><p>未提交的回滚数据(uncommitted undo information) </p>
</li>
<li><p>已经提交但未过期的回滚数据(committed undo information) </p>
</li>
<li><p>事务已经提交并过期的数据(expired undo information) </p>
</li>
</ol>
<h5 id="4undo的类型"><a href="#4undo的类型" class="headerlink" title="4undo的类型"></a>4undo的类型</h5><p>在InnoDB存储引擎中，undo log分为： </p>
<ul>
<li>insert undo log </li>
<li>update undo log </li>
</ul>
<h5 id="5-undo-log的声明周期"><a href="#5-undo-log的声明周期" class="headerlink" title="5.undo log的声明周期"></a>5.undo log的声明周期</h5><p>5.1简要生成过程</p>
<p>只有Buffer Pool的流程：<img src="/2022/04/22/MySQL/1651157886841.png" alt="1651157886841" loading="lazy"></p>
<p>有了Redo log和Undo log之后：<img src="/2022/04/22/MySQL/1651157909096.png" alt="1651157909096" loading="lazy"></p>
<p>5.2详细生成过程<img src="/2022/04/22/MySQL/1651157929374.png" alt="1651157929374" loading="lazy"></p>
<p>当我们执行insert时：</p>
<blockquote>
<p>begin; </p>
<p>INSERT INTO user (name) VALUES (“tom”);</p>
</blockquote>
<p><img src="/2022/04/22/MySQL/1651157994414.png" alt="1651157994414" loading="lazy"></p>
<p>当执行update时：<img src="/2022/04/22/MySQL/1651158015821.png" alt="1651158015821" loading="lazy"></p>
<blockquote>
<p>UPDATE user SET id=2 WHERE id=1;</p>
</blockquote>
<p><img src="/2022/04/22/MySQL/1651158032322.png" alt="1651158032322" loading="lazy"></p>
<p>5.3undo log如何回滚</p>
<p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样： </p>
<ol>
<li><p>通过undo no=3的日志把id=2的数据删除 </p>
</li>
<li><p>通过undo no=2的日志把id=1的数据的deletemark还原成0 </p>
</li>
<li><p>通过undo no=1的日志把id=1的数据的name还原成Tom </p>
</li>
<li><p>通过undo no=0的日志把id=1的数据删除</p>
</li>
</ol>
<p>5.4undo log的删除</p>
<ul>
<li>针对于insert undo log </li>
</ul>
<p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。 </p>
<ul>
<li>针对于update undo log </li>
</ul>
<p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。 </p>
<h5 id="6小结"><a href="#6小结" class="headerlink" title="6小结"></a>6小结</h5><p><img src="/2022/04/22/MySQL/1651158117353.png" alt="1651158117353" loading="lazy"></p>
<p>undo log是逻辑日志，对事物回滚时，只是将数据库逻辑地恢复到原来的样子</p>
<p>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程</p>
<h3 id="其他数据库日志"><a href="#其他数据库日志" class="headerlink" title="其他数据库日志"></a>其他数据库日志</h3><p>MySQL官网日志地址：“<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/server-logs.html%E2%80%9D">https://dev.mysql.com/doc/refman/8.0/en/server-logs.html”</a></p>
<h4 id="1-MySQL支持的日志"><a href="#1-MySQL支持的日志" class="headerlink" title="1.MySQL支持的日志"></a>1.MySQL支持的日志</h4><h5 id="1-1日志类型"><a href="#1-1日志类型" class="headerlink" title="1.1日志类型"></a>1.1日志类型</h5><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为<strong>二进制日志</strong>、<strong>错误日志</strong>、<strong>通用查询日志和慢查询日志，这也是常用的4种。MySQL8又新增了：</strong>中继日志和数据定义语句日志**。使用这些日志文件可以查看MySQL内部发生的事情。</p>
<p>这6类日志分别为：</p>
<ul>
<li>慢查询日志：记录所有执行时间超过long_query_time的所有查询，方便对查询优化</li>
<li>通用查询日志：记录所有连接的起始时间和终止时间，以及连接发送给服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大帮助</li>
<li>错误日志：记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护</li>
<li>二进制日志：记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复</li>
<li>中继日志：用于主从服务器架构中，从服务器用来存放主服务器二进制内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。</li>
<li>数据定义语句日志：记录数据定义语句执行的元数据操作</li>
</ul>
<p>除二进制日志外，其他日志都是<strong>文本文件</strong>。默认情况，所有日志文件创建于<strong>MySQL数据目录</strong>中</p>
<h5 id="1-2日志的弊端"><a href="#1-2日志的弊端" class="headerlink" title="1.2日志的弊端"></a>1.2日志的弊端</h5><ul>
<li>日志功能会<strong>降低MySQL数据库的性能</strong>。例如，在查询非常频繁的MySQL数据库系统中，如果开启了通用日志和慢查询日志，MySQL数据库会花费很多时间记录日志</li>
<li>日志会占用大量的磁盘空间。对于用户量非常大、操作非常频繁的数据库，日志文件需要的存储空间设置比数据库文件需要的存储空间还要大</li>
</ul>
<h4 id="2-通用查询日志-general-query-log"><a href="#2-通用查询日志-general-query-log" class="headerlink" title="2.通用查询日志(general query log)"></a>2.通用查询日志(general query log)</h4><p>通用查询日志用来<strong>记录用户的所有操作</strong>，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给MySQL数据库服务器的所有SQL指令等。当我们的数据发生异常时，<strong>开启通用查询日志，还原操作时的具体场景</strong>，可以帮助我们准确定位问题。</p>
<h5 id="2-1问题场景"><a href="#2-1问题场景" class="headerlink" title="2.1问题场景"></a>2.1问题场景<img src="/2022/04/22/MySQL/1652081406202.png" alt="1652081406202" loading="lazy"></h5><h5 id="2-2查看当前状态"><a href="#2-2查看当前状态" class="headerlink" title="2.2查看当前状态"></a>2.2查看当前状态<img src="/2022/04/22/MySQL/1652081470079.png" alt="1652081470079" loading="lazy"></h5><p>说明1：系统变量general_log的值是OFF，即通用查询日志处于关闭状态。在MySQL中，这个参数的<strong>默认值是关闭的</strong>。因为一旦开启记录通用查询日志，MySQL会记录所有的连接起止和相关的sql操作，这样会消耗系统资源并且占用磁盘空间，可以手动修改变量的值，在<strong>需要的时候开启日志。</strong></p>
<p>说明2：通用查询日志文件的名称是atguigu01.log。存储路径是var/lib/mysql/，默认也是数据路径，这样我们知道在哪里可以查看通用查询日志的内容。</p>
<h5 id="2-3启动日志"><a href="#2-3启动日志" class="headerlink" title="2.3启动日志"></a>2.3启动日志</h5><p><strong>方式1：永久性方式</strong></p>
<p>修改my.cnf或者my.ini配置文件来设置。在mysql组下加入log选项，并重启MySQL服务。格式如下</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">general_log</span>=<span class="literal">ON</span></span><br><span class="line"><span class="attr">general_log_file</span>=[path[filename]] <span class="comment">#日志文件所在目录路径,filename为日志文件名</span></span><br></pre></td></tr></table></figure>

<p>如果不指定目录和文件名，通用查询日志默认存储在MySQL数据目录中的hostname.log文件中，hostname表示主机名。</p>
<p><strong>方式2：临时性方式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL general_log=on;  #开启通用查询日志</span><br><span class="line">SET GLOBAL general_log_file=&#x27;path/filename&#x27;;  #设置日志文件位置</span><br></pre></td></tr></table></figure>

<p>对应的，关闭操作SQL命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL general_log=off;  #关闭通用查询日志</span><br></pre></td></tr></table></figure>

<p>查看设置后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;general_log%&#x27;;</span><br></pre></td></tr></table></figure>

<h5 id="2-4查看日志"><a href="#2-4查看日志" class="headerlink" title="2.4查看日志"></a>2.4查看日志</h5><p>通用查询日志是以文本文件的形式存储在文件系统中的，可以使用文本编辑器直接打开日志文件。每台MySQL服务器的通用查询日志内容是不同的。</p>
<ul>
<li>在windows操作系统中，使用文本文件查看器</li>
<li>在Linux系统中，可以使用vi工具或者gedit工具查看</li>
<li>在Mac osx系统中，可以使用文本文件查看器或者vi等工具查看</li>
</ul>
<p>从**SHOW VARIABLES LIKE ‘general_log%’;**结果中可以看到通用查询日志的设置</p>
<p>通过通用查询日志，可以了解用户对MySQL进行的操作。比如MySQL启动信息和用户root连接服务器和执行查询表的记录。<img src="/2022/04/22/MySQL/1652082843720.png" alt="1652082843720" loading="lazy"></p>
<p>通用查询日志里面，我们可以清除的看到，什么时候开启了新的客户端登录数据库，登录之后做了什么，针对的是哪个数据表等信息。</p>
<h5 id="2-5停止日志"><a href="#2-5停止日志" class="headerlink" title="2.5停止日志"></a>2.5停止日志</h5><p><strong>方式一：永久性方式</strong></p>
<p>修改my.cnf或者my.ini文件，把[mysqld]组下的general_log值设置为OFF或者把general_log一项注释掉。</p>
<p>举例1：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">general_log</span>=<span class="literal">OFF</span></span><br></pre></td></tr></table></figure>

<p>举例2：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment">#general_log=ON</span></span><br></pre></td></tr></table></figure>

<p><strong>方式2：临时性方式</strong></p>
<p>使用SET命令停止MySQL通用查询日志功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL general_log=off;</span><br></pre></td></tr></table></figure>

<p>查看通用日志功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;general_log%&#x27;;</span><br></pre></td></tr></table></figure>

<h5 id="2-6删除-刷新日志"><a href="#2-6删除-刷新日志" class="headerlink" title="2.6删除/刷新日志"></a>2.6删除/刷新日志</h5><p>如果数据的使用非常频繁，那么通用查询日志会占用服务器非常大的磁盘空间。数据管理员可以删除很长时间之前的查询日志，以保证MySQL服务器上的硬盘空间。</p>
<p><strong>手动删除文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLE LIKE &#x27;general_log%&#x27;;</span><br></pre></td></tr></table></figure>

<p>可以看出，通用查询日志的目录默认为MySQL数据目录。在该目录下手动删除通用查询日志atguigu01.log。</p>
<p>使用如下命令重新生成查询日志文件，具体命令如下。刷新MySQLS数据目录，发现创建了新的日志文件。前提一定要开启通用日志。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot -p flush-logs</span><br></pre></td></tr></table></figure>

<p>如果希望备份旧的通用查询日志，就必须先将旧的日志文件复制出来或者改名，然后执行上面的命令。正确流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd mysqld-data-directory  #输入自己的通用日志文件所在目录</span><br><span class="line">mv mysql.general.log mysql.general.log.old  #指名旧的文件名以及新的文件名</span><br><span class="line">mysqladmin -uroot -p flush-logs  </span><br></pre></td></tr></table></figure>

<h4 id="3-错误日志（error-log）"><a href="#3-错误日志（error-log）" class="headerlink" title="3.错误日志（error log）"></a>3.错误日志（error log）</h4><p>错误日志记录了MySQL<strong>服务器启动、停止运行时间，以及系统启动、运行和停止过程中的诊断信息，包括错误、警告和提示</strong>等。</p>
<p>通过错误日志可以查看系统的运行状态，便于及时发现故障、修复故障。如果MySQL服务出现异常，错误日志是发现问题、解决故障的首选。</p>
<h5 id="3-1启动日志"><a href="#3-1启动日志" class="headerlink" title="3.1启动日志"></a>3.1启动日志</h5><p>在MySQL数据库中，错误日志功能是默认开启的。而且，错误日志<strong>无法被禁止</strong>。默认情况下，错误日志存储在MySQL数据库的数据文件夹下，名称默认mysqld.log（Linux系统）或者hostname.err（max系统）。如果需要绑定文件名，则需要在my.ini或者my.cnf中做如下配置：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">log-error</span>=[path/[filename]]  <span class="comment">#path为日志文件所在的目录路径，filename为日志文件名</span></span><br></pre></td></tr></table></figure>

<p>修改配置项后，需要重启MySQL服务以生效</p>
<h5 id="3-2查看日志"><a href="#3-2查看日志" class="headerlink" title="3.2查看日志"></a>3.2查看日志</h5><p>MySQL错误日志是以文本文件形式存储的，可以使用文本编辑器直接查看。</p>
<p>查询错误日志的存储路径：<img src="/2022/04/22/MySQL/1652086149005.png" alt="1652086149005" loading="lazy"></p>
<p>执行结果中可以看到错误日志文件是mysqld.log，在默认的数据目录下。</p>
<p>下面我们查看一下错误日志的内容<img src="/2022/04/22/MySQL/1652086201026.png" alt="1652086201026" loading="lazy"></p>
<p>可以看到，错误日志文件中记录了服务器启动的时间，以及存储引擎InnoDB启动和停止时间等，我们在做初始化时生成的数据库初始密码也是记录在error.log</p>
<h5 id="3-3删除-刷新日志"><a href="#3-3删除-刷新日志" class="headerlink" title="3.3删除/刷新日志"></a>3.3删除/刷新日志</h5><p>对于很久以前的错误日志，数据库管理员查看这些错误日志的可能性不大，可以将这些错误日志删除，以保证MySQL服务器上的<strong>硬盘空间</strong>。MySQL的错误日志是以文本文件的形式存储在文件系统中的，可以直接删除。</p>
<ul>
<li><p>第一步（方式一）：删除操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f /var/lib/mysql/mysqld.log</span><br></pre></td></tr></table></figure>

<p>在运行状态下删除错误日志文件后，MySQL并不会自动创建日志文件</p>
</li>
<li><p>第一步（方式二）：重命名文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /var/log/mysqld.log /var/log/mysqld.log.old</span><br></pre></td></tr></table></figure></li>
<li><p>第二步：重建日志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot -p flush-logs</span><br></pre></td></tr></table></figure>

<p>可能会报错：<img src="/2022/04/22/MySQL/1652086806953.png" alt="1652086806953" loading="lazy"></p>
<p>官网提示：<img src="/2022/04/22/MySQL/1652086850681.png" alt="1652086850681" loading="lazy"></p>
<p>补充操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install -omysql -gmysql -m0644 /dev/null /var/log/mysqld.log</span><br></pre></td></tr></table></figure>

<p>flush-logs指令操作：</p>
<ul>
<li>MySQL5.5.7以前的版本，flush-logs将错误日志文件重命名为filename.err_old，并创建新的日志文件</li>
<li>从MySQL5.5.7开始，flush-log只是重新打开日志文件，并不做日志备份和创建的操作</li>
<li>如果日志文件不存在，MySQL启动或执行flush-logs时会自动创建新的日志文件。重新创建错误日志，大小为0字节。</li>
</ul>
</li>
</ul>
<h5 id="3-4MySQL8-0新特性"><a href="#3-4MySQL8-0新特性" class="headerlink" title="3.4MySQL8.0新特性"></a>3.4MySQL8.0新特性</h5><p>MySQL8.0里对错误日志的改进。MySQL8.0的错误日志可以理解为一个全新的日志，在这个版本里，接受了来自社区的广泛批评意见，在这些意见和建议的基础上生成了新的日志。<img src="/2022/04/22/MySQL/1652087407447.png" alt="1652087407447" loading="lazy"></p>
<blockquote>
<p>小结：通常情况下，管理员不需要查看错误。但是，MySQL服务器发生异常时，管理员可以从错误日志中找到发生异常的时间、原因，然后根据这些信息来解决异常</p>
</blockquote>
<h4 id="4-二进制日志（bin-log）"><a href="#4-二进制日志（bin-log）" class="headerlink" title="4.二进制日志（bin log）"></a>4.二进制日志（bin log）</h4><p>binlog可以说是MySQL比较重要的日志，在日常开发及运维中，都会遇到。</p>
<p>binlog即binary log，二进制日志文件，也叫做变更日志（update log）。它记录了数据库所有执行的DDL和DML等数据库更新事件的语句但是不包含没有修改任何数据的语句（如数据查询语句slect、show等）</p>
<p>它以<strong>事件形式</strong>记录并保存在<strong>二进制文件</strong>中。通过这些信息，可以再现数据更新操作的全过程。</p>
<blockquote>
<p>如果想要记录所有语句（例如，为了识别有问题的查询），需要使用通用查询日志</p>
</blockquote>
<p>binlog主要应用场景：</p>
<ul>
<li>一是用于<strong>数据恢复</strong>，如果MySQL数据库意外停止，可以通过二进制文件来查看用户执行了哪些操作，对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器</li>
<li>而是用于<strong>数据复制</strong>，由于日志的延续性和时效性，master把它的二进制日志传递给slaves来达到master-slaves数据一致的目的</li>
</ul>
<p>可以说Mysql数据库的<strong>数据备份、主备、主主、主从</strong>都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。</p>
<p><img src="/2022/04/22/MySQL/1652169004023.png" alt="1652169004023" loading="lazy"></p>
<h5 id="4-1查看默认情况"><a href="#4-1查看默认情况" class="headerlink" title="4.1查看默认情况"></a>4.1查看默认情况</h5><p>查看记录二进制日志是否开启：在MySQL8中默认情况下，二进制文件时开启的<img src="/2022/04/22/MySQL/1652169192227.png" alt="1652169192227" loading="lazy"></p>
<p><strong>log_bin_basename</strong>:是binlog日志的基本文件名，后面会追加标识来表示每一个文件</p>
<p><strong>log_bin_index</strong>:是binlog文件的索引文件，这个文件管理了所有的binlog文件的目录</p>
<p><strong>log_bin_trust_function_creators</strong>:限制存储过程，这是因为二进制日志的一个重要功能是用于主从复制，而存储函数有可能导致主从的数据不一致。所以当开启二进制日志后，需要限制存储函数的创建、修改、调用</p>
<p><strong>log_bin_use_v1_row_events</strong>:此只读变量已有弃用。ON表示使用版本1二进制日志行，OFF表示使用版本2二进制日志行(MySQL5.6的默认值为2)</p>
<h5 id="4-2日志参数设置"><a href="#4-2日志参数设置" class="headerlink" title="4.2日志参数设置"></a>4.2日志参数设置</h5><p><strong>方式一：永久性方式</strong></p>
<p>修改MySQL的my.cnf或my.ini文件可以设置二进制日志的相关参数：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment">#启用二进制日志</span></span><br><span class="line"><span class="attr">log-bin</span>=atguigu-bin</span><br><span class="line"><span class="attr">binlog_expire_logs_seconds</span>=<span class="number">600</span></span><br><span class="line"><span class="attr">max_binlog_size</span>=<span class="number">100</span>m</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：</p>
<ul>
<li>log-bin=mysql-bin #打开日志(主机需要打开)，这个mysql-bin也可以自定义，这里也可以加上路径，如：/home/www/mysql_bin_log/mysql-bin</li>
<li>binlog_expire_logs_seconds:此参数控制二进制日志文件保留的时长，单位是秒，默认2592000 30天–14400 4小时；86400 1天；259200 3天</li>
<li>max_binlog_size:控制单个二进制日志大小，当前日志文件大小超过此变量时，执行切换动作。此参数的<strong>最大和默认值是1GB</strong>，该设置<strong>并不能严格控制Binlog的大小</strong>，尤其是Binlog接近最大值而又遇到一个比较大的事务时，为了保证事务的完整性，可能不做切换日志的动作，只能将该事务的所有SQL都记录进当前日志，知道事务结束。一般情况下可采取默认值</li>
</ul>
</blockquote>
<p>重新启动MySQL服务，查询二进制日志的信息，执行结果：<img src="/2022/04/22/MySQL/1652170474789.png" alt="1652170474789" loading="lazy"></p>
<p><strong>设置带文件夹的bin-log日志存放记录</strong></p>
<p>如果想改变日志文件的目录和名称，可以对my.cnf或my.ini中的log_bin参数修改如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">log-bin</span>=<span class="string">&quot;/var/lib/mysqld/binlog/atguigu-bin&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意：新建的文件夹需要使用mysql用户，使用下面命令即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R -v mysql:mysql binlog </span><br></pre></td></tr></table></figure>

<p>重启MySQL服务器后，新的二进制日志文件将出现在/var/lib/mysql/binlog/文件夹下面<img src="/2022/04/22/MySQL/1652170745354.png" alt="1652170745354" loading="lazy"></p>
<blockquote>
<p>提示</p>
<p><strong>数据库文件最好不要与日志文件放在同一磁盘上</strong>这样，当数据库文件所在磁盘发生故障时，可以使用日志文件恢复数据</p>
</blockquote>
<p><strong>方式二：临时性方式</strong></p>
<p>如果不希望通过修改文件并重启的方式设置二进制日志的话，还可以使用如下命令，需要注意的是在mysql8中只有会话级别的设置，没有了global级别的设置<img src="/2022/04/22/MySQL/1652173036069.png" alt="1652173036069" loading="lazy"></p>
<h5 id="4-3查看日志"><a href="#4-3查看日志" class="headerlink" title="4.3查看日志"></a>4.3查看日志</h5><p>当MySQL创建二进制日志文件时，先创建一个以“filename”为名称，以“.index”为后缀的文件，在创建一个以“filename”为名称、以“.000001”为后缀的文件。</p>
<p>MySQL服务重启一次，以“.000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的个数与MySQL服务启动的次数相同。如果日志长度超过了max_binlog_size的上限(默认值1GB)，就会创建一个新的日志文件。</p>
<p>查看当前的二进制日志文件列表及大小。指令如下：<img src="/2022/04/22/MySQL/1652173276644.png" alt="1652173276644" loading="lazy"></p>
<p>所有对数据库的修改都会记录在binlog中。但binlog是二进制文件，无法直接查看，想要更直观的观测就要借助mysqlbinlog命令工具。指令如下，再查看执行，先执行一条sql语句，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update student set name=&#x27;张三_back&#x27; where id=1;</span><br></pre></td></tr></table></figure>

<p>开始查看binlog<img src="/2022/04/22/MySQL/1652173558534.png" alt="1652173558534" loading="lazy"></p>
<p><img src="/2022/04/22/MySQL/1652173592799.png" alt="1652173592799" loading="lazy"></p>
<p>执行结果可以看到，这是一个简单的日志文件，日志中记录了用户的一些操作，这里并没有出现具体的SQL语句，这是因为binlog关键字后面的内容是经过编码后的二进制日志。<img src="/2022/04/22/MySQL/1652173669364.png" alt="1652173669364" loading="lazy"></p>
<p><img src="/2022/04/22/MySQL/1652173708240.png" alt="1652173708240" loading="lazy"></p>
<p><img src="/2022/04/22/MySQL/1652173731122.png" alt="1652173731122" loading="lazy"></p>
<p>前面的命令同时显示binlog格式的语句，使用如下命令不显示它<img src="/2022/04/22/MySQL/1652173783442.png" alt="1652173783442" loading="lazy"></p>
<p><img src="/2022/04/22/MySQL/1652173794633.png" alt="1652173794633" loading="lazy"></p>
<p>关于mysqlbinlog工具的使用技巧还有很多，<img src="/2022/04/22/MySQL/1652173831831.png" alt="1652173831831" loading="lazy"></p>
<p>上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息。下面是方便查询的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binlog events [IN &#x27;log_name&#x27;] [FROM pos] [LIMIT [offset,] row_count];</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652173949806.png" alt="1652173949806" loading="lazy"></p>
<p><img src="/2022/04/22/MySQL/1652174650001.png" alt="1652174650001" loading="lazy"></p>
<p>一个update语句包含如下事件：</p>
<ul>
<li>Query事件负责开始一个事务（BEGIN）</li>
<li>Table_map事件 负责映射需要的表</li>
<li>Update_rows事件 负责写入数据</li>
<li>Xid事件 负责结束事务</li>
</ul>
<p>上面讲的都使基于binlog的默认格式，binlog格式查看</p>
<p><img src="/2022/04/22/MySQL/1652174882766.png" alt="1652174882766" loading="lazy"></p>
<p>除此之外，binlog还有2种格式，分别是srarement和Mixed</p>
<ul>
<li><p>Statement</p>
<p>每一条会修改数据的sql都会记录在binlog中，优点：不需要记录每一行的变化，减少binlog日志量，节约了IO，提高性能</p>
</li>
<li><p>Row</p>
<p><img src="/2022/04/22/MySQL/1652174991719.png" alt="1652174991719" loading="lazy"></p>
</li>
<li><p>Mixed</p>
<p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement和Row的结合</p>
</li>
</ul>
<h5 id="4-4使用日志恢复数据"><a href="#4-4使用日志恢复数据" class="headerlink" title="4.4使用日志恢复数据"></a>4.4使用日志恢复数据</h5><p>如果MySQL服务器启用了二进制日志，在数据库出现意外丢失数据时，可以使用MySQLbinlog工具从指定时间点开始（例如，最后一次备份）直到现在，或另一个指定的时间点的日志中恢复数据。</p>
<p>mysqlbinlog恢复数据的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog 【option】 filename|mysql -uuser -ppass</span><br></pre></td></tr></table></figure>

<p>这个命令可以这样理解：使用mysqlbinlog命令来读取filename中的内容，然后使用mysql命令将这些内容恢复到数据库</p>
<ul>
<li>filename：是日志文件名</li>
<li>option：可选项，比较重要的两对option参数是–start-date、–stop-date和–start-position、–stop-position。<ul>
<li>–start-date和-stop-date：可以指定恢复数据库的起始时间点和结束时间点</li>
<li>–start-position和–stop-position：可以指定恢复数据的开始位置和结束位置</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如atguigu-bin.000001必须在atguigu-bin.000002之前</p>
</blockquote>
<h5 id="4-5删除二进制日志"><a href="#4-5删除二进制日志" class="headerlink" title="4.5删除二进制日志"></a>4.5删除二进制日志</h5><p>MySQL的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制文件的方法。PURGE MASTER LOGS只能删除指定部分的二进制日志文件，REST MASTER删除所有的二进制日志文件。具体如下：</p>
<p><strong>1.PURGE MASTER LOGS：删除指定日志文件</strong></p>
<p>PURGE MASTER LOGS语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PURGE &#123;MASTER | BINARY&#125; LOGS TO &#x27;指定日志文件名&#x27;</span><br><span class="line">PURGE &#123;MASTER | BINARY&#125; LOGS BEFORE &#x27;指定日期&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>举例</strong>：使用PURGE MASTER LOGS语句删除创建时间比binlog.000005早的所有日志</p>
<p>（1）多次重新启动MySQL服务，便于生成多个日志文件。然后用SHOW语句显示二进制日志文件列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW BINARY LOGS</span><br></pre></td></tr></table></figure>

<p>（2）执行PURGE BINARY LOGS语句删除创建时间比binlog.000005早的所有日志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PURGE BINARY LOGS TO &quot;binlog.000005&quot;;</span><br></pre></td></tr></table></figure>

<p>(3) 显示二进制日志文件列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW BINARY LOGS</span><br></pre></td></tr></table></figure>

<p>比binlog.000005早的所有日志文件多已经被删除了。</p>
<p><strong>举例：</strong>使用PURGE MASTER LOGS语句删除2020年10月25日前创建的所有日志文件。</p>
<p>（1）显示二进制日志文件列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW BINARY LOGS</span><br></pre></td></tr></table></figure>

<p>（2）执行mysqlbinlog命令查看二进制日志文件binlog.000005的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog --no-defaults &quot;/var/lib/mysql/binlog/atguigu.000005&quot;</span><br></pre></td></tr></table></figure>

<p>（3）使用PURGE MASTER LOGS语句删除2022.01.05前创建的日志文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PURGE MASTER LOGS brfore &quot;20220105&quot;;</span><br></pre></td></tr></table></figure>

<p>（4）显示二进制日志文件列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW BINARY LOGS;</span><br></pre></td></tr></table></figure>

<p>20220105前的都被删除，最后一个没有删除，因为当前再用，还未记录最后的时间，所以没有删除</p>
<p><strong>2.RESET MASTER:删除所有二进制日志文件</strong></p>
<p>使用RESET MASTER语句删除所有的binlog日志。MySQL会重新创建二进制文件，新的日志文件扩展名将重新从000001开始编号。<strong>慎用！</strong></p>
<p><strong>举例：</strong>使用RESET MASTER语句删除所有日志文件</p>
<p>（1）重启MySQL服务器若干次，执行SHOW语句显示所有日志文件列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW BINARY LOGS</span><br></pre></td></tr></table></figure>

<p>（2）执行RESET MASTER语句，删除所有日志文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RESET MASTER;</span><br></pre></td></tr></table></figure>

<p>执行完该语句后，原来的所有二进制日志已经全部被删除。</p>
<h5 id="4-6其他场景"><a href="#4-6其他场景" class="headerlink" title="4.6其他场景"></a>4.6其他场景</h5><p>二进制日志可以通过数据库的<strong>全量备份</strong>和二进制中保存的<strong>增量信息</strong>完成数据库的<strong>无损失恢复</strong>。但是，如果遇到数据量大、数据库和数据表很多（比如分库分表的应用）的场景，用二进制日志进行数据恢复，是很有挑战性的，因为起止位置不容易管理。</p>
<p>在这种情况下，一个有效的方法是配置<strong>主从数据库服务器</strong>，甚至是一主多从的架构，把二进制日志文件的内容通过中继日志，同步大从数据库服务器中，这样就可以有效避免数据库故障导致的数据异常等问题</p>
<h4 id="5-（重点）再谈二进制日志-binlog"><a href="#5-（重点）再谈二进制日志-binlog" class="headerlink" title="5.（重点）再谈二进制日志(binlog)"></a>5.（重点）再谈二进制日志(binlog)</h4><h5 id="5-1写入机制"><a href="#5-1写入机制" class="headerlink" title="5.1写入机制"></a>5.1写入机制</h5><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写道binlog文件中。因为一个事务的的binlog不能拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个快内存作为binlog cache。</p>
<p>我们可以通过<strong>binlog_cache_size</strong>参数控制单个线程binlog cache大小，如果存储内容超过了这个参数，就要暂存到磁盘（Swap）。binlog日志刷盘流程如下：<img src="/2022/04/22/MySQL/1652342298513.png" alt="1652342298513" loading="lazy"></p>
<blockquote>
<ul>
<li>上图的write，是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快</li>
<li>上图的fsync，才是将数据持久化到磁盘的操作</li>
</ul>
</blockquote>
<p>write和fsync的时机，可以由参数<strong>syn_binlog</strong>控制，默认是0。为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是及其宕机，page cache里的binlog会丢失。如下图：<img src="/2022/04/22/MySQL/1652342452791.png" alt="1652342452791" loading="lazy"></p>
<p>为了安全起见，可以设置为1，表示每次提交事务都会fsync，就如同<strong>redo log刷盘策略一样</strong>。最后还有一种折中方式，可以设置为N（N&gt;1），表示每次提交事务都write，但累积N个事务后才fsync。<img src="/2022/04/22/MySQL/1652342593186.png" alt="1652342593186" loading="lazy"></p>
<p>在出现IO瓶颈的场景里，将sync_binlog设置成一个较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</p>
<h5 id="5-2binlog与redolog对比"><a href="#5-2binlog与redolog对比" class="headerlink" title="5.2binlog与redolog对比"></a>5.2binlog与redolog对比</h5><ul>
<li>redo log 是<strong>物理日志</strong>，记录内容是“在某个数据页上做了什么修改”，属于InnoDB存储引擎层产生的</li>
<li>bin log 是<strong>逻辑日志</strong>，记录内容是语句的原始逻辑，类似于“给ID为2这一行的c字段加1”，属于MySQL Server层</li>
<li>redo是循环写入，全部写满就从头开始</li>
<li>binlog是追加写，写满则创建新文件写入</li>
<li>虽然他们都属于持久化特征，但是侧重点不同。<ul>
<li>redo log 让InnoDB存储引擎拥有了数据崩溃恢复能力</li>
<li>bin log 保证了MySQL集群架构的数据一致性。</li>
</ul>
</li>
</ul>
<h5 id="5-3两阶段提交"><a href="#5-3两阶段提交" class="headerlink" title="5.3两阶段提交"></a>5.3两阶段提交</h5><p><img src="/2022/04/22/MySQL/1652344319600.png" alt="1652344319600" loading="lazy"></p>
<p>在执行更新语句过程，会记录redo log与binlog两块日志，以事务为基本单位，redo log在事务执行过程中可以不断写入，而binglog只有在提交事务时才写入，所以redo log与binlog的<strong>写入时机</strong>不一样</p>
<p><img src="/2022/04/22/MySQL/1652344953665.png" alt="1652344953665" loading="lazy"></p>
<p><strong>redo log与binlog两份日志之间的逻辑不一致，会出现什么问题？</strong></p>
<p>以update语句为例，假设id=2的记录，字段c值是0，把字段c值更新成1，SQL语句为update T set c=1 where id=2.</p>
<p>假设执行过程中写完redo log日志后，binlog日志写期间发生了异常，会出现什么情况呢？<img src="/2022/04/22/MySQL/1652345215447.png" alt="1652345215447" loading="lazy"></p>
<p>由于binlog没写完出现异常，这时候binlog里面没有对应的修改记录。因此，之后用binlog日志恢复数据时，就会减少这一次更新，恢复出来的这一行c值是0，而原库因为redo log日志恢复这一行是1，最终数据不一致。<img src="/2022/04/22/MySQL/1652345400446.png" alt="1652345400446" loading="lazy"></p>
<p>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用<strong>两阶段提交</strong>方案。原理很简单，将redo log的写入拆成两个步骤<strong>prepare</strong>和<strong>commit</strong>，这就是<strong>两阶段提交</strong><img src="/2022/04/22/MySQL/1652345657788.png" alt="1652345657788" loading="lazy"></p>
<p>使用<strong>两阶段提交</strong>后，写入binlog时发现异常也不会由影响，因为MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应binglog日志，就会回滚该事务。<img src="/2022/04/22/MySQL/1652345739133.png" alt="1652345739133" loading="lazy"></p>
<p>另一个场景，redo log设置commit阶段发生异常，会不会回滚事务？<img src="/2022/04/22/MySQL/1652345887656.png" alt="1652345887656" loading="lazy"></p>
<p>并不会回滚事务，他会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binglog日志，所以MySQL认为是完整的，就会提交事务恢复数据。</p>
<h4 id="6-中继日志"><a href="#6-中继日志" class="headerlink" title="6.中继日志"></a>6.中继日志</h4><h5 id="6-1介绍"><a href="#6-1介绍" class="headerlink" title="6.1介绍"></a>6.1介绍</h5><p><strong>中继日志只在主从服务器架构的从服务器上存在。</strong>从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入<strong>本地的日志文件</strong>中，这个从服务器本地的日志文件叫<strong>中继日志</strong>。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成从服务器的<strong>数据同步</strong>。</p>
<p>搭建好后主从服务器之后，中继日志默认会保存在从服务器的数据目录下。</p>
<p>文件名的格式是：<strong>从服务器名 -relay-bin.序号</strong>。中继日志还有一个索引文件：<strong>从服务器名 -relay-bin.index</strong>，用来定位当前正在使用的中级日志。</p>
<h5 id="6-2查看中继日志"><a href="#6-2查看中继日志" class="headerlink" title="6.2查看中继日志"></a>6.2查看中继日志</h5><p>中继日志与二进制日志的格式相同，可以用mysqlbinlog工具进行查看。下面是中继日志的一个片段：<img src="/2022/04/22/MySQL/1652346900849.png" alt="1652346900849" loading="lazy"></p>
<p>这一段的意思是，主服务器（“server id 1”）对表atguigu.test进行了2步操作：<img src="/2022/04/22/MySQL/1652346954347.png" alt="1652346954347" loading="lazy"></p>
<h5 id="6-3恢复的典型错误"><a href="#6-3恢复的典型错误" class="headerlink" title="6.3恢复的典型错误"></a>6.3恢复的典型错误</h5><p>如果从服务器宕机，有的时候为了系统恢复，要重装系统，这样就可能会导致你的<strong>服务器名称与之前不同</strong>。而中继日志里是<strong>包含从服务器名</strong>的。在这种情况下，就可能导致恢复从服务器时，无法从宕机前的中继日志里读取数据，以为是日志文件损坏了，其实是名称不对了。</p>
<p>解决办法，把从服务器的名称改回之前的名称。</p>
<h2 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h2><p><strong>事务的隔离性由锁来实现</strong></p>
<blockquote>
<p>锁的粒度</p>
</blockquote>
<p>MySQL提供了两种锁：行级锁和表级锁。</p>
<p>选择时，应尽量只锁需要修改的那部分数据，而不是所有的资源，锁定的数量越少，并发度越高，发生锁的争用越少。</p>
<p>但是加锁需要消耗资源，所得各种操作（包括获取锁、释放锁以及检查锁的状体）都会增加系统开销，因此锁的粒度越小，系统开销越大。在选择时需要在锁开销和并发程度间做权衡 。</p>
<h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/SnailMann/article/details/88353099">https://blog.csdn.net/SnailMann/article/details/88353099</a></p>
<hr>
<p>1.读写锁</p>
<ul>
<li>互斥锁，简写为X锁，又称写锁</li>
<li>共享锁，简写为S锁，又称读锁</li>
</ul>
<p>规定：</p>
<ul>
<li>一个事物对数据A加了X锁，就可以对数据A进行读取和更新，加锁期间不能对A加任何锁</li>
<li>一个事物对数据对象A加了S锁，可以对A进行读取数据，但是不能进行更新，加锁期间其他事物可以对数据对象A加S锁，但不能加X锁</li>
</ul>
<p> <img src="/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373231333532333737372e706e67.png" alt="img" loading="lazy"> </p>
<p>2.意向锁</p>
<p>使用意向锁，可以更容易的支持多粒度封锁。</p>
<p> 在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。 </p>
<p>意向锁在原来的X/S锁基础上引入了IS/IX锁，两者都是表锁，表示：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事物T想要对表A加X锁，只需要检查是否有其他事物对表A加了X/IX/S/IS锁，如果加了就表示有其他事物正在使用表或表中的一行，因此事物T加锁失败</p>
<p> <img src="/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373231343434323638372e706e67.png" alt="img" loading="lazy"> </p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li>
<li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li>
</ul>
<p>3.InnoDB存储引擎行锁的三种实现</p>
<p>record lock：单个行记录上的锁</p>
<p>gap lock：间歇锁，锁定一个范围，不包括记录本身</p>
<p>next-key lock：record lock+gap锁定一个范围包括记录本身</p>
<p>4.乐观锁和悲观锁</p>
<p>并不是真正意义的锁，而是一种思想</p>
<p>悲观锁：悲观并发控制，持一种消极态度，默认数据被访问时，会发生冲突，所以在处理数据整个过程加锁状态</p>
<p>乐观锁：乐观并发控制，并发环境中始终认为对数据的操作不会发生冲突，在对事物更新提交时，才判断是否发生冲突</p>
<p>5.行锁、表锁与页锁</p>
<ul>
<li>表级锁定：MySQL中锁定粒度最大的一种，表示对当前表加锁</li>
<li>页级锁定 ：MySQL中锁粒度介于行级锁和表级锁之间的一种锁</li>
<li>行级锁：MySQL中锁粒度最小的一种，</li>
</ul>
<h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><blockquote>
<p>三级锁协议</p>
</blockquote>
<p>1.一级封锁协议</p>
<p>事物T想要修改数据A时必须加X锁，知道T结束才释放锁。</p>
<p>可以解决丢失修改的问题，因为不能有同时两个事物对同一个数据修改 <img src="/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232303434303435312e706e67.png" alt="img" loading="lazy"> </p>
<p>2.二级封锁协议</p>
<p>在一级基础上，要求读取数据A时必须加S锁，读取完马上释放。</p>
<p>可以解决脏读问题，因为如果一个事物在对数据A修改，根据一级协议会加X锁，呢么就不能加S锁，也就不会读入数据。 <img src="/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232303833313834332e706e67.png" alt="img" loading="lazy"> </p>
<p>3.三级封锁协议</p>
<p>在二级的基础上，要求一个事物读取数据A时加S锁，知道事物结束才释放锁。可以解决不可重复读的问题，因为读A时，其他事物不能修改数据A <img src="/2022/04/22/MySQL/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313331333831392e706e67.png" alt="img" loading="lazy"> </p>
<blockquote>
<p>两端锁协议</p>
</blockquote>
<p>加锁和解锁分为两个阶段进行。</p>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure>

<p> 但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure>

<h3 id="MySQL隐式与显示锁定"><a href="#MySQL隐式与显示锁定" class="headerlink" title="MySQL隐式与显示锁定"></a>MySQL隐式与显示锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>
<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... LOCK In SHARE MODE;</span><br><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据，需要保证这个数据在任何时刻最多只有一个线程在访问，保证数据的完整性和一致性。</p>
<p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对 <strong>并发操作进行控制</strong> ，因此产生了 锁 。同时 锁机制 也为实现MySQL 的各个隔离级别提供了保证。 锁冲突 也是影响数据库 并发访问性能 的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p>
<h3 id="2-MySQL并发事务访问相同记录"><a href="#2-MySQL并发事务访问相同记录" class="headerlink" title="2.MySQL并发事务访问相同记录"></a>2.MySQL并发事务访问相同记录</h3><h4 id="2-1读-读情况"><a href="#2-1读-读情况" class="headerlink" title="2.1读-读情况"></a>2.1读-读情况</h4><p>读-读情况，即并发事务相继读取相同记录。读取操作本身不会对记录有任何影响，所以允许这种情况发生</p>
<h4 id="2-2写-写情况"><a href="#2-2写-写情况" class="headerlink" title="2.2写-写情况"></a>2.2写-写情况</h4><p>即并发事务相继对相同记录做出改动。</p>
<p>在这种情况下会发生 <strong>脏写</strong> 的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们 <strong>排队执行</strong> ，这个排队的过程其实是通过 <strong>锁</strong> 来实现的。这个所谓 的锁其实是一个 <strong>内存中的结构</strong> ，在事务执行前本来是没有锁的，也就是说一开始是没有 <strong>锁结构</strong> 和记录进行关联的，如图所示：<img src="/2022/04/22/MySQL/1651307939016.png" alt="1651307939016" loading="lazy"></p>
<p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 <strong>锁结构</strong> ，当没有的时候 就会在内存中生成一个 <strong>锁结构</strong> 与之关联。比如，事务 T1 要对这条记录做改动，就需要生成一个 <strong>锁结构</strong> 与之关联：<img src="/2022/04/22/MySQL/1651307988699.png" alt="1651307988699" loading="lazy"></p>
<p><img src="/2022/04/22/MySQL/1651307996814.png" alt="1651307996814" loading="lazy"></p>
<p><img src="/2022/04/22/MySQL/1651308003294.png" alt="1651308003294" loading="lazy"></p>
<p>小结几种说法：</p>
<ul>
<li><p>不加锁 </p>
<p>意思就是不需要在内存中生成对应的 锁结构 ，可以直接执行操作。 </p>
</li>
<li><p>获取锁成功，或者加锁成功 </p>
<p>意思就是在内存中生成了对应的 锁结构 ，而且锁结构的 is_waiting 属性为 false ，也就是事务可以继续执行操作。 </p>
</li>
<li><p>获取锁失败，或者加锁失败，或者没有获取到锁</p>
<p>意思就是在内存中生成了对应的 锁结构 ，不过锁结构的 is_waiting 属性为 true ，也就是事务 </p>
<p>需要等待，不可以继续执行操作。 </p>
</li>
</ul>
<h4 id="2-3读-写或写-读情况"><a href="#2-3读-写或写-读情况" class="headerlink" title="2.3读-写或写-读情况"></a>2.3读-写或写-读情况</h4><p>读-写或写-读，即一个事务进行读取操作，另一个事务进行改动操作。这种情况下可能发生脏读，不可重复读，幻读的问题。</p>
<p>各个数据库厂商对 SQL标准 的支持都可能不一样。比如MySQL在 REPEATABLE READ 隔离级别上就已经解决了 幻读 问题。</p>
<h4 id="2-4并发问题的解决方案"><a href="#2-4并发问题的解决方案" class="headerlink" title="2.4并发问题的解决方案"></a>2.4并发问题的解决方案</h4><p>如何解决脏读、不可重复读、幻读问题呢</p>
<ul>
<li><p>方案一：读操作利用多版本并发控制（MVCC），写操作进行加锁</p>
<p>所谓<strong>MVCC</strong>，就是生成一个<strong>ReadView</strong>，通过ReadView找到符合条件的记录版本(历史版本由<strong>undo日志</strong>构建)。查询语句只能<strong>读</strong>到在ReadView前<strong>已提交事务的修改</strong>，在未提交或才开启的事务所作的修改是看不到的。而<strong>写操作是针对最新版本的记录</strong>，读记录的历史版本和改记录的最新版本并不冲突，也就是MVCC读-写不冲突</p>
<blockquote>
<p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p>
<ul>
<li>在READ COMMITED隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可读取到未提交的事务所作的修改，也就避免了脏读现象</li>
<li>在REPEATABLE READ隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作才会生成一个ReadView，之后的SELECT操作都会复用这个readview，这样就避免了不可重复读和幻读问题</li>
</ul>
</blockquote>
<p><strong>mvcc能否解决幻读？</strong></p>
</li>
<li><p>方案二：读写操作都采用加锁</p>
<p>如果一些业务场景不允许读取记录的旧版本，而是每次必须去读取记录的最新版本。比如，在银行存款的事务中，需要先把账户的余额读出来，然后将其加上本次存款的数额，最后写到数据库。在将账户余额读取出来后，就不想让其他事务访问该余额，直到本次存款事务执行成功，其他事务才可以访问到账户余额。这样在读取记录的时候就需要对其进行加锁操作，这样也就意味着读操作和写操作也像写-写操作一样排队执行</p>
<p><strong>脏读</strong>的产生是因为当前事务读取了另一个未提交事务写的记录，如果另一个事务在写记录的时候就给记录加锁，那么当前事务就无法读到该记录，也就就没有脏读问题</p>
<p><strong>不可重复读</strong>的产生是因为当前事务先读取到某一记录，另一个事务对该类记录修改并提交后，当前事务再次读取会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读。</p>
<p>幻读的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新的记录，当前事务再次读取该范围的记录时发现了新插入的新纪录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务第一次读取记录时幻影记录并不存在，所以读取的时候加锁不知道给谁加</p>
</li>
<li><p>小结对比：</p>
<ul>
<li>采用MVCC方式，读-写操作彼此并不冲突</li>
<li>采用加锁方式，读-写操作彼此需要排队执行，影响性能</li>
</ul>
</li>
</ul>
<h3 id="3-锁的不同角度分类"><a href="#3-锁的不同角度分类" class="headerlink" title="3.锁的不同角度分类"></a>3.锁的不同角度分类</h3><p>锁的分类图，如下：<img src="/2022/04/22/MySQL/1651320185635.png" alt="1651320185635" loading="lazy"></p>
<h4 id="3-1从数据操作的类型划分-读锁、写锁"><a href="#3-1从数据操作的类型划分-读锁、写锁" class="headerlink" title="3.1从数据操作的类型划分:读锁、写锁"></a>3.1从数据操作的类型划分:读锁、写锁</h4><p>对于数据库中并发事务的读-读情况并不会引起什么问题。对于读-写、写-写或写-读这些情况可能会引起一些问题。需要使用MVCC或加锁方式来解决。在使用加锁方式解决时，由于既要允许读-读情况不受影响，又要使写-写、读-写或写-读情况中的操作相互阻塞，所以MySQL实现了一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常称为共享锁、排他锁，也叫读锁和写锁</p>
<ul>
<li>读锁：也称为共享锁、英文用S表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞。</li>
<li>写锁:也称为排他锁、英文用X表示。当前写操作没有完成前，它会阻挡其他写锁和读锁。这样就能确保在给定的时间内只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源</li>
</ul>
<p><strong>需要注意的是对于InnoDb引擎来说，读锁和写锁可以加在表上也可以加在行上</strong></p>
<p>举例（行级读写锁）：如果一个事务T1已经获得某个行r的读锁，此时另一个事务是可以去获得这个行r的读锁的，因为读操作并没有改变行r的数据，但是T3事务想获得行r的写锁，则必须等到1 2两个事务释放掉r上的读锁<img src="/2022/04/22/MySQL/1651393998025.png" alt="1651393998025" loading="lazy"></p>
<p><strong>1.锁定读</strong></p>
<p>在采用加锁方式解决脏读、不可重复读、幻读问题时，读取一条记录时需要获得该行记录的S锁，其实不严谨，有时候需要在读取记录时获取记录的X锁。来禁止别的事务读读写该记录，为此MySQL提出了两种特殊的SELECT语句格式：</p>
<ul>
<li><p>对读取记录加S锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... LOCK IN SHARE MODE;</span><br><span class="line">#或</span><br><span class="line">SELECT ... FOR SHARE;#(8.0新增)</span><br></pre></td></tr></table></figure>

<p>在普通的SELECT语句后边加LOCK IN SHARE MODE，如果对读取记录加X锁：如果当前事务执行到了该语句，那么它会为读取到的记录加S锁，这样允许别的事物j继续获取这些记录的S锁，但不能获取记录的X锁。如果别的事物想获得记录的X锁，就会阻塞，直到当前事务提交后将这些记录上的S锁释放掉</p>
</li>
<li><p>对读取记录加X锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p>在普通的SELECT语句后加FOR UPDATE，如果当前事务执行到该语句，那么会为读取到的记录加X锁，这样及不允许别的事物获取这些记录的S锁，也不允许别的事物获取X锁</p>
</li>
</ul>
<p><strong>MySQL8.0新特性</strong></p>
<p>在5.7及之前的版本，SELECT…FOR UPDATE，如果获取不到锁，会一直等待，直到<strong>innodb_lock_wait_timeout</strong>超时。在8.0版本中，SELECT..FOR UPDATE，SELECT…FOR SHARE添加的NOWAIT SKIP LOCKED语法，跳过锁等待，或者跳过锁定。</p>
<ul>
<li>通过添加NOWAIT、SKIP LOCKED语法，能够立即返回。如果查询的行已经加锁：<ul>
<li>那么NOWAIT会立即报错返回</li>
<li>而SKIP LOCKED也会立即返回，知识返回结果中不包含锁定的行</li>
</ul>
</li>
</ul>
<p><img src="/2022/04/22/MySQL/1651395019178.png" alt="1651395019178" loading="lazy"></p>
<p><strong>2.写操作</strong></p>
<p>平常锁用到的写操作无非是DELETE、UPDATE、INSERT三种：</p>
<ul>
<li><p>DELETE：</p>
<p>对一条记录做DELETE操作的过程其实是现在B+树定位到这条记录的位置，然后获取这条记录的X锁，在执行delete mark操作。我们也可以把这个定位待删除记录在B+树中位置的过程看成一个获取X锁的锁定读</p>
</li>
<li><p>UPDATE:在对一条记录做UPDATE操作时分为三种情况</p>
<ul>
<li><strong>情况1：</strong>未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。则先在B+树中定位到这个记录的位置，然后再获取一下记录的X锁，最后在原纪录的位置进行修改操作。也可以把这个定位待修改记录在B+树中的位置的过程看作获取X锁的锁定读</li>
<li><strong>情况2：</strong>未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。则先在B+树中定位到这个记录的位置，然后再获取一下记录的X锁，将该记录彻底删掉(把记录彻底移入垃圾链表)，最后再插入一条新纪录。这个定位待修改记录在B+树种位置的过程看成是一个获取X锁的锁定读，新插入的记录由INSERT操作提供隐式锁保护。</li>
<li><strong>情况3：</strong>修改了该记录的键值，则相当于在原纪录上做了DELETE操作之后再来一次INSERT操作，加锁操作按照DELETE和INSERT的规则进行</li>
</ul>
</li>
<li><p>INSERT:</p>
<p>一般情况下，新插入一条记录的操作并不加锁，通过一种叫隐式锁的结构来保护这条新插入的记录在本事物提交前不被别的事物访问。</p>
</li>
</ul>
<h4 id="3-2从数据操作的粒度上划分：表级锁、行级锁、页级锁"><a href="#3-2从数据操作的粒度上划分：表级锁、行级锁、页级锁" class="headerlink" title="3.2从数据操作的粒度上划分：表级锁、行级锁、页级锁"></a>3.2从数据操作的粒度上划分：表级锁、行级锁、页级锁</h4><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是<strong>很耗资源</strong>的事（涉及获取、检查、释放锁等动作）。因此数据库系统需要在<strong>高并发响应和系统性能</strong>两方面进行平衡，这样就产生了<strong>锁粒度</strong>的概念。</p>
<p>对一条记录加锁影响的只是这条记录，我们就说这个锁的粒度比较细，其实一个事务也可以在表上加锁，称之为表锁，对一个表加锁影响的也是一个表的记录，我们就说这个锁的粒度比较粗，锁的粒度主要分为表级锁、页级锁、行锁</p>
<h5 id="1-表锁（Table-Lock）"><a href="#1-表锁（Table-Lock）" class="headerlink" title="1.表锁（Table Lock）"></a>1.表锁（Table Lock）</h5><p>该锁会锁定整张表，它是MySQL最基本的锁策略，并不依赖存储引擎，并且表锁是开销最小的策略（因为粒度比较大），由于表级锁一次会将整张表锁住，所以可以很好的避免死锁问题。当然锁粒度的增大带来的负面影响就是出现锁资源竞争的概率也会增大，导致并发率降低</p>
<p>1.表级的S锁、X锁</p>
<p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的S锁或X锁的。在对某个表执行一些诸如ALTER TABLE、DROP TABLE这类的DDL语句时，其他事物对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事物种对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行DDL语句也会发生阻塞。这个过程其实是通过在server层使用一种称之为元数据锁结构来实现的</p>
<p>一般情况下，不会使用InnoDB存储引擎提供的表级别的 S锁 和 X锁 。只会在一些特殊情况下，比方说 崩 溃恢复 过程中用到。比如，在系统变量 autocommit=0，innodb_table_locks = 1 时， 手动 获取InnoDB存储引擎提供的表t 的 S锁 或者 X锁 可以这么写： </p>
<ul>
<li>LOCK TABLES t READ ：InnoDB存储引擎会对表 t 加表级别的 S锁 。 </li>
<li>LOCK TABLES t WRITE ：InnoDB存储引擎会对表 t 加表级别的 X锁 。 </li>
</ul>
<p>不过尽量避免在使用InnoDB存储引擎的表上使用 LOCK TABLES 这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的 行锁 ，关于InnoDB表级别的 S锁 和 X锁 大家了解一下就可以了。 </p>
<p>MyISAM在执行查询语句前，会给涉及的所有表加读锁，在执行增删改之前，会给涉及的所有表加写锁。InnoDB<strong>存储引擎不会为这个表添加表级别的读锁或写锁</strong></p>
<p>MySQL的表级锁有两种模式：（以MyISAM表进行操作的演示） </p>
<ul>
<li>标记共享锁</li>
<li>表独占写锁<img src="/2022/04/22/MySQL/1651415857990.png" alt="1651415857990" loading="lazy"></li>
</ul>
<p>2.意向锁</p>
<p>InnoDB支持多粒度锁，允许行级锁和表级锁共享，而意向锁就是其中一种表锁。</p>
<ol>
<li>意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存</li>
<li>意向锁是一种不与行级锁冲突的表级锁</li>
<li>表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</li>
</ol>
<p>意向锁分为两种：</p>
<ul>
<li><p>意向共享锁:事物有意向对表中的某些行加共享锁（S锁）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 SELECT column FROM table ... LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure></li>
<li><p>意向排他锁:事物有意向对表中某些行加排他锁（X锁）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。 SELECT column FROM table ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p>即：意向锁是由<strong>存储引擎 自己维护的</strong> ，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前InooDB 会先获取该数据行 <strong>所在数据表的对应意向锁 。</strong></p>
</li>
</ul>
<p><strong>意向锁解决的问题</strong></p>
<p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排他锁，如果没有意向锁的存在，那么T2就需要去检查各个页或行是否存在锁，如果存在意向锁，那么此时就会享受到由T1控制的表级别意向锁的阻塞。T2锁定该表前不必检查各个页或行锁，只需要检查该表的意向锁。</p>
<p>在数据表场景中，如果我们给某一行数据加上了排他锁，数据库会自动    给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有其他人上过排他锁，这样当其他人想要获取数据表排他锁时，只需要了解是否有人已经获取了这个数据表的意向排他锁即可</p>
<ul>
<li>如果事务想要获取数据表中某些记录的共享锁，就需要在数据表上加意向共享锁</li>
<li>如果事务想要获取数据表中某些记录的排他锁，就需要在数据表上加意向排他锁</li>
</ul>
<p><strong>意向锁的并发性</strong></p>
<p>意向锁不会与行级锁的共享/排他锁互斥。正因如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性</p>
<p>从上面例子可以得到如下结论：</p>
<ol>
<li>InnoDB支持多粒度锁，特定场景下，行级锁可以与表级锁共存</li>
<li>意向锁之间并不互斥，，但除了IS与S兼容外，意向锁会与共享锁/排他锁互斥</li>
<li>IX、IS是表级锁，不会与行级的X，S锁发生冲突，只会与表级的S、X锁发生冲突</li>
<li>意向锁在保证并发性的前提下，实现了行锁和表锁共存且满足事务隔离性的要求</li>
</ol>
<p>3.自增锁（AUTO-INC锁）</p>
<p>在使用MySQL过程中，我们可以分为表的某个列添加AUTO_INCREMENT属性。举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `teacher` ( `id` int NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure>

<p>由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改 如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `teacher` (name) VALUES (&#x27;zhangsan&#x27;), (&#x27;lisi&#x27;);</span><br></pre></td></tr></table></figure>

<p>上边的插入语句并没有为id列显示赋值，所以系统会自动为它附上递增的值，结果如下：<img src="/2022/04/22/MySQL/1651481620005.png" alt="1651481620005" loading="lazy"></p>
<p>现在我们看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是 </p>
<p>“ Simple inserts ”，“ Bulk inserts ”和“ Mixed-mode inserts ”。 </p>
<p><strong>1. “Simple inserts”</strong> <strong>（简单插入）</strong> </p>
<p>可以 预先确定要插入的行数 （当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行 INSERT…VALUES() 和 REPLACE 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行数。 </p>
<p><strong>2. “Bulk inserts”</strong> <strong>（批量插入）</strong> </p>
<p>事先不知道要插入的行数 （和所需自动递增值的数量）的语句。比如 INSERT … SELECT ， REPLACE … SELECT 和 LOAD DATA 语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列 分配一个新值。 </p>
<p><strong>3. “Mixed-mode inserts”</strong> <strong>（混合模式插入）</strong> </p>
<p>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如 INSERT INTO teacher (id,name) VALUES (1,’a’), (NULL,’b’), (5,’c’), (NULL,’d’); 只是指定了部分id的值。另一种类型的“混 合模式插入”是 INSERT … ON DUPLICATE KEY UPDATE 。 </p>
<p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式： </p>
<p>（1）innodb_autoinc_lock_mode = 0(“传统”锁定模式) </p>
<p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有 AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个 表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证 master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的 时候，对于AUTO-INC锁的争夺会 限制并发 能力。 </p>
<p>（2）innodb_autoinc_lock_mode = 1(“连续”锁定模式) </p>
<p>在 MySQL 8.0 之前，连续锁定模式是 默认 的。 </p>
<p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT … SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。 </p>
<p>对于“Simple inserts”（要插入的行数事先已知），则通过在 mutex（轻量锁） 的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用 表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。 </p>
<p>（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式) </p>
<p>从 MySQL 8.0 开始，交错锁模式是 默认 设置。 </p>
<p>在此锁定模式下，自动递增值 保证 在所有并发执行的所有类型的insert语句中是 唯一 且 单调递增 的。但 是，由于多个语句可以同时生成数字（即，跨语句交叉编号），<strong>为任何给定语句插入的行生成的值可能不是连续的。</strong> </p>
<p><strong>④ 元数据锁（<strong><strong>MDL</strong></strong>锁）</strong> MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个 表结构做变更 ，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。 </p>
<p>因此，<strong>当对一个表做增删改查操作的时候，加</strong> <strong>MDL****读锁；当要对表做结构变更操作的时候，加</strong> <strong>MDL</strong> <strong>写锁。</strong></p>
<h5 id="2-InnoDB行锁"><a href="#2-InnoDB行锁" class="headerlink" title="2.InnoDB行锁"></a>2.InnoDB行锁</h5><p>行锁也称为记录锁，就是锁住某一行。mysql服务层并没有实现行锁机制，行级锁只在存储引擎层实现</p>
<p><strong>优点</strong>：锁定粒度小，发生锁冲突概率低，可以实现的并发度高</p>
<p><strong>缺点</strong>对于锁的开销比较大，加锁会比较慢，容易出现死锁</p>
<p><strong>1.记录锁（record lock）</strong></p>
<p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为： LOCK_REC_NOT_GAP 。比如我们把id值为8的那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。<img src="/2022/04/22/MySQL/1651481862505.png" alt="1651481862505" loading="lazy"></p>
<p>举例如下：<img src="/2022/04/22/MySQL/1651481874818.png" alt="1651481874818" loading="lazy"></p>
<p>记录锁是有S锁和X锁之分，称之为S型记录锁和X型记录锁。</p>
<ul>
<li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁</li>
<li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li>
</ul>
<p><strong>2.间歇锁（Gap Locks）</strong></p>
<p>MySQL 在 REPEATABLE READ 隔离级别下是<strong>可以解决幻读问题的</strong>，解决方案有两种，可以使用 MVCC 方案解决，也可以采用 加锁 方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读 取操作时，那些幻影记录尚不存在，我们无法给这些 幻影记录 加上 记录锁 。InnoDB提出了一种称之为 Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们可以简称为 gap锁 。比如，把id值为8的那条记录加一个gap锁的示意图如下。<img src="/2022/04/22/MySQL/1651482155999.png" alt="1651482155999" loading="lazy"></p>
<p>图中id值为8的记录加了gap锁，意味着不允许别的事物在id值为8的记录前边的间歇插入新纪录，其实就是idlie的值(3，8)这个区间的新记录时不允许立即插入。比如，有另外一个事物想再插入一条id值为4的新纪录，他定位到该条新纪录的下一条的id值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作，知道拥有这个gap锁的事物提交之后，id列的值在区间（3，8）中的新纪录才可以被插入。</p>
<p><strong>gap锁的提出仅仅是为了防止插入幻影记录而提出的</strong></p>
<p><strong>3.临键锁（Next-Key Locks）</strong></p>
<p>有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间歇插入新纪录，所以InnoDB就提出了一种称之为Next-Key Locks的锁。官方称之为LOCK_ORDINARY，简称为 Next-Key 锁。Next-Key Locks是存在存储引擎innodb、事务级别在可重复读的情况下使用的数据库锁，InnoDB默认就是Next-Key Locks。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">begin; select * from student where id &lt;=8 and id &gt; 3 for update;</span><br></pre></td></tr></table></figure>

<p><strong>4.插入意向锁（insert Intention Locks）</strong></p>
<p>我们说一个事务在 插入 一条记录时需要判断一下插入位置是不是被别的事务加了 gap锁 （ next-key锁也包含 gap锁 ），如果有的话，插入操作需要等待，直到拥有 gap锁 的那个事务提交。但是<strong>InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构</strong>，表明有事务想在某个 间隙 中 插入 新记录，但是现在在等待。InnoDB就把这种类型的锁命名为 Insert Intention Locks ，官方的类型名称为：LOCK_INSERT_INTENTION ，我们称为 插入意向锁 。插入意向锁是一种 Gap锁 ，不是意向锁，在insert操作时产生。 </p>
<p>插入意向锁是在插入一条记录行前，由 INSERT 操作产生的一种间隙锁 。 </p>
<p>事实上<strong>插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</strong> </p>
<h5 id="3-页锁"><a href="#3-页锁" class="headerlink" title="3.页锁"></a>3.页锁</h5><p>页锁就是在 页的粒度 上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。<strong>页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</strong> </p>
<p>每个层级的锁数量是有限制的，因为锁会占用内存空间， 锁空间的大小是有限的 。当某个层级的锁数量 超过了这个层级的阈值时，就会进行 锁升级 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p>
<h4 id="3-3从对锁的态度划分：乐观锁、悲观锁"><a href="#3-3从对锁的态度划分：乐观锁、悲观锁" class="headerlink" title="3.3从对锁的态度划分：乐观锁、悲观锁"></a>3.3从对锁的态度划分：乐观锁、悲观锁</h4><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待<strong>数据并发的思维方式</strong> 。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的 <strong>设计思想</strong> 。 </p>
<h5 id="1-悲观锁"><a href="#1-悲观锁" class="headerlink" title="1.悲观锁"></a>1.悲观锁</h5><p>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。 </p>
<p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 阻塞 直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中 <strong>synchronized</strong> 和 <strong>ReentrantLock</strong> 等独占锁就是悲观锁思想的实现。</p>
<p><strong>秒杀案例1：</strong></p>
<p>商品秒杀过程中，库存数量的减少，避免出现超卖的情况。比如，商品表中有一个字段为quantity标识当前该商品的库存量。假设商品为华为mate40，id为1001， quantity为100个，如果不使用锁的情况下，操作方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#第一步：查出商品库存</span><br><span class="line">select quantity from items where id = 1001;</span><br><span class="line">#第二步：如果库存大于0，则根据商品信息生产订单</span><br><span class="line">insert into orders(item_id) values(1001);</span><br><span class="line">#第三步：修改商品的库存，num表示购买数量</span><br><span class="line">update items set quantity = quantity-num where id = 1001;</span><br></pre></td></tr></table></figure>

<p>这样写的话，在并发量小的公司没有大的问题，但如果在高并发环境下可能会出现以下问题<img src="/2022/04/22/MySQL/1651741342257.png" alt="1651741342257" loading="lazy"></p>
<p>其中线程B此时已经下单并且减完库存，这个时候线程A依然执行step3，就造成了超卖。</p>
<p>我们使用悲观锁可以解决这个问题，商品信息从查询出来到修改，中间有一个生成订单过程，使用悲观锁的原理就是，当我们查询items信息后把当前数据锁定，知道修改完毕后再解锁。那么整个过程中，因为数据被锁定了，就不会出现第三者来对其修改。而这样做是需要将执行的sql语句放在同一个事务，否则达不到锁定数据行的目的。</p>
<p>修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#第一步：查询商品库存</span><br><span class="line">select quantity from items where id = 1001 for update;</span><br><span class="line">#第二步：如果库存大于0，则根据商品信息生产订单</span><br><span class="line">insert into orders(item_id) values(1001);</span><br><span class="line">#第三步：修改商品库存，num表示购买数量</span><br><span class="line">update items set quantity = quantity - num where id = 1001;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1651741901928.png" alt="1651741901928" loading="lazy"></p>
<h5 id="2-乐观锁"><a href="#2-乐观锁" class="headerlink" title="2.乐观锁"></a>2.乐观锁</h5><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是<strong>不采用数据库自身的锁机制，而是通过程序来实现</strong>。在程序上，我们可以采用 版本号机制 或者 CAS机制 实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。在Java中 java.util.concurrent.atomic 包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。 </p>
<p><strong>1.乐观锁的版本号机制</strong></p>
<p>在表中设计一个 版本字段 version ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行 UPDATE … SET version=version+1 WHERE version=version 。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</p>
<p><strong>2.乐观锁的时间戳机制</strong></p>
<p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。 </p>
<p>你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或者时间戳），从而证明当前拿到的数据是否最新。</p>
<p><strong>秒杀案例2</strong>：</p>
<p>依然使用上面秒杀的案例，执行流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#第一步，查出商品库存</span><br><span class="line">select quantity from items where id = 1001;</span><br><span class="line">#第二步：如果库存大于0，则根据商品信息生产订单</span><br><span class="line">insert into orders(item_id) values(1001);</span><br><span class="line">#第三步：修改商品的库存，num表示购买数量</span><br><span class="line">update items set quantity = quantity-num,version=version+1 where id = 1001 and version = #(version)</span><br></pre></td></tr></table></figure>

<p>注意，如果数据表是读写分离的表，当masterr表中写入的数据没有及时同步到slave表中时，会造成更新一直失败的问题。此时需要强制读取master表中的数据（即将select语句放到事务中即可，这时候查询的就是master主库了）</p>
<p>如果我们对同一条数据进行频繁的修改的话，那么就会出现这么一种场景，每次修改都只有一个事务能更新成功，在业务感知上面就有大量的失败操作。把代码修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#第一步：查出商品库存</span><br><span class="line">select quantity from items where id = 1001;</span><br><span class="line">#第二步：如果库存大于0，则根据商品信息生产订单</span><br><span class="line">insert into orders(item_id) values(1001);</span><br><span class="line">#第三步：修改商品的库存，num表示购买数量</span><br><span class="line">update items set quantity = quantity - num where id = 100 and quantity-num&gt;0;</span><br></pre></td></tr></table></figure>

<p>这样就会使每次修改都能成功，而且我不会出现超卖的现象。</p>
<h5 id="3-两种锁的使用场景"><a href="#3-两种锁的使用场景" class="headerlink" title="3.两种锁的使用场景"></a>3.两种锁的使用场景</h5><ol>
<li><p>乐观锁 适合 读操作多 的场景，相对来说写的操作比较少。它的优点在于 程序实现 ， 不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。 </p>
</li>
<li><p>悲观锁 适合 写操作多 的场景，因为写的操作具有 排它性 。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止 读 - 写 和 写 - 写 的冲突。 </p>
</li>
</ol>
<h4 id="3-4按加锁方式划分：显示锁、隐式锁"><a href="#3-4按加锁方式划分：显示锁、隐式锁" class="headerlink" title="3.4按加锁方式划分：显示锁、隐式锁"></a>3.4按加锁方式划分：显示锁、隐式锁</h4><h5 id="1-隐式锁"><a href="#1-隐式锁" class="headerlink" title="1.隐式锁"></a>1.隐式锁</h5><ul>
<li><strong>情景一：</strong>对于聚簇索引记录来说，有一个 trx_id 隐藏列，该隐藏列记录着最后改动该记录的 事务 id 。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的 trx_id 隐藏列代表的的就是 当前事务的 事务id ，如果其他事务此时想对该记录添加 S锁 或者 X锁 时，首先会看一下该记录的 trx_id 隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个 X 锁 （也就是为当前事务创建一个锁结构， is_waiting 属性是 false ），然后自己进入等待状态 (也就是为自己也创建一个锁结构， is_waiting 属性是 true ）。 </li>
<li><strong>情景二：</strong>对于二级索引记录来说，本身并没有 trx_id 隐藏列，但是在二级索引页面的 Page Header 部分有一个 PAGE_MAX_TRX_ID 属性，该属性代表对该页面做改动的最大的 事务id ，如 果 PAGE_MAX_TRX_ID 属性值小于当前最小的活跃 事务id ，那么说明对该页面做修改的事务都已 经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记 录，然后再重复 情景一 的做法。 </li>
</ul>
<p>session1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; insert INTO student VALUES(34,&quot;周八&quot;,&quot;二班&quot;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>session2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; select * from student lock in share mode; #执行完，当前事务被阻塞</span><br></pre></td></tr></table></figure>

<p>执行下述语句，输出结果：<img src="/2022/04/22/MySQL/1651483798762.png" alt="1651483798762" loading="lazy"></p>
<p>隐式锁的逻辑过程如下： </p>
<p>A. InnoDB的每条记录中都一个隐含的trx_id字段，这个字段存在于聚簇索引的B+Tree中。 </p>
<p>B. 在操作一条记录前，首先根据记录中的trx_id检查该事务是否是活动的事务(未提交或回滚)。如果是活动的事务，首先将 隐式锁 转换为 显式锁 (就是为该事务添加一个锁)。 </p>
<p>C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为waiting状态。如果没有冲突不加锁，跳到E。 </p>
<p>D. 等待加锁成功，被唤醒，或者超时。 </p>
<p>E. 写数据，并将自己的trx_id写入trx_id字段。</p>
<h5 id="2-显示锁"><a href="#2-显示锁" class="headerlink" title="2.显示锁"></a>2.显示锁</h5><p>通过特定的语句进行加锁，我们一般称之为显示加锁，例如： </p>
<p>显示加共享锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select .... lock in share mode</span><br></pre></td></tr></table></figure>

<p>显示排他锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select .... for update</span><br></pre></td></tr></table></figure>

<h4 id="3-5其他锁之：全局锁"><a href="#3-5其他锁之：全局锁" class="headerlink" title="3.5其他锁之：全局锁"></a>3.5其他锁之：全局锁</h4><p>全局锁就是对 整个数据库实例 加锁。当你需要让整个库处于 只读状态 的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用 场景 是：做 全库逻辑备份 。 </p>
<p>全局锁的命令：</p>
<blockquote>
<p>Flush tables with read lock</p>
</blockquote>
<h4 id="3-6其他锁之：死锁"><a href="#3-6其他锁之：死锁" class="headerlink" title="3.6其他锁之：死锁"></a>3.6其他锁之：死锁</h4><blockquote>
<p>概念</p>
</blockquote>
<p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。死 </p>
<p>锁示例： <img src="/2022/04/22/MySQL/1651497441083.png" alt="1651497441083" loading="lazy"></p>
<p>这时候，事务1在等待事务2释放id=2的行锁，而事务2在等待事务1释放id=1的行锁。 事务1和事务2在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有 两种策略 ：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout 来设置。 </li>
<li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务（将持有最少行级排他锁的事务进行回滚），让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为on ，表示开启这个逻辑。 </li>
</ul>
<p><strong>第二种策略的成本分析</strong></p>
<p>方法一：<strong>如果你确保这个业务一定不会出现死锁，可以把死锁检测关掉。</strong>但是这种操作本身带有一定的风险，因为业务涉及的时候一般不会把死锁当作一个严重错误，毕竟出现了死锁，就回滚，然后通过业务重试一般就没问题，这是<strong>业务无损</strong>的。而关掉死锁检测意味着可能会出现大量超时，这是<strong>业务有损</strong>。</p>
<p>方法二：控制并发度。如果并发能够控制住，比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题</p>
<blockquote>
<p>产生死锁条件</p>
</blockquote>
<ol>
<li>两个或两个以上事务</li>
<li>每个事务都已经持有锁并且申请新的锁</li>
<li>锁资源同时只能被同一个事务持有或者不兼容</li>
<li>事务之间因为持有锁和申请锁导致彼此循环等待</li>
</ol>
<p><strong>死锁的关键在于两个(或以上)的session加锁顺序不一致</strong></p>
<blockquote>
<p>如何处理死锁</p>
</blockquote>
<p><strong>方式一</strong>等待，知道超时(innodb_lock_wait_timeout=50s).</p>
<p>即当两个事务互相等待时，当一个事务等待时间超过设置的阈值时，就将其回滚，另外事务继续进行。这种方法简单有效，在innodb中，参数innodb_lock_wait_timeoput用来设置超时时间。</p>
<p>缺点：对于在线服务来说，这个等待时间往往是无法接受的</p>
<p>那就将此值修改短一些，比如1s，0.1s是否合适？不合适，容易误伤到普通锁的等待</p>
<p><strong>方式二</strong>使用死锁检测进行死锁处理。</p>
<p>方式一检测死锁太过被动，innodb还提供了wait-for graph算法来主动进行死锁检测，每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法就会被出发。</p>
<p>这是一种较为主动的死锁检测机制，要求数据库保存锁的信息链表和事务等待链表两部分信息。<img src="/2022/04/22/MySQL/1651758403654.png" alt="1651758403654" loading="lazy"></p>
<p>基于这两个信息，可以绘制wait-for graph（等待图）<img src="/2022/04/22/MySQL/1651758478245.png" alt="1651758478245" loading="lazy"></p>
<p><strong>死锁检测的原理是构建一个以事务为顶点，锁为边的有向图，判断有向图是否存在环，存在即有死锁</strong></p>
<p>一旦检测到回路、有死锁，这时候InnoDB存储引擎会选择回滚<strong>undo量最小的事务</strong>，让其他事务继续执行（innodb_deadlock_detect=on表示开启这个逻辑）</p>
<p>缺点：每个新的被阻塞的线程，都要判断是不是由于自己的加入导致了死锁，这个操作时间复杂度是O(n)。如果100并发线程同时更新同一行，意味着要检测100*100=1万次，1万个线程就会有1千万次检测。</p>
<p><strong>如何解决？</strong></p>
<ul>
<li>方式1：关闭死锁检测，但意味着可能会出现大量的超时，会导致业务有损</li>
<li>方式2：控制并发访问的数量。比如在中间件中实现相对于相同行的更新，在进入引擎之前排队，这样在InnoDB内部就不会有大量的死锁检测工作</li>
</ul>
<p><strong>进一步的思考</strong></p>
<p>可以考虑通过将一行改成逻辑上的多行来减少锁冲突。比如，连锁超市总额的记录，可以考虑放到多条记录上。账户总额等于这多个记录的值的总和。</p>
<blockquote>
<p>如何避免死锁</p>
</blockquote>
<ul>
<li>合理设计索引，使业务定位更少的行，减少锁冲突</li>
<li>调整业务逻辑sql执行顺序，避免upadte/delete长时间持有锁的sql在事务前面。</li>
<li>避免大事务，尽量将大事务拆成小事务来处理，小事务缩短锁定资源的时间，发生锁冲突的概率减小。</li>
<li>在并发度高的系统中，不要显示加锁，特别是在事务里显示加锁。如elect…for update语句，如果是在事务里运行了start transaction或设置了autocommit等于0，那么就会锁定所查找到的记录。</li>
<li>降低隔离级别。如果业务允许，将隔离级别调低也是较好选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁</li>
</ul>
<h3 id="4-锁的内存结构"><a href="#4-锁的内存结构" class="headerlink" title="4.锁的内存结构"></a>4.锁的内存结构</h3><p>InnoDB存储引擎中的锁结构如下：<img src="/2022/04/22/MySQL/1651497979915.png" alt="1651497979915" loading="lazy"></p>
<p>结构分析：</p>
<ol>
<li>锁所在的事务信息 ： </li>
</ol>
<p>不论是 表锁 还是 行锁 ，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构 ，这里就记录这个 事务的信息。 </p>
<p>此 锁所在的事务信息 在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比 方说事务id等。 </p>
<ol start="2">
<li>索引信息 ： </li>
</ol>
<p>对于 行锁 来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。 </p>
<ol start="3">
<li>表锁／行锁信息 ： </li>
</ol>
<p>表锁结构 和 行锁结构 在这个位置的内容是不同的：</p>
<ul>
<li><p>表锁</p>
<p>记载着是对哪个表加的锁，还有一些其他信息</p>
</li>
<li><p>行锁</p>
<p>记载了三个重要的信息：</p>
<ul>
<li><p>Space ID：记录所在表空间</p>
</li>
<li><p>Page Number：记录所在页号</p>
</li>
<li><p>n_bits：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行结构的末尾放置了一堆比特位，这个n_bits属性代表使用了多少比特位</p>
<blockquote>
<p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后也不至于重新分配锁结构</p>
</blockquote>
</li>
</ul>
<p> 4.type_mode：</p>
</li>
</ul>
<p>这是一个32位的数，被分成lock_mode、lock_type、rec_lock_type三个部分，如图所示：<img src="/2022/04/22/MySQL/1651498396421.png" alt="1651498396421" loading="lazy"></p>
<ul>
<li>锁的模式(lock_mode)，占用低4位，可选的值如下：<ul>
<li>LOCK_IS （十进制的 0 ）：表示共享意向锁，也就是 IS锁 。</li>
<li>LOCK_IX （十进制的 1 ）：表示独占意向锁，也就是 IX锁 。 </li>
<li>LOCK_S （十进制的 2 ）：表示共享锁，也就是 S锁 。 </li>
<li>LOCK_X （十进制的 3 ）：表示独占锁，也就是 X锁 。 </li>
<li>LOCK_AUTO_INC （十进制的 4 ）：表示 AUTO-INC锁 。 </li>
</ul>
</li>
</ul>
<p>在InnoDB存储引擎中，LOCK_IS、LOCK_IX、LOCK_WUTO_INC都算是表级锁的模式，LOCK_S和LOCK_X既可以算是表级锁的模式，也可以是行级锁</p>
<ul>
<li>锁的类型（lock_type）,占用第5-8位，不过现阶段只有第5位和第6位被使用；<ul>
<li>LOCK_TABLE(十进制的16)，也就是当第5个比特位置为1时，表示表级锁</li>
<li>LOCK_REC （十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁。</li>
</ul>
</li>
<li>行的具体类型（rec_lock_type），使用其余的位来表示。只有在lock_type的值为LOCK_REC时，也就是说只有在该锁为行级锁时，才会被细分为更多类型：<ul>
<li>LOCK_ORDINARY （十进制的 0 ）：表示 next-key锁 。 </li>
<li>LOCK_GAP （十进制的 512 ）：也就是当第10个比特位置为1时，表示 gap锁 。 </li>
<li>LOCK_REC_NOT_GAP （十进制的 1024 ）：也就是当第11个比特位置为1时，表示正经 记录锁 。</li>
<li>LOCK_INSERT_INTENTION （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。 </li>
</ul>
</li>
<li>is_waiting 属性呢？基于内存空间的节省，所以把 is_waiting 属性放到了 type_mode 这个32位的数字中：<ul>
<li>LOCK_WAIT （十进制的 256 ） ：当第9个比特位置为 1 时，表示 is_waiting 为 true ，也 就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 0 时，表示 is_waiting 为 false ，也就是当前事务获取锁成功。 </li>
</ul>
</li>
</ul>
<p>5.其他信息：</p>
<p>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。 </p>
<p>6.一堆比特位：</p>
<p>如果是 行锁结构 的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的 n_bits 属性 表示的。InnoDB数据页中的每条记录在 记录头信息 中都包含一个 heap_no 属性，伪记录 Infimum 的 heap_no 值为 0 ， Supremum 的 heap_no 值为 1 ，之后每插入一条记录， heap_no 值就增1。 锁结 构 最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个 heap_no ，即一个比特位映射 到页内的一条记录。</p>
<h3 id="5-、锁监控"><a href="#5-、锁监控" class="headerlink" title="5.、锁监控"></a>5.、锁监控</h3><p>关于MySQL锁的监控，我们一般可以通过检查 InnoDB_row_lock 等状态变量来分析系统上的行锁的争夺情况 </p>
<p><img src="/2022/04/22/MySQL/1651499248866.png" alt="1651499248866" loading="lazy"></p>
<p>对各个状态量的说明如下： </p>
<ul>
<li>Innodb_row_lock_current_waits：当前正在等待锁定的数量； </li>
<li><strong>Innodb_row_lock_time</strong> ：从系统启动到现在锁定总时间长度；（等待总时长） </li>
<li><strong>Innodb_row_lock_time_avg ：</strong>每次等待所花平均时间；（等待平均时长） </li>
<li>Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间； </li>
<li><strong>Innodb_row_lock_waits</strong> ：系统启动后到现在总共等待的次数；（等待总次数）</li>
</ul>
<p>对于这5个变量，比较重要的是上面三个（加粗）</p>
<p><strong>其他监控方法：</strong></p>
<p>MySQL把事务和锁的信息记录在了 information_schema 库中，涉及到的三张表分别是 INNODB_TRX 、 INNODB_LOCKS 和 INNODB_LOCK_WAITS 。 </p>
<p>MySQL5.7及之前 ，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。 </p>
<p>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了 performance_schema.data_locks ，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。同时，information_schema.INNODB_LOCK_WAITS也被 performance_schema.data_lock_waits 所代替。</p>
<p>我们模拟一个锁等待的场景，以下是从这三张表收集的信息；锁等待场景，依然使用记录锁中的案例，当事务2进行等待时，查询情况如下：</p>
<p>（1）查询正在被锁阻塞的sql语句。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.INNODB_TRX\G;</span><br></pre></td></tr></table></figure>

<p>（2）查询锁等待情况<img src="/2022/04/22/MySQL/1651558597258.png" alt="1651558597258" loading="lazy"></p>
<p><img src="/2022/04/22/MySQL/1651558603939.png" alt="1651558603939" loading="lazy"></p>
<p>（3）查询锁的情况</p>
<p><img src="/2022/04/22/MySQL/1651558638351.png" alt="1651558638351" loading="lazy"></p>
<p><img src="/2022/04/22/MySQL/1651558648806.png" alt="1651558648806" loading="lazy"></p>
<p>从锁的情况可以看出来，两个事务分别获取了IX锁，我们从意向锁章节可以知道，IX锁互相时兼容的。所以这里不会等待，但是事务1同样持有X锁，此时事务2也要去同一行记录获取X锁，他们之间不兼容，导致等待的情况发生。</p>
<h3 id="6-间歇锁加锁规则（11案例）"><a href="#6-间歇锁加锁规则（11案例）" class="headerlink" title="6.间歇锁加锁规则（11案例）"></a>6.间歇锁加锁规则（11案例）</h3><p>间隙锁是在可重复读隔离级别下才会生效的： </p>
<p>next-key lock 实际上是由间隙锁加行锁实现的，如果切换到读提交隔离级别 (read-committed) 的话，就好理解了，过程中去掉间隙锁的部分，也就是只剩下行锁的部分。而在读提交隔离级别下间隙锁就没有了，为了解决可能出现的数据和日志不一致问题，需要把binlog 格式设置为 row 。也就是说，许多公司的配置为：读提交隔离级别加 binlog_format=row。业务不需要可重复读的保证，这样考虑到读提交下操作数据的锁范围更小（没有间隙锁），这个选择是合理的。</p>
<p>next-key lock的加锁规则，包含两个“原则”、两个“优化”和一个“bug”</p>
<p>1.原则1：加锁的基本单位是next-key lock。前开后闭区间</p>
<p>2.原则2：查找过程中访问到的对象才会加锁。任何辅助索引上的锁，或者非索引列上的锁，最终都要回溯到主键上，在主键上也要加一把锁</p>
<p>3.优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock会退化为行锁。也就是说如果InnoDB扫描的是一个主键或者一个唯一索引的话，只会采用行锁方式加锁。</p>
<p>4.优化2：索引上（不一定是唯一索引）的等值查询，向右遍历的时候且最后一个值不满足等值条件时，next-key lock退化为间歇锁</p>
<p>5.一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p>
<p>以表test为例，建表语句及初始化如下：id为主键索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test` (</span><br><span class="line">`id` int(11) NOT NULL,</span><br><span class="line">`col1` int(11) DEFAULT NULL,</span><br><span class="line">`col2` int(11) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">insert into test values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure>

<h4 id="案例一：唯一索引等值查询间歇锁"><a href="#案例一：唯一索引等值查询间歇锁" class="headerlink" title="案例一：唯一索引等值查询间歇锁"></a>案例一：唯一索引等值查询间歇锁<img src="/2022/04/22/MySQL/1651559606567.png" alt="1651559606567" loading="lazy"></h4><p>由于表test中没有id=7的记录，根据原则1，加锁单位是next-key lock，sessionA加锁范围就是(5,10]；同时根据优化2，这是一个等值查询(id=7)，而id=10不满足查询条件，next-key lcok退化成间歇锁，因此最终加锁范围是(5,10)</p>
<h4 id="案例二：非唯一索引等值查询锁"><a href="#案例二：非唯一索引等值查询锁" class="headerlink" title="案例二：非唯一索引等值查询锁"></a>案例二：非唯一索引等值查询锁<img src="/2022/04/22/MySQL/1651560453447.png" alt="1651560453447" loading="lazy"></h4><p>这里sessionA要给索引col1上col1=5的这一行加上读锁。</p>
<p>1.根据原则1，加锁单位是next-key lock，左开有闭，5是闭上的，因此会给(0,5]加上next-key lock</p>
<p>2.要注意c是普通索引，因此仅访问次这一条记录是不能停下的（可能有col1=5的其他记录），需要继续向右遍历，查到c=10才放弃。根据原则2，访问到的对象都要加锁，因此要给(5，10]加上next-key lock</p>
<p>3.但是同时这个符合优化2：等值判断，向右遍历，最后一个不满足col1=5这个等值条件，因此退化成间歇锁(5,10)。</p>
<p>4.根据原则2，只有访问到的对象才会加锁，这个查询使用这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引没有加任何锁，这就是为什么sessionB可以完成的原因</p>
<p>但sessionC要插入一个（7，7，7）的记录，就会被sessionA的间歇锁（5，10）锁住，这个例子说明锁加载索引上的。</p>
<p>执行for update时，系统会认为接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</p>
<p>如果要使用lock in share mode来给行加读锁避免数据被更新的话，就必须绕过覆盖索引的优化，因为覆盖索引的优化不会访问主键索引，不会给主键索引加锁</p>
<h4 id="案例三：主键索引范围查询锁"><a href="#案例三：主键索引范围查询锁" class="headerlink" title="案例三：主键索引范围查询锁"></a>案例三：主键索引范围查询锁</h4><p>上面两个例子是等值查询的，这个例子是关于范围查询的，也就是说下面的语句 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from test where id=10 for update</span><br><span class="line">select * from test where id&gt;=10 and id&lt;11 for update;</span><br></pre></td></tr></table></figure>

<p>这两条语句肯定等价，但他们的加锁规则不太一样<img src="/2022/04/22/MySQL/1651561526629.png" alt="1651561526629" loading="lazy"></p>
<p>1.开始执行的时候，要找到第一个id=10的行，因此本该是next-key lock(5,10]，但根据优化1，主键id上的等值条件，退化成行锁，只加了id=10这一条的行锁。</p>
<p>2.它是范围查询，范围查询就往后继续找，知道找到id=15这一行停下来，不满足条件，因此需要加next-key lcok(10,15].</p>
<p>sessionA这时候锁上的范围就是主键索引上，行锁id=10和next-key lcok(10,15]。<strong>首次sessionA定位查找id=10的行时，是当作等值查询来判断的，而向右扫描到id=15时，用的是范围查询判断</strong></p>
<h4 id="案例四：非唯一索引范围查询锁"><a href="#案例四：非唯一索引范围查询锁" class="headerlink" title="案例四：非唯一索引范围查询锁"></a>案例四：非唯一索引范围查询锁</h4><p>与案例三不同的是，案例四中查询语句的 where 部分用的是字段 c ，它是普通索引 </p>
<p>这两条查语句肯定是等价的，但是它们的加锁规则不太一样 <img src="/2022/04/22/MySQL/1651561876661.png" alt="1651561876661" loading="lazy"></p>
<p>在第一次用col1=10定位记录时，索引c上加了(5,10]这个next-key lock后，由于索引col1是非唯一索引，没有优化规则，也就是说不会蜕变为行锁。因此最终sessionA加的锁是，索引c上的(5,10]和(10,15]这两个next-key lock</p>
<p>这里需要扫描到col1=15才停止扫描，是合理的。因为InnoDB要扫描到col1=15，才知道不需要继续往后找了。</p>
<h4 id="案例五：唯一索引范围查询-bug"><a href="#案例五：唯一索引范围查询-bug" class="headerlink" title="案例五：唯一索引范围查询 bug"></a>案例五：唯一索引范围查询 bug</h4><p><img src="/2022/04/22/MySQL/1651562209398.png" alt="1651562209398" loading="lazy"></p>
<p>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15] 这个 next-key lock ，并且因为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了。 </p>
<p>但是实现上， InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20 。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上。照理说，这里锁住 id=20 这一行的行为，其实是没有必要的。因为扫描到 id=15 ，就可以确定不用往后再找了。 </p>
<h4 id="案例六：非唯一索引上存在“等值”的例子"><a href="#案例六：非唯一索引上存在“等值”的例子" class="headerlink" title="案例六：非唯一索引上存在“等值”的例子"></a>案例六：非唯一索引上存在“等值”的例子</h4><p>这里，我给表 t 插入一条新记录：insert into t values(30,10,30);也就是说，现在表里面有两个c=10的行 </p>
<p><strong>但是它们的主键值</strong> <strong>id</strong> <strong>是不同的（分别是</strong> <strong>10</strong> <strong>和</strong> <strong>30</strong> <strong>），因此这两个****c=10</strong> <strong>的记录之间，也是有间隙的。</strong></p>
<p><img src="/2022/04/22/MySQL/1651562471166.png" alt="1651562471166" loading="lazy">这次我们用 delete 语句来验证。注意， delete 语句加锁的逻辑，其实跟 select … for update 是类似的，也就是我在文章开始总结的两个 “ 原则 ” 、两个 “ 优化 ” 和一个 “bug” 。 </p>
<p>这时， session A 在遍历的时候，先访问第一个 col1=10 的记录。同样地，根据原则 1 ，这里加的是 (col1=5,id=5) 到 (col1=10,id=10) 这个 next-key lock 。 </p>
<p>由于c是普通索引，所以继续向右查找，直到碰到 (col1=15,id=15) 这一行循环才结束。根据优化 2 ，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成 (col1=10,id=10) 到 (col1=15,id=15) 的间隙锁。<img src="/2022/04/22/MySQL/1651562707743.png" alt="1651562707743" loading="lazy"></p>
<p>这个 delete 语句在索引 c 上的加锁范围，就是上面图中蓝色区域覆盖的部分。这个蓝色区域左右两边都是虚线，表示开区间，即 (col1=5,id=5) 和 (col1=15,id=15) 这两行上都没有锁</p>
<h4 id="案例七：limit语句加锁"><a href="#案例七：limit语句加锁" class="headerlink" title="案例七：limit语句加锁"></a>案例七：limit语句加锁</h4><p><img src="/2022/04/22/MySQL/1651562819770.png" alt="1651562819770" loading="lazy"></p>
<p>session A 的 delete 语句加了 limit 2 。你知道表 t 里 c=10 的记录其实只有两条，因此加不加 limit 2 ，删除的效果都是一样的。但是加锁效果却不一样</p>
<p>这是因为，案例七里的 delete 语句明确加了 limit 2 的限制，因此在遍历到 (col1=10, id=30) 这一行之后， </p>
<p>满足条件的语句已经有两条，循环就结束了。因此，索引 col1 上的加锁范围就变成了从（col1=5,id=5)到（col1=10,id=30) 这个前开后闭区间，如下图所示： <img src="/2022/04/22/MySQL/1651562846169.png" alt="1651562846169" loading="lazy"></p>
<p>这个例子对我们实践的指导意义就是，在删除数据的时候计量加limit</p>
<p>这样不仅<strong>可以控制删除数据的条数，让操作更方便，还可以缩小加锁范围</strong></p>
<h4 id="案例八：一个死锁的例子"><a href="#案例八：一个死锁的例子" class="headerlink" title="案例八：一个死锁的例子"></a>案例八：一个死锁的例子</h4><p><img src="/2022/04/22/MySQL/1651562944756.png" alt="1651562944756" loading="lazy"></p>
<p>1.sessionA启动事务后执行查询语句加lock in share mode，在索引上加了next-key lock(5,10]和间歇锁(10,15)(索引向右遍历退化为间歇锁)</p>
<p>2.session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待； 实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 col1=10 的行锁，因为sessionA上已经给这行加上了读锁，此时申请死锁时会被阻塞 </p>
<p>3.然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁， InnoDB 让session B 回滚</p>
<h4 id="案例九：order-by索引排序的间歇锁1"><a href="#案例九：order-by索引排序的间歇锁1" class="headerlink" title="案例九：order by索引排序的间歇锁1"></a>案例九：order by索引排序的间歇锁1</h4><p>如下面一条语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test where id&gt;9 and id&lt;12 order by id desc for update;</span><br></pre></td></tr></table></figure>

<p>下图为这个表的索引id的示意图<img src="/2022/04/22/MySQL/1651563249209.png" alt="1651563249209" loading="lazy"></p>
<ol>
<li>首先这个查询语句的语义是order by id desc，要拿到满足条件的所有行，优化器必须先找到“第一个id&lt;12的值”</li>
<li>这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到id=12的这个值，只是最终没找到，但找到了（10，15）这个间隙（id=15不满足条件，所以next-key lock退化为间隙锁（10，15））</li>
<li>然后向左遍历，在过程中，就不是等值查询了，会扫描到id=5这一行，又因为区间是左闭右开的，所以会加一个next-key lock(,5]。也就是说，通过树搜索的方法定位记录的时候，用的是等值查询</li>
</ol>
<h4 id="案例十：order-by索引排序的间隙锁2"><a href="#案例十：order-by索引排序的间隙锁2" class="headerlink" title="案例十：order by索引排序的间隙锁2"></a>案例十：order by索引排序的间隙锁2</h4><p><img src="/2022/04/22/MySQL/1651827877071.png" alt="1651827877071" loading="lazy"></p>
<p>1.由于是order by col1 desc，第一个定位的是col1上最右边的col1=20的行。这是一个非唯一索引的等值查询：</p>
<p>左开右闭区间，首先加上 next-key lock (15,20] 。 向右遍历，col1=25不满足条件，退化为间隙锁 所以会加上间隙锁(20,25) 和 next-key lock (15,20] 。</p>
<p>2.在索引 col1 上向左遍历，要扫描到 col1=10 才停下来。同时又因为左开右闭区间，所以 next-keylock 会加到 (5,10] ，这正是阻塞session B 的 insert 语句的原因。</p>
<p>3.在扫描过程中， col1=20 、 col1=15 、 col1=10 这三行都存在值，由于是 select * ，所以会在主键id 上加三个行锁。 因此， session A 的 select 语句锁的范围就是：</p>
<ol>
<li><p>索引 col1 上 (5, 25) ； </p>
</li>
<li><p>主键索引上 id=15 、 20 两个行锁。 </p>
</li>
</ol>
<h4 id="案例十一：update修改数据的例子-先插入后删除"><a href="#案例十一：update修改数据的例子-先插入后删除" class="headerlink" title="案例十一：update修改数据的例子-先插入后删除"></a>案例十一：update修改数据的例子-先插入后删除</h4><p><img src="/2022/04/22/MySQL/1651828065888.png" alt="1651828065888" loading="lazy"></p>
<p>注意：根据 col1&gt;5 查到的第一个记录是 col1=10 ，因此不会加 (0,5] 这个 next-key lock 。 </p>
<p>session A 的加锁范围是索引 col1 上的 (5,10] 、 (10,15] 、 (15,20] 、 (20,25] 和(25,supremum] 。 </p>
<p>之后 session B 的第一个 update 语句，要把 col1=5 改成 col1=1 ，你可以理解为两步： </p>
<ol>
<li><p>插入 (col1=1, id=5) 这个记录； </p>
</li>
<li><p>删除 (col1=5, id=5) 这个记录。 </p>
</li>
</ol>
<p>通过这个操作， session A 的加锁范围变成了图 7 所示的样子：<img src="/2022/04/22/MySQL/1651828226607.png" alt="1651828226607" loading="lazy"></p>
<p>接下来 session B 要执行 update t set col1 = 5 where col1 = 1 这个语句了，一样地可以拆成两步： </p>
<ol>
<li><p>插入 (col1=5, id=5) 这个记录； </p>
</li>
<li><p>删除 (col1=1, id=5) 这个记录。 第一步试图在已经加了间隙锁的 (1,10) 中插入数据，所以就被堵住了。</p>
</li>
</ol>
<h2 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h2><h3 id="1-前提概要"><a href="#1-前提概要" class="headerlink" title="1.前提概要"></a>1.前提概要</h3><h4 id="1-什么是MVCC？"><a href="#1-什么是MVCC？" class="headerlink" title="1.什么是MVCC？"></a>1.什么是MVCC？</h4><p>MVCC（Multi-Version Consurrency Controller），即多版本并发控制。顾名思义，MVCC是通过数据行的多个版本管理来实现数据库的<strong>并发控制</strong>这项技术使得在InnoDB的事务隔离级别下执行一致性读操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以被更新之前的值，这样查询的时候就不用等待另一个事务释放锁。</p>
<blockquote>
<p>MVCC在InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读</p>
</blockquote>
<h4 id="2-当前读和快照读"><a href="#2-当前读和快照读" class="headerlink" title="2.当前读和快照读"></a>2.当前读和快照读</h4><ul>
<li>MVCC可以做到即使有读写冲突时，也可以<strong>不加锁、非阻塞读</strong>，而这个读指的是<strong>快照读</strong>，而不是<strong>当前读</strong>。当前读实际上是一种加锁的操作，是悲观锁的实现，而MVCC是采用乐观锁思想的一种方式。</li>
</ul>
<h5 id="2-1快照读"><a href="#2-1快照读" class="headerlink" title="2.1快照读"></a>2.1快照读</h5><p>快照读又叫一致性读，读取的是快照数据。<strong>不加锁的简单的SELECT都属于快照读</strong>，即不加锁的非阻塞读；比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM player WHERE ...</span><br></pre></td></tr></table></figure>

<p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，他在很多情况下，避免加锁操作，降低了开销。</p>
<p>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前历史版本。</p>
<p>快照读的<strong>前提是隔离级别不是串行级别</strong>，串行级别下的快照读会退化为当前读。</p>
<h5 id="2-2当前读"><a href="#2-2当前读" class="headerlink" title="2.2当前读"></a>2.2当前读</h5><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前事务，会对读取的记录进行加锁。加锁的SELECT，或者对数据进行增删改都会进行当前读。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student LOCK IN SHARE MODE;#共享锁</span><br><span class="line">SELECT * FROM student FOR UPDATE;#排他锁</span><br><span class="line">SELECT * INTO student VALUES...;#排他锁</span><br><span class="line">SELECT * FROM srudent WHERE ...;#排他锁</span><br><span class="line">UPDATE student SET ...;#排他锁</span><br></pre></td></tr></table></figure>

<h4 id="3-当前读、快照读和MVCCC的关系"><a href="#3-当前读、快照读和MVCCC的关系" class="headerlink" title="3.当前读、快照读和MVCCC的关系"></a>3.当前读、快照读和MVCCC的关系</h4><ul>
<li>MVCC并发控制是<strong>维持一个数据的多个版本，使得读写操作没有冲突</strong>的概念，只是一个抽象概念，并非实现</li>
<li>因为MVCC只是一个抽象概念，要实现这个概念，MySQL就需要提供具体的功能去实现它，<strong>快照读就是MySQL实现MVCC理想模型的其中一个非阻塞读功能</strong>。而当前读就是悲观锁的具体功能实现</li>
<li>要说的再细致一些，快照读本身也是一个抽象概念，再深入研究，MVCC模型在MySQL中的具体实现是由<strong>3个隐式字段、uno日志、read View等去完成的</strong>。</li>
</ul>
<h3 id="2-MVCC能解决什么问题？好处？"><a href="#2-MVCC能解决什么问题？好处？" class="headerlink" title="2.MVCC能解决什么问题？好处？"></a>2.MVCC能解决什么问题？好处？</h3><p><strong>数据库并发场景分三种，分别为：</strong></p>
<ul>
<li>读-读：不存在任何问题，也不需要并发控制</li>
<li>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读、幻读、不可重复读</li>
<li>写-写：有线程安全问题，可能会存在更新丢失问题。</li>
</ul>
<p><strong>带来的好处：</strong></p>
<p>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库快照。所以MVCC可以为数据库解决以下问题：</p>
<ul>
<li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</li>
<li>同时还可以解决脏读、幻读、不可重复读等事务隔离问题，但不能解决更新丢失问题</li>
</ul>
<p>因此我们可以形成两个组合：</p>
<ul>
<li><p>MVCC+悲观锁</p>
<p>MVCC解决读写冲突，悲观锁解决写写冲突</p>
</li>
<li><p>MVCC+乐观锁</p>
<p>MVCC解决读写冲突，乐观锁解决写写冲突</p>
</li>
</ul>
<h3 id="3-MVCC实现原理"><a href="#3-MVCC实现原理" class="headerlink" title="3.MVCC实现原理"></a>3.MVCC实现原理</h3><h4 id="3-1前提知识"><a href="#3-1前提知识" class="headerlink" title="3.1前提知识"></a>3.1前提知识</h4><h5 id="1-再谈隔离级别"><a href="#1-再谈隔离级别" class="headerlink" title="1.再谈隔离级别"></a>1.再谈隔离级别</h5><p>事务由四个隔离级别，可能存在3种并发问题：<img src="/2022/04/22/MySQL/1651886095147.png" alt="1651886095147" loading="lazy"></p>
<p><img src="/2022/04/22/MySQL/1651886137530.png" alt="1651886137530" loading="lazy"></p>
<h5 id="2-隐藏字段、undo-log版本链"><a href="#2-隐藏字段、undo-log版本链" class="headerlink" title="2.隐藏字段、undo log版本链"></a>2.隐藏字段、undo log版本链</h5><blockquote>
<p>隐式字段</p>
</blockquote>
<p>每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段</p>
<ul>
<li><p>DB_TRX_ID</p>
<p>6 byte，最近修改（修改/插入）事务ID：记录创建这条记录/最后一次修改该记录的事务ID</p>
</li>
<li><p>DB_ROLL_PTR</p>
<p>7 byte，回滚指针，指向这条记录的上一个版本（存储在rollback segment里）</p>
</li>
<li><p>DB_ROW_ID</p>
<p>6 byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</p>
</li>
<li><p>实际上还有一个删除flag隐藏字段，既记录被更新或删除并不代表真的删除，而是删除flag变了。</p>
</li>
</ul>
<p><img src="/2022/04/22/MySQL/1651886935823.png" alt="1651886935823" loading="lazy"></p>
<p>如上图，DB_ROW_ID是数据库默认为该记录生成的唯一主键，DB_TRX_ID是当前操作该记录的事务ID，而DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向当前记录上一个版本。</p>
<blockquote>
<p>undo日志</p>
</blockquote>
<p>undo log主要分为两种：</p>
<ul>
<li><p>insert undo log</p>
<p>代表事务在insert新纪录时产生的undo log，只在事务回滚时需要，并且在事务提交后可以立即被丢弃</p>
</li>
<li><p>update undo log</p>
<p>事务在进行update或delete时产生的undo log；不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快照读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</p>
</li>
</ul>
<blockquote>
<p>purge</p>
<ul>
<li>从前面的分析可以看出，为了实现 InnoDB 的 MVCC 机制，更新或者删除操作都只是设置一下老记录的 deleted_bit ，并不真正将过时的记录删除。</li>
<li>为了节省磁盘空间，InnoDB 有专门的 purge 线程来清理 deleted_bit 为 true 的记录。为了不影响 MVCC 的正常工作，purge 线程自己也维护了一个read view（这个 read view 相当于系统中最老活跃事务的 read view ）;如果某个记录的 deleted_bit 为 true ，并且 DB_TRX_ID 相对于 purge 线程的 read view 可见，那么这条记录一定是可以被安全清除的。</li>
</ul>
</blockquote>
<p>对MVCC有帮助的实质是update undo log，undo log实际上存在<strong>rollback segment</strong>中旧纪录链，执行流程如下：</p>
<p>1.<strong>比如一个有个事务插入 persion 表插入了一条新记录，记录如下，<code>name</code> 为 Jerry , <code>age</code> 为 24 岁，<code>隐式主键</code>是 1，<code>事务 ID</code>和<code>回滚指针</code>，我们假设为 NULL</strong> </p>
<p><img src="/2022/04/22/MySQL/1651888551880.png" alt="1651888551880" loading="lazy"></p>
<p>2.<strong>现在来了一个<code>事务 1</code>对该记录的 <code>name</code> 做出了修改，改为 Tom</strong> 。</p>
<ul>
<li>在事务1修改该行数据时，数据库会先对该行加排他锁</li>
<li>然后把该行数据拷贝到undo log中，作为旧纪录，即在undo log中有当前行的副本</li>
<li>拷贝完后，修改改行的name为Tom，并且隐藏字段的事务ID为当前事务1的ID，默认从1开始，之后递增，回滚指针指向拷贝到undo log的副本记录，即表示上一个版本是它</li>
<li>事务提交后，释放锁</li>
</ul>
<p><img src="/2022/04/22/MySQL/1651888559444.png" alt="1651888559444" loading="lazy"></p>
<p>3**.又来了个事务2修改person表的同一个记录，将age修改为30岁**</p>
<ul>
<li>在事务2修改该行数据时，数据库也为该行加锁</li>
<li>然后把该行数据拷贝到undo log中，作为旧纪录，发现该行记录已有undo log了，那么最新的旧数据作为链表的表头，插在该行记录的undo log最前面</li>
<li>修改该行记录age为30，并且修改隐藏字段的事务ID为当前事务2的ID，回滚指针指向刚刚拷贝到undo log的副本记录</li>
<li>事务提交，释放锁</li>
</ul>
<p><img src="/2022/04/22/MySQL/1651890657023.png" alt="1651890657023" loading="lazy"></p>
<p>从上面，可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，即链表，undo log的链表首部就是最新的旧纪录，链表尾部就是最早的旧纪录</p>
<h4 id="3-2实现原理之ReadView"><a href="#3-2实现原理之ReadView" class="headerlink" title="3.2实现原理之ReadView"></a>3.2实现原理之ReadView</h4><p>MVCC的实现依赖于：隐藏字段、undo log、readview</p>
<hr>
<h5 id="什么是ReadView"><a href="#什么是ReadView" class="headerlink" title="什么是ReadView"></a>什么是ReadView</h5><p>readview就是事务进行快照读操作的时候，产生的读视图（ReadView），在该事务执行到快照读那一刻，会生成一个数据库当前的一个快照，记录并维护当前活跃的事务的ID（当每个事务开启时，都会被分配一个ID，这个ID是递增的，所以最新的事务，ID值最大）</p>
<p>所以我们知道了ReadView是用来做可进行判断的，即当我们某个事务执行快照读时。为该记录创建一个系统的ReadView读视图，将其作为判断当前事务能够看到哪个版本的数据，即可能是最新的也可能是历史版本的数据。</p>
<h5 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h5><p>使用READ UNCOMMITED（读未提交）隔离级别的事务，可以读到未提交事务修改过的记录，所以直接读取最新版本</p>
<p>使用SERIALIZABLE（串行化）隔离级别的事务，InnoDB规定使用加锁方式访问记录</p>
<p>使用READ COMMITED（读提交）和REPREATABLE READ（可重复读）隔离级别的事务，都必须保证读到已提交了的事务修改过的记录。假如另一个事务已经修改了记录但尚未提交，是不能读取到最新版本的记录的，<strong>核心问题在于需要判断一下版本链中哪个版本是当前事务可见的这是ReadView主要解决的问题</strong></p>
<p><strong>ReadView</strong>遵循一个可进行算法，主要是将<strong>要被修改的数据</strong>的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID对比（由ReadView维护），如果DB_TRX_ID跟Read View的属性做了比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出undo log中的DB_TRX_ID再比较，既遍历链表的DB_TRX_ID（从链表首到链表尾，即从最近一次查起），直到找到满足特定条件的DB_TRX_ID，那么<strong>这个DB_TRX_ID所在记录就是当前事务能看见的最新老版本</strong></p>
<p>ReadView中主要包含4个比较重要的内容：</p>
<ol>
<li><p><strong>creator_trx_id</strong>，创建这个Read View的事务ID。</p>
</li>
<li><p><strong>trx_ids</strong>，表示在生成Read View时，当前系统中活跃的事务id列表</p>
</li>
<li><p>up_limit_id，活跃的事务中最小的事务ID</p>
</li>
<li><p>low_limit_id，表示生成ReadView时系统中下一个事务应该分配事务ID，也就是目前已出现过的事务ID的最大值+1。low_lmit_id是系统最大的事务ID值，需要注意的是系统中的事务ID，需要区别于正在活跃的事务ID。</p>
<blockquote>
<p>注意：low_limit_id并不是trx_ids最大值，事务id是递增分配的比如，现在有id为1，2，3这三个事务，之后id为3的事务提交了，那么一个新的事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4.</p>
</blockquote>
</li>
</ol>
<h5 id="ReadView的规则"><a href="#ReadView的规则" class="headerlink" title="ReadView的规则"></a>ReadView的规则</h5><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见</p>
<ul>
<li>如果被访问版本 的<strong>DB_TRX_ID</strong>值与ReadView中的<strong>creator_limit_id</strong>值相同，意味着当前事务在访问他自己修改过的记录，所以该版本可以被当前事务看见</li>
<li>如果被访问版本的<strong>DB_TRX_ID&lt;up_limit_id</strong>,表明生成该版本的事务在当前事务生成ReadView前已经提交，所以当前版本可以被当前事务访问</li>
<li>如果被访问版本的<strong>DB_TRX_ID&gt;=low_limit_id</strong>表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可被当前事务访问</li>
<li>如果被访问版本的<strong>DB_TRX_ID的值在up_limit_id和low_limit_id之间</strong>就需要判断DB_TRX_ID是否在trx_ids列表中；<ul>
<li>如果在，说明创建ReadView时生成该版本的事务还活跃，该版本不可访问</li>
<li>如果不在，说明创建ReadView时生成该版本的事务已经提交，该版本呢可以访问</li>
</ul>
</li>
</ul>
<h4 id="3-3整体流程"><a href="#3-3整体流程" class="headerlink" title="3.3整体流程"></a>3.3整体流程</h4><p>当我们查询一条记录时，系统通过MVCC查找步骤：</p>
<ol>
<li>首先获取事务自己的事务ID</li>
<li>获取ReadView</li>
<li>查询得到的数据，然后与ReadView中事务的版本号进行比较</li>
<li>如果不符合ReadView谷规则，就需要从undo log中获取历史快照</li>
<li>最后返回符合规则的数据</li>
</ol>
<blockquote>
<p>举个例子</p>
</blockquote>
<ul>
<li><p>当事务 2对某行数据执行了快照读，数据库为该行数据生成一个Read View读视图，假设当前事务 ID 为 2，此时还有事务1和事务3在活跃中，事务 4在事务 2快照读前一刻提交更新了，所以 Read View 记录了系统当前活跃事务 1，3 的 ID，维护在一个列表上，假设我们称为trx_ids<img src="/2022/04/22/MySQL/1651908943761.png" alt="1651908943761" loading="lazy"></p>
</li>
<li><p>Read View不仅仅会通过一个列表trx_ids来维护事务2执行快照读那刻系统正在活跃的事务ID，还有两个属性up_limit_id(trx_ids中事务ID最小的ID)，low_limit_id(快照读时刻系统下一个尚未分配的事务ID，也就是目前已出现过的事务ID的最大值+1)所以这里up_limit_id是1，low_limit_id是4+1=5，trx_ids的值是1，3，ReadView如图：<img src="/2022/04/22/MySQL/1651909261231.png" alt="1651909261231" loading="lazy"></p>
</li>
<li><p>我们的例子中，只有<strong>事务4</strong>修改过该行记录，并在事务2执行快照读前，就提交事务。所以当前该行数据的undo log如下图所示：我们的事务2在快照读该行记录的时候，就会拿该行记录的<strong>DB_TRX_ID</strong>去跟<strong>up_limit_id,low_limit_id</strong>和<strong>活跃事务ID列表（trx_ids）</strong>进行比较，判断当前事务2能看到该记录的版本是哪个<img src="/2022/04/22/MySQL/1651911811794.png" alt="1651911811794" loading="lazy"></p>
</li>
<li><p>所以先拿该记录 DB_TRX_ID 字段记录的事务 ID 4 去跟 Read View 的 up_limit_id 比较，看 4 是否小于 up_limit_id( 1 )，所以不符合条件，继续判断 4 是否大于等于 low_limit_id( 5 )，也不符合条件，最后判断 4 是否处于 trx_list 中的活跃事务, 最后发现事务 ID 为 4 的事务不在当前活跃事务列表中, 符合可见性条件，所以事务 4修改后提交的最新结果对事务 2 快照读时是可见的，所以事务 2 能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本<img src="/2022/04/22/MySQL/1651911900429.png" alt="1651911900429" loading="lazy"></p>
</li>
</ul>
<blockquote>
<p>正是由于ReadView生成的时机不同，从而造成RC,RR级别下快照读的结果不同</p>
</blockquote>
<p>在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次 Read View。</p>
<p><img src="/2022/04/22/MySQL/1651912021363.png" alt="1651912021363" loading="lazy"></p>
<p><strong>注意，此时同样的查询语句都会重新获取一次ReadView，这时如果ReadView不同，就可能产生不可重复度或幻读情况</strong></p>
<hr>
<p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会 </p>
<p>获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示： <img src="/2022/04/22/MySQL/1651912164535.png" alt="1651912164535" loading="lazy"></p>
<h3 id="4-举例说明"><a href="#4-举例说明" class="headerlink" title="4.举例说明"></a>4.举例说明</h3><h4 id="4-1READ-COMITED隔离级别"><a href="#4-1READ-COMITED隔离级别" class="headerlink" title="4.1READ COMITED隔离级别"></a>4.1READ COMITED隔离级别</h4><p>READ COMMITED:每次读取数据前都生成一个ReadView</p>
<p>现在有两个<strong>事务id</strong>分别为10、20的事务在执行：<img src="/2022/04/22/MySQL/1651912356028.png" alt="1651912356028" loading="lazy"></p>
<p>此刻，表student中id为1的记录得到的版本链表如下所示：<img src="/2022/04/22/MySQL/1651912394286.png" alt="1651912394286" loading="lazy"></p>
<p>假设现在有一个使用READ COMMITED隔离级别的事务开始执行：<img src="/2022/04/22/MySQL/1651912445005.png" alt="1651912445005" loading="lazy"></p>
<p>之后，我们把<strong>事务id</strong>为10的事务提交一下：<img src="/2022/04/22/MySQL/1651912521199.png" alt="1651912521199" loading="lazy"></p>
<p>然后再到事务id为20的事务中更新一下表student中id为1的记录：<img src="/2022/04/22/MySQL/1651912610232.png" alt="1651912610232" loading="lazy"></p>
<p>刺客，表student中id为1的记录的版本链就长成这样：<img src="/2022/04/22/MySQL/1651912651986.png" alt="1651912651986" loading="lazy"></p>
<p>然后再到刚才使用 READ COMMITTED 隔离级别的事务中继续查找这个 id 为 1 的记录，如下：<img src="/2022/04/22/MySQL/1651912669153.png" alt="1651912669153" loading="lazy"></p>
<h4 id="4-2REPEATABLE-READ隔离级别"><a href="#4-2REPEATABLE-READ隔离级别" class="headerlink" title="4.2REPEATABLE READ隔离级别"></a>4.2REPEATABLE READ隔离级别</h4><p>使用REPEATABLE READ隔离级别的事务来说，只会在第一次执行查询语句时生成一个ReadView，之后的查询就不会重复生成了。</p>
<p>比如，系统里有两个事务id分别为10、20的事务在执行：<img src="/2022/04/22/MySQL/1651912961466.png" alt="1651912961466" loading="lazy"></p>
<p>此刻，表student 中 id 为 1 的记录得到的版本链表如下所示：<img src="/2022/04/22/MySQL/1651912972253.png" alt="1651912972253" loading="lazy"></p>
<p>假设现在有一个使用 REPEATABLE READ 隔离级别的事务开始执行： <img src="/2022/04/22/MySQL/1651912982025.png" alt="1651912982025" loading="lazy"></p>
<p>之后，我们把 事务id 为 10 的事务提交一下，就像这样： <img src="/2022/04/22/MySQL/1651912991132.png" alt="1651912991132" loading="lazy"></p>
<p>然后再到 事务id 为 20 的事务中更新一下表 student 中 id 为 1 的记录： <img src="/2022/04/22/MySQL/1651913001481.png" alt="1651913001481" loading="lazy"></p>
<p>此刻，表student 中 id 为 1 的记录的版本链长这样： <img src="/2022/04/22/MySQL/1651913014989.png" alt="1651913014989" loading="lazy"></p>
<p>然后再到刚才使用 REPEATABLE READ 隔离级别的事务中继续查找这个 id 为 1 的记录，如下： <img src="/2022/04/22/MySQL/1651913025657.png" alt="1651913025657" loading="lazy"></p>
<h3 id="5-如何解决幻读"><a href="#5-如何解决幻读" class="headerlink" title="5.如何解决幻读"></a>5.如何解决幻读</h3><p>假设现在表student中只有一条数据，数据内容中，主键id=1，隐藏的DB_TRX_ID=10，它的undo log如下图所示。<img src="/2022/04/22/MySQL/1651913181475.png" alt="1651913181475" loading="lazy"></p>
<p>假设现在有事务A和事务B并发执行，事务A的事务id为20，事务B的事务id为30。</p>
<p>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where id &gt;= 1;</span><br></pre></td></tr></table></figure>

<p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下： trx_ids= [20,30] ， up_limit_id=20 ， low_limit_id=31 ， creator_trx_id=20 。 </p>
<p>由于此时表 student 中只有一条数据，且符合 where id&gt;=1 条件，因此会查询出来。然后根据 ReadView 机制，发现该行数据的trx_id=10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。 </p>
<p>结论：事务 A 的第一次查询，能读取到一条数据，id=1。 </p>
<p>步骤2：接着事务 B(trx_id=30)，往表 student 中新插入两条数据，并提交事务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into student(id,name) values(2,&#x27;李四&#x27;);</span><br><span class="line">insert into student(id,name) values(3,&#x27;王五&#x27;);</span><br></pre></td></tr></table></figure>

<p>此时表student 中就有三条数据了，对应的 undo 如下图所示： <img src="/2022/04/22/MySQL/1651913282692.png" alt="1651913282692" loading="lazy"></p>
<p>步骤3：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成 ReadView。此时表 student 中的 3 条数据都满足 where id&gt;=1 的条件，因此会先查出来。然后根据 ReadView 机制，判断每条数据是不是都可以被事务 A 看到。 </p>
<p>1）首先 id=1 的这条数据，前面已经说过了，可以被事务 A 看到。 </p>
<p>2）然后是 id=2 的数据，它的 trx_id=30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之 间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids=[20,30]，因此在数组内，这表 示 id=2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。 </p>
<p>3）同理，id=3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。</p>
<p><img src="/2022/04/22/MySQL/1651913320851.png" alt="1651913320851" loading="lazy"></p>
<p>结论：最终事务 A 的第二次查询，只能查询出 id=1 的这条数据。这和事务 A 的第一次查询的结果是一样 的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。 </p>
<h3 id="6-MVCC相关问题"><a href="#6-MVCC相关问题" class="headerlink" title="6.MVCC相关问题"></a>6.MVCC相关问题</h3><h4 id="RR如何在RC基础上解决不可重复读？"><a href="#RR如何在RC基础上解决不可重复读？" class="headerlink" title="RR如何在RC基础上解决不可重复读？"></a>RR如何在RC基础上解决不可重复读？</h4><p><strong>当前读和快照读在RR级别下的区别</strong></p>
<p>表1：<img src="/2022/04/22/MySQL/1651913686382.png" alt="1651913686382" loading="lazy"></p>
<p>在上表的顺序下，事务B的在事务A提交修改后的快照读是旧版本数据，而当前读是实时新数据400</p>
<p>表2：<img src="/2022/04/22/MySQL/1651913783543.png" alt="1651913783543" loading="lazy"></p>
<p>而在<strong>表2</strong>这里的顺序中，事务B在事务A提交后的快照读和当前读都是实时的新数据400，为什么？</p>
<ul>
<li>这里与上表的唯一区别仅仅是<code>表 1</code>的事务 B 在事务 A 修改金额前<code>快照读</code>过一次金额数据，而<code>表 2</code>的事务B在事务A修改金额前没有进行过快照读。</li>
</ul>
<p><strong>所以我们知道事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力</strong></p>
<p><strong>我们这里测试的是<code>更新</code>，同时<code>删除</code>和<code>更新</code>也是一样的，如果事务B的快照读是在事务A操作之后进行的，事务B的快照读也是能读取到最新的数据的</strong></p>
<h4 id="RC、RR级别下的InnoDB快照读有什么不同？"><a href="#RC、RR级别下的InnoDB快照读有什么不同？" class="headerlink" title="RC、RR级别下的InnoDB快照读有什么不同？"></a>RC、RR级别下的InnoDB快照读有什么不同？</h4><p> 正是 <code>Read View</code> 生成时机的不同，从而造成 RC , RR 级别下快照读的结果的不同 </p>
<ul>
<li>在 RR 级别下的某个事务的对某条记录的第一次快照读会创建一个快照及 Read View, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个 Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个 Read View，所以对之后的修改不可见；</li>
<li>即 RR 级别下，快照读生成 Read View 时，Read View 会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见</li>
<li>而在 RC 级别下的，事务中，每次快照读都会新生成一个快照和 Read View , 这就是我们在 RC 级别下的事务中可以看到别的事务提交的更新的原因</li>
</ul>
<p>总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View，之后的快照读获取的都是同一个Read View</p>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h3><p>这里介绍了<strong>MVCC</strong>在<strong>READ COMMITTED、REPEATABLE READ</strong>这两种隔离级别的事务在执行快照读操作时访问记录的版本链的过程。这样使不同事物的<strong>读-写、写-读</strong>操作并发执行，从而提升系统性能。</p>
<p>核心点在于ReadView的原理，READ COMMITED、REPEATABLE READ这两个隔离级别的一个很大不同就是ReadView的生成时机不同：</p>
<ul>
<li>READ COMMITED在每一次进行普通select操作前都会生成一个ReadView</li>
<li>REPEATABLE READ只在第一次进行普通select操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了</li>
</ul>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h3><h4 id="1-1如何提升数据库并发能力"><a href="#1-1如何提升数据库并发能力" class="headerlink" title="1.1如何提升数据库并发能力"></a>1.1如何提升数据库并发能力</h4><p>在实际工作中，我们常常将Redis作为缓存与MySQL配合来使用，当有请求的时候，首先会从缓存中进行查找，如果不存在再访问数据库，这样就<strong>提升了读取的效率</strong>，也减少了对后端数据库的<strong>访问压力</strong>。Redis的缓存架构是<strong>高并发架构</strong>中非常重要的一环。<img src="/2022/04/22/MySQL/1652348444218.png" alt="1652348444218" loading="lazy"></p>
<p>此外，一般应用对数据库而言都是“<strong>读多写少</strong>”，也就是说对数据库读取压力比较大，有一个思路就是采用数据库集群的方案，做<strong>主从架构</strong>、进行<strong>读写分离</strong>，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。</p>
<p>如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何<strong>优化SQL和索引</strong>，这种方式简单有效；其次才是采用<strong>缓存的策略</strong>，比如使用Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用<strong>主从架构</strong>，进行读写分离。</p>
<p>按照上面的方式进行优化，使用和维护的成本由低到高。</p>
<h4 id="1-2主从复制的作用"><a href="#1-2主从复制的作用" class="headerlink" title="1.2主从复制的作用"></a>1.2主从复制的作用</h4><p>主从同步设计不仅可以提高数据库的吞吐量，还有以下3个方面的作用</p>
<p><strong>第一个作用：读写分离</strong>。我们可以通过主从复制的方式来同步数据，然后通过读写分离提高数据库并发处理能力<img src="/2022/04/22/MySQL/1652429016082.png" alt="1652429016082" loading="lazy"></p>
<p>其中一个是Master主库，负责写入数据，我们称之为写库。</p>
<p>其他都是Slave从库，负责读取数据，我们称之为：读库。</p>
<p>当主库更新时，会自动将数据复制到从库中，而我们在客户端读数据的时候，会从从库中读取。面对“读多写少”的需求，采用读写分离的方式，可以实现<strong>更高的并发访问</strong>。同时，我们还能对从服务器进行<strong>负载均衡</strong>，让不同的去请求按照策略均匀地分发到不同的从服务器上，让<strong>读取更顺畅</strong>。读取顺畅的另一个原因，就是<strong>减少了表锁</strong>的影响，比如我们让主库负责写，当主库出现写锁的时候，不会影响从库进行SELECT的读取。</p>
<p><strong>第2个作用就是数据备份</strong>。我们通过主从复制将主库上的数据复制到了从库上，相当于是一种<strong>热备份机制</strong>，也就是在主库正常运行的情况下进行的备份，不会影响到服务。</p>
<p><strong>第3个作用就是高可用性</strong>。数据备份实际上是一种冗余的机制，通过这种冗余的方式可以换取数据库的高可用性，也就是当服务器出现<strong>故障或宕机</strong>的情况下，可以切换到从服务器上，保证服务的正常运行。</p>
<p>关于高可用性的程度，我们可以用一个指标衡量，即正常可用时间/全年时间，比如要达到全年99.999%的时间都可用，就意味着系统在一年中的不可用时间不得超过<img src="/2022/04/22/MySQL/1652430305898.png" alt="1652430305898" style="zoom: 67%;" loading="lazy">分钟（含系统崩溃时间、日常维护操作导致的停机时间等），其他时间都需要保持可用状态。</p>
<p>实际上，更高的高可用性，意味着需要付出更高的成本代价。在现实中我们需要结合业务需求和成本来进行选择。</p>
<h3 id="2-主从复制的原理"><a href="#2-主从复制的原理" class="headerlink" title="2.主从复制的原理"></a>2.主从复制的原理</h3><p><strong>Slave</strong>会从<strong>Master</strong>读取<strong>binlog</strong>来进行数据同步。</p>
<h4 id="2-1原理剖析"><a href="#2-1原理剖析" class="headerlink" title="2.1原理剖析"></a>2.1原理剖析</h4><p><strong>三个线程</strong></p>
<p>实际上主从同步的原理就是基于binlog进行数据同布的。在主从复制过程中，会基于<strong>3个线程</strong>来操作，一个主库线程，两个从库线程。<img src="/2022/04/22/MySQL/1652431025956.png" alt="1652431025956" loading="lazy"></p>
<p><strong>二进制日志转储线程（Binlog dump thread）</strong>是一个主库线程。当从库线程连接的时候，主库可以将二进制日志发给从库，当主库读取事件（Event）的时候，会在Binlog上<strong>加锁</strong>，读取完成之后，再将锁释放掉。</p>
<p><strong>从库I/O线程</strong>会连接到主库，向主库发送请求更新Binlog。这时从库的I/O线程就可以读取到主库的二进制日志转储线程发送的Binlog更新部分，并且拷贝到本地的中继日志（Relay log）。</p>
<p><strong>从库SQL线程</strong>会读取从库中的中继日志，并且执行日志中的事件，将从库的数据于主库保持同步。</p>
<p><img src="/2022/04/22/MySQL/1652431463999.png" alt="1652431463999" loading="lazy"></p>
<blockquote>
<p>注意：</p>
<p>不是所有版本的MySQL都默认开启服务器的二进制日志。在进行同步的时候，我们需要先检查服务是否已经开启了二进制日志。</p>
<p>除非特殊指定，默认情况下从服务器会执行所有主服务器中保存的事件。也可以通过配置，使从服务器执行特定的事件。</p>
</blockquote>
<p><strong>复制三步骤</strong></p>
<p>步骤1：<strong>Maste</strong>r将写操作记录到二进制日志（binlog），这些记录叫做二进制日志事件（binary log events）</p>
<p>步骤2：<strong>Slave</strong>将<strong>Master</strong>的binary log events拷贝到它的中继日志（relay log）</p>
<p>步骤3：<strong>Slave</strong>重做中继日志中的事件，将改变应用到自己的数据库中，MySQL复制是异步的且串行化的，而且重启后从加入点开始复制。</p>
<p><strong>复制的问题</strong></p>
<p>复制的最大问题：<strong>延时</strong></p>
<h4 id="2-2复制的基本原则"><a href="#2-2复制的基本原则" class="headerlink" title="2.2复制的基本原则"></a>2.2复制的基本原则</h4><ul>
<li>每个<strong>Slave</strong>hi只有一个<strong>Master</strong></li>
<li>每个<strong>Slave</strong>只有一个唯一的服务器ID</li>
<li>每个<strong>Master</strong>可以有多个<strong>Slave</strong></li>
</ul>
<h3 id="3-一主一从架构搭建"><a href="#3-一主一从架构搭建" class="headerlink" title="3.一主一从架构搭建"></a>3.一主一从架构搭建</h3><p>一台主机用于处理所有写请求，一台从服务器用来处理所有读请求，架构图如下：<img src="/2022/04/22/MySQL/1652462253464.png" alt="1652462253464" loading="lazy"></p>
<h4 id="3-1准备工作"><a href="#3-1准备工作" class="headerlink" title="3.1准备工作"></a>3.1准备工作</h4><p>1.准备2台centos虚拟机</p>
<p>2.每台虚拟机上需要安装号MySQL</p>
<p>说明：前面讲过如何克隆一台CentOS。可以通过在一台CentOS上安装MySQL，进而通过克隆方式复制出一台包含MySQL的虚拟机</p>
<p>注意：克隆方式需要修改新克隆出的主机的：MAC地址、hostname、IP地址、UUID</p>
<p>此外，克隆方式生成的虚拟机（包含MySQL Sever），则克隆的虚拟机MySQL Sever的UUID相同，必修修改，否则在有些场景会报错。比如，show slave status\G，则包如下错误：<img src="/2022/04/22/MySQL/1652443319986.png" alt="1652443319986" loading="lazy"></p>
<p>修改MySQL Sever的UUID方式：</p>
<p><img src="/2022/04/22/MySQL/1652443344519.png" alt="1652443344519" loading="lazy"></p>
<h4 id="3-2主机配置文件"><a href="#3-2主机配置文件" class="headerlink" title="3.2主机配置文件"></a>3.2主机配置文件</h4><p>建议mysql版本一致且后台以服务运行，主从所有配置项都配置在[mysqld]节点下，且都是小写字母。</p>
<p>具体参数配置如下：</p>
<ul>
<li><p>必选</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[必须]主服务器唯一ID</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[必须]启用二进制日志，指名路径，比如：自己本地的路径/log/mysqlbin</span></span><br><span class="line"><span class="attr">log-bin</span>=<span class="string">atguigu-bin</span></span><br></pre></td></tr></table></figure></li>
<li><p>可选</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[可选]0（默认）表示读写（读写）、1表示只读（从机）</span></span><br><span class="line"><span class="attr">read-only</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#设置单个日志文件保留的时长，单位是秒</span></span><br><span class="line"><span class="attr">binlog_expire_logs_seconds</span>=<span class="string">6000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#控制单个二进制日志大小。此参数的最大值和默认值是1GB</span></span><br><span class="line"><span class="attr">max_binlog_size</span>=<span class="string">200M</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[可选]设置不要复制的数据库</span></span><br><span class="line"><span class="attr">binlog-ignore-db</span>=<span class="string">test</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[可选]设置需要复制的数据库，默认全部记录。比如:binlog-do-db=atguigu_master_slave</span></span><br><span class="line"><span class="attr">binlog</span>=<span class="string">do-db=需要复制的主数据库名字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[可选]设置binglog格式</span></span><br><span class="line"><span class="attr">binlog_format</span>=<span class="string">STATEMENT</span></span><br></pre></td></tr></table></figure>

<p>重启后台mysql服务，使配置生效。</p>
<blockquote>
<p>注意：</p>
<p>先搭建完主从复制，再创建数据库</p>
<p>MySQL主从复制起始时，从机不继承主机数据</p>
</blockquote>
</li>
</ul>
<p><strong>binlog格式设置：</strong></p>
<p>格式1：<strong>STATEMENT模式</strong>（基于SQL语句的复制(statement-based replication，SBR)）</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">binlog_format-STATEMENT</span></span><br></pre></td></tr></table></figure>

<p>每一条会修改数据的sql语句会记录到binglog中，这是默认binglog格式。</p>
<ul>
<li><p>SBR的优点：</p>
<ul>
<li>历史悠久，技术成熟</li>
<li>不需要记录每一行的变化</li>
<li>binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况</li>
<li>binlog可以用于实时的还原，而不仅仅用于复制</li>
<li>主从复制可以不一样，从服务器版本可以比主服务器版本高</li>
</ul>
</li>
<li><p>SBR的缺点：</p>
<ul>
<li>不是所有的UPDATE语句都能被复制，尤其包含不确定的操作的时候</li>
</ul>
</li>
<li><p>使用以下函数的语句也无法被复制：LOAD_FILE()、UUID()、USER()、FOUND_ROWS()、SYSDATE()(除非启动时启用了–sysdate-is-now选项)</p>
<ul>
<li>INSERT—SELECT会产生比RBR更多的行级锁</li>
<li>复制需要进行全表扫描（WHERE语句中没有使用到索引）的UPDATE时，需要比RBR请求更多的行级锁</li>
<li>对于有AUTO_INSERT字段的InnoDB表而言，INSERT语句会阻塞其他INSERT语句</li>
<li>对于一些复杂的语句，在从服务器上的耗资源情况会更严重，而RBR模式下，只会对那个发生变化的记录产生影响</li>
<li>执行复杂语句如果出错的话，会消耗更多资源</li>
<li>数据表必须几乎和主服务器保持一致才行，否则可能会导致复制出错</li>
</ul>
</li>
</ul>
<p>格式2：<strong>ROW模式（基于行的复制(row-based replication，RBR)）</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">binlog_format</span>=<span class="string">ROW</span></span><br></pre></td></tr></table></figure>

<p>5.1.5版本的MySQL才开始支持，不记录每条sql语句的上下文信息，仅记录哪条数据被修改了，修改成什么样子<img src="/2022/04/22/MySQL/1652450290525.png" alt="1652450290525" loading="lazy"></p>
<p>格式3：<strong>MIXED模式（混合模式复制(mixed-based replicatino,MBR)）</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">binlog_format</span>=<span class="string">MIXED</span></span><br></pre></td></tr></table></figure>

<p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。</p>
<p>在Mixed模式下，一般的语句修改使用statement格式保存binlog，如一些函数，statement无法完成复制的操作，则采用row格式保存binlog。</p>
<p>MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在statement和row之间选择一种。</p>
<h4 id="3-3-从机配置文件"><a href="#3-3-从机配置文件" class="headerlink" title="3.3.从机配置文件"></a>3.3.从机配置文件</h4><p>要求主从所有配置项都配置在my.cnf的[mysqld]栏位下，且都是小写字母。</p>
<ul>
<li><p>必选</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[必须]从服务器唯一ID</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure></li>
<li><p>可选</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[可选]启用中继日志</span></span><br><span class="line"><span class="attr">relay-log</span>=<span class="string">mysql-relay</span></span><br></pre></td></tr></table></figure>

<p>重启后台mysql服务，使配置生效。</p>
<blockquote>
<p>注意：主从机都关闭防火墙</p>
<p>service iptables stop #CentOS 6</p>
<p>systemctl stop firewalld.service #CentOS 7</p>
</blockquote>
</li>
</ul>
<h4 id="3-4主机：建立账户并授权"><a href="#3-4主机：建立账户并授权" class="headerlink" title="3.4主机：建立账户并授权"></a>3.4主机：建立账户并授权</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在主机MySQL里执行授权主从复制的命令</span></span><br><span class="line"><span class="attr">GRANT</span> <span class="string">REPLICATION SLAVE ON *.* TO &#x27;slave1&#x27;@‘从机器数据库IP’ IDENTIFIED BY &#x27;abc123&#x27;;#5.5,5.7</span></span><br></pre></td></tr></table></figure>

<p>注意：使用的是MySQL8，需要使用如下方式建立账户，并授权slave：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CREATE</span> <span class="string">USER &#x27;slave1&#x27;@‘%’ IDENTIFIED BY &#x27;123456&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">GRANT</span> <span class="string">REPLICATION SLAVE ON *.* TO &#x27;slave1&#x27;@‘%’;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#此语句必须之心，否则见下面</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">USER &#x27;slave1&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">flush</span> <span class="string">privileges;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：在从机执行show slave staus\G时报错：</p>
</blockquote>
<p><img src="/2022/04/22/MySQL/1652495493057.png" alt="1652495493057" loading="lazy"></p>
<p>查询Master的状态，并记录下File和Position的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652495571131.png" alt="1652495571131" loading="lazy"></p>
<ul>
<li>记录下File和Position的值</li>
</ul>
<blockquote>
<p>注意：执行完此步骤后不再操作主服务器MySQL，防止主服务器状态值变化</p>
</blockquote>
<h4 id="3-5从机：配置需要复制的主机"><a href="#3-5从机：配置需要复制的主机" class="headerlink" title="3.5从机：配置需要复制的主机"></a>3.5从机：配置需要复制的主机</h4><p>步骤1：从机上复制主机的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER T0</span><br><span class="line">MASTER_HOST=&#x27;主机的IP地址&#x27;,</span><br><span class="line">MASTER_USER=&#x27;主机用户名&#x27;,</span><br><span class="line">MASTER_PASSWORD-&#x27;主机用户名的密码&#x27;,</span><br><span class="line">MASTER_LOG_FILE=&#x27;MYSQL-BIN.具体数字&#x27;,</span><br><span class="line">MASTER_LOG_POS=&#x27;具体值&#x27;;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER T0</span><br><span class="line">MASTER_HOST=&#x27;192.168.1.150&#x27;,MASTER_USER=&#x27;slave1&#x27;,MASTER_PASSWORD=&#x27;123456&#x27;,MASTER_LOG_FILE=&#x27;atguigu-bin.000007&#x27;,MASTER_LOG_POS=&#x27;154&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652495968713.png" alt="1652495968713" loading="lazy"></p>
<p><img src="/2022/04/22/MySQL/1652496020652.png" alt="1652496020652" loading="lazy"></p>
<p>步骤2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#启动slzve同步</span><br><span class="line">START SLAVE;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652496079386.png" alt="1652496079386" loading="lazy"></p>
<p>如果报错：<img src="/2022/04/22/MySQL/1652496104951.png" alt="1652496104951" loading="lazy"></p>
<p>可以执行以下操作，删除之前的relay_log信息，然后重新执行CHANGE MASTER TO……语句即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; reset slave; #删除slave数据库的relaylog日志文件，并重新启用新的relaylog文件</span><br></pre></td></tr></table></figure>

<p>接着查看同步状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW SLAVE STATUS\G;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/22/MySQL/1652496322341.png" alt="1652496322341" loading="lazy"></p>
<blockquote>
<p>上面连个参数都是YES，则说明主从配置成功</p>
</blockquote>
<p>显示如下，说明不正确</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.网络不同</span><br><span class="line">2.账户密码错误</span><br><span class="line">3.防火墙</span><br><span class="line">4.mysql配置文件问题</span><br><span class="line">5.连接服务器时语法</span><br><span class="line">6.主服务器mysql权限</span><br></pre></td></tr></table></figure>

<h4 id="3-6测试"><a href="#3-6测试" class="headerlink" title="3.6测试"></a>3.6测试</h4><p>主机新建库、新建表、insert记录，从机复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE atguigu_master_slave;</span><br><span class="line">CREATE TABLE mytbl(id IND,NAME VARCHAR(16));</span><br><span class="line">INSERT INTO mytbl VALUES(1,&#x27;zhang3&#x27;);</span><br><span class="line">INSERT INTO mytbl VALUES(2,@@hostname);</span><br></pre></td></tr></table></figure>



<h4 id="3-7停止主从同步"><a href="#3-7停止主从同步" class="headerlink" title="3.7停止主从同步"></a>3.7停止主从同步</h4><ul>
<li><p>停止主从同步命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure></li>
<li><p>如何重新配置主从</p>
<p>如果停止从服务器复制功能，再使用需要重新配置主从。否则会报错：<img src="/2022/04/22/MySQL/1652496673385.png" alt="1652496673385" loading="lazy"></p>
</li>
</ul>
<p>再重新配置主从，需要在从机上执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">reset master;#删除Master种所有的binlog文件，并将日志索引文件清空，重新开始所有新的日志文件</span><br></pre></td></tr></table></figure>

<h4 id="3-8后续"><a href="#3-8后续" class="headerlink" title="3.8后续"></a>3.8后续</h4><p><strong>搭建主从复制：双主双从</strong></p>
<p>一个主机m1用于处理所有写请求，它的从机s1和另一个主机m2还有它的从机s2负责所有读请求。当m1主机宕机后，m2主机负责写请求，m1、m2互为备机    。架构图如下：<img src="/2022/04/22/MySQL/1652497523655.png" alt="1652497523655" loading="lazy"></p>
<h3 id="4-同步数据一致性的问题"><a href="#4-同步数据一致性的问题" class="headerlink" title="4.同步数据一致性的问题"></a>4.同步数据一致性的问题</h3><p><strong>主从同步的要求：</strong></p>
<ul>
<li>读库和写库的数据一致（最终一致）</li>
<li>写数据必须写到写库</li>
<li>读数据必须到读库（不一定）</li>
</ul>
<h4 id="4-1理解主从延迟问题"><a href="#4-1理解主从延迟问题" class="headerlink" title="4.1理解主从延迟问题"></a>4.1理解主从延迟问题</h4><p>进行主从同步的内容的二进制日志，它是一个文件，在进行<strong>网络传输</strong>的过程中就一定会存在<strong>主从延迟</strong>（比如500ms），这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的<strong>数据不一致性</strong>问题</p>
<p><strong>举例：</strong>导致主从延迟的时间点主要包括以下三个：</p>
<ul>
<li>主库A执行完成一个事务，写入binlog，这个时刻为T1</li>
<li>之后传给从库B，从库B接收完这个binlog的时刻记为T2</li>
<li>从库B执行完成这个事务的时刻记为T3</li>
</ul>
<h4 id="4-2主从延迟问题原因"><a href="#4-2主从延迟问题原因" class="headerlink" title="4.2主从延迟问题原因"></a>4.2主从延迟问题原因</h4><p>在网络正常的情况下，日志从主库传给从库所需的时间很短，即T2-T1的值非常小。即，网络正常情况下，主备延迟的<strong>主要来源是备库接收完binlog和执行完这个事务之间的时间差</strong></p>
<p><strong>主备延迟最直接的表现是，从库消费中继日志(relay log)的速度，比主库生产binog的速度要慢</strong>。造成原因：</p>
<ol>
<li>从库的机器性能比主库要差</li>
<li>从库的压力大</li>
<li>大事务的执行</li>
</ol>
<p>举例1：一次性用delete语句删除太多数据</p>
<p>结论：后续再删除的时候，要控制每个事务的删除的数据量，分成多次删除</p>
<p>举例2：一次性用insert…select插入太多数据 </p>
<p>举例3：大表DDL</p>
<p>比如在主库对一张500W的表添加一个字段耗费了10分钟，那么从节点上也会耗费10分钟</p>
<h4 id="4-3如何减少主从延迟"><a href="#4-3如何减少主从延迟" class="headerlink" title="4.3如何减少主从延迟"></a>4.3如何减少主从延迟</h4><p>若想要减少主从延迟的时间，可以采取下面的办法：</p>
<ol>
<li>降低多线程大事务并发的概率，优化业务逻辑</li>
<li>优化SQL，避免慢SQL，<strong>减少批量操作</strong>，建议写脚本以update-sleep这样的形式完成。</li>
<li><strong>提高从库机器的配置</strong>，减少主库写binlog和从库读binlog的效率差</li>
<li>尽量采用<strong>短的链路</strong>，也就是主库和从库服务器的举例尽量要短，提升端口带宽，减少binlog传输的网络延时</li>
<li>实时性要求的业务读强制走主库，从库只做备库，备份。</li>
</ol>
<h4 id="4-4如何解决一致性问题"><a href="#4-4如何解决一致性问题" class="headerlink" title="4.4如何解决一致性问题"></a>4.4如何解决一致性问题</h4><p>如果操作的数据存储在同一个数据库中，那么对数据进行更新的时候，可以对记录加写锁，这样在读取的时候就不会发生数据不一致的情况。但这时从库的作用就是 <strong>备份</strong> ，并没有起到 <strong>读写分离</strong> ，<strong>分担主库读压力</strong> 的作用。 <img src="/2022/04/22/MySQL/1652498741807.png" alt="1652498741807" loading="lazy"></p>
<p>读写分离情况下，解决主从同步中数据不一致的问题，就是解决主从之间<strong>数据复制方式</strong>的问题，如果按照数据一致性<strong>从弱到强</strong>来进行划分，有以下3种复制方式。</p>
<p><strong>方法1：异步复制</strong></p>
<p>异步模式就是客户端提交COMMOT之后不需要等从库返回结果，而是直接将结果返回给客户端，这样做的好处就是不会影响主库写的效率，但可能会存在主库宕机，而binlog还没有同步到从库的情况，也就是此时的主库和从库数据不一致。这时候从从库种选择一个作为新主，那么新主机则可能缺少原来主服务器种已提交的事务。所以，这种复制模式下的数据一致性是最弱的<img src="/2022/04/22/MySQL/1652515436179.png" alt="1652515436179" loading="lazy"></p>
<p><strong>方法2：半同步复制</strong></p>
<p>MySQL5.5版本之后开始支持半同步复制的方式。原理就是客户端提交commit之后不直接将结果返回客户端，而是等待至少有一个从库接收到了binlog，并且写入到中继日志，再返回客户端。</p>
<p>这样做的好处就是提高了数据的一致性，当然相比于异步复制来说，至少多增加了了一个网络连接的延迟，降低了主库写的效率。</p>
<p>在MySQL5.7版本中还增加了一个rpl_semi_sync_master_wait_for_slave_count参数，可以对应答的从库数量进行控制，默认为1，也就是说之要有1和从库进行了响应，就可以返回给客户端，如果将这个参数调大，可以提升数据一致性的强度，但也会增加主库等待从库响应的时间。<img src="/2022/04/22/MySQL/1652516168388.png" alt="1652516168388" loading="lazy"></p>
<p><strong>方法3：组复制</strong></p>
<p>异步复制和半同步复制都无法最终保证数据一致性问题，半同步复制是通过判断从库响应的个数来决定是否返回客户端，虽然数据一致性相比与异步复制有提升，但仍然无法满足对数据一致性要求高的场景，比如金额领域。MGR很好地弥补了这两种复制模式地不足。</p>
<p>组复制技术，简称MGR（MySQL Group Replication）。是MySQL5.7.17版本中推出的一种新的数据复制技术。这种技术是基于Paxos协议的状态机复制。</p>
<p><strong>MGR是如何工作的</strong></p>
<p>首先我们将多个节点共同组成一个复制组，<strong>在 执行读写（RW）事务</strong> 的时候，需要通过一致性协议层 （Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节 点）的同意，大多数指的是同意的节点数量需要大于 （N/2+1），这样才可以进行提交，而不是原发起 方一个说了算。而针对 只读（RO）事务 则不需要经过组内同意，直接 COMMIT 即可。 </p>
<p>在一个复制组内有多个节点组成，它们各自维护了自己的数据副本，并且在一致性协议层实现了原子消息和全局有序消息，从而保证组内数据的一致性。</p>
<p><img src="/2022/04/22/MySQL/1652516682376.png" alt="1652516682376" loading="lazy"></p>
<p>MGR 将 MySQL 带入了数据强一致性的时代，是一个划时代的创新，其中一个重要的原因就是MGR 是基于 Paxos 协议的。Paxos 算法是由 2013 年的图灵奖获得者 Leslie Lamport 于 1990 年提出的，有关这个算法的决策机制可以搜一下。事实上，Paxos 算法提出来之后就作为 分布式一致性算法 被广泛应用，比如 Apache 的 ZooKeeper 也是基于 Paxos 实现的。</p>
<h3 id="5-知识延伸"><a href="#5-知识延伸" class="headerlink" title="5.知识延伸"></a>5.知识延伸</h3><p>在主从架构的配置中，如果想要采取读写分离的策略，我们可以自己编写程序，也可以通过第三方的中间件来实现。</p>
<ul>
<li>自己编写程序的好处就在于比较自主，我们可以自己判断哪些查询在从库上来执行，针对实时性要求高的需求，我们还可以考虑哪些查询可以在主库上执行。同时，程序直接连接数据库，减少了中间件层，相当于减少了性能损耗。</li>
<li>采用中间件的方法有很明显的优势， 功能强大 ， 使用简单 。但因为在客户端和数据库之间增加了中间件层会有一些 性能损耗 ，同时商业中间件也是有使用成本的。我们也可以考虑采取一些优秀的开源工具。 <img src="/2022/04/22/MySQL/1652516907424.png" alt="1652516907424" loading="lazy"></li>
</ul>
<p>① Cobar 属于阿里B2B事业群，始于2008年，在阿里服役3年多，接管3000+个MySQL数据库的schema,集群日处理在线SQL请求50亿次以上。由于Cobar发起人的离职，Cobar停止维护。 </p>
<p>② Mycat 是开源社区在阿里cobar基础上进行二次开发，解决了cobar存在的问题，并且加入了许多新的功能在其中。青出于蓝而胜于蓝。③ OneProxy 基于MySQL官方的proxy思想利用c语言进行开发的，OneProxy是一款商业 收费 的中 间件。舍弃了一些功能，专注在 性能和稳定性上 。 </p>
<p>④ kingshard 由小团队用go语言开发，还需要发展，需要不断完善。 </p>
<p>⑤ Vitess 是Youtube生产在使用，架构很复杂。不支持MySQL原生协议，使用 需要大量改造成 本 。 </p>
<p>⑥ Atlas 是360团队基于mysql proxy改写，功能还需完善，高并发下不稳定。 </p>
<p>⑦ MaxScale 是mariadb（MySQL原作者维护的一个版本） 研发的中间件 </p>
<p>⑧ MySQLRoute 是MySQL官方Oracle公司发布的中间件 </p>
<p><img src="/2022/04/22/MySQL/1652516948614.png" alt="1652516948614" loading="lazy"></p>
<p><img src="/2022/04/22/MySQL/1652516956893.png" alt="1652516956893" loading="lazy"></p>
<p>主备切换：<img src="/2022/04/22/MySQL/1652516971520.png" alt="1652516971520" loading="lazy"></p>
<ul>
<li>主动切换</li>
<li>被动切换</li>
<li>如何判断主库出问题了？如何解决过程中的数据不一致性问题？</li>
</ul>
<h2 id="数据库备份与恢复"><a href="#数据库备份与恢复" class="headerlink" title="数据库备份与恢复"></a>数据库备份与恢复</h2><p>在任何数据库环境中，总会有不确定的意外情况发生，比如断电、计算机各种应将故障、人为破坏、管理员失误操作等是不可避免地，这些情况会导致<strong>数据的丢失、服务器瘫痪</strong>等后果。存在多个服务器时，会出现主从服务器之间地<strong>数据同步问题</strong></p>
<p>为了有效防止数据丢失，并将损失降到最低，应定期对MySQL数据库服务器做备份。</p>
<h3 id="1-物理备份与逻辑备份"><a href="#1-物理备份与逻辑备份" class="headerlink" title="1.物理备份与逻辑备份"></a>1.物理备份与逻辑备份</h3><p><strong>物理备份</strong>：备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比 较大，MySQL中可以用 xtrabackup 工具来进行物理备份。 </p>
<p><strong>逻辑备份</strong>：对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空 间小，更灵活。MySQL 中常用的逻辑备份工具为 mysqldump 。逻辑备份就是 备份sql语句 ，在恢复的时候执行备份的sql语句实现数据库数据的重现。</p>
<h3 id="2-mysqldump实现逻辑备份"><a href="#2-mysqldump实现逻辑备份" class="headerlink" title="2.mysqldump实现逻辑备份"></a>2.mysqldump实现逻辑备份</h3><p>mysqld是MySQL提供的一个非常有用的数据库备份工具</p>
<p>2.1备份一个数据库</p>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/images/alipay.jpg"><img loading="lazy" src="/images/alipay.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/wechatpay.png"><img loading="lazy" src="/images/wechatpay.png" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>翔仔</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://example.com/2022/04/22/MySQL/" title="MySQL">http://example.com/2022/04/22/MySQL/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022/04/25/%E5%89%8D%E7%BC%80%E4%B8%8E%E8%B4%AA%E5%BF%83/" rel="prev" title="前缀与贪心"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">前缀与贪心</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2022/04/18/JVM/" rel="next" title="JVM"><span class="post-nav-text">JVM</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2022 </span><span class="with-love" id="animate" title="云游君的赞助者们"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 翔仔</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.2</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.8.11</span></div><div class="live-time"><span>本博客已运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2022-04-10T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} 天 ${passHour} 小时 ${passMinute} 分 ${passSecond} 秒`;
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>